import path from 'path';
import _ from 'lodash';

import { ContentStoreTypes } from '@stackbit/cms-core';
import { Logger } from '@stackbit/types';
import { Config } from '@stackbit/sdk';
import { omitByNil, isTruthy } from '@stackbit/utils';

import { getNameSlugFromPath } from '../utils/file-utils';
import { getFlattenModels } from '../utils/schema-utils';
import { extractTokensFromString, convertToRegularTokens, interpolatePageUrlFromFilePath, forEachField } from '../utils/code-utils';
import { lazilyResolveObjectsWithAnnotationTree } from '../services/annotations/annotation-tree-parser';
import { PageNotFoundError } from '../services/response-errors';
import { createPreset, generatePresetFileName, PresetParams } from '../services/presets-service';
import { CommitAndPushChanges, ContentStoreAdapter } from '../cms/content-store-adapter';
import type { Schema, CollectionItem, CollectionItemWithModel, PageModel, SiteMap, Collections } from '../types';

export interface EditorOptions {
    contentStoreAdapter: ContentStoreAdapter;
    stackbitConfig: Config | null;
    logger: Logger;
    userLogger: Logger;
    stackbitUrlPathField: string;
    staticAssetsPublicPath?: string;
    commitAndPushChanges?: CommitAndPushChanges;
}

export default class Editor {
    private readonly contentStoreAdapter: ContentStoreAdapter;
    private readonly logger: Logger;
    private readonly userLogger: Logger;
    private readonly stackbitUrlPathField: string;
    private readonly staticAssetsPublicPath?: string;
    private readonly commitAndPushChanges?: CommitAndPushChanges;
    private stackbitConfig: Config | null;

    constructor(options: EditorOptions) {
        this.contentStoreAdapter = options.contentStoreAdapter;
        this.stackbitConfig = options.stackbitConfig;
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.stackbitUrlPathField = options.stackbitUrlPathField;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.commitAndPushChanges = options.commitAndPushChanges;
    }

    onStackbitConfigChange({ stackbitConfig }: { stackbitConfig: Config | null }) {
        this.stackbitConfig = stackbitConfig;
    }

    buildUrlForPage(pageModel: PageModel, document: ContentStoreTypes.Document, locale?: string, urlPathTemplateParams?: Record<string, any>): string | null {
        const pagesDir = this.stackbitConfig?.pagesDir || '';

        function getLocalizedFieldFromPageEntry(document: ContentStoreTypes.Document, fieldName: string): string | undefined {
            const docField = document.fields[fieldName];
            if (!docField) {
                return;
            } else if ('value' in docField) {
                return _.get(docField, 'value');
            } else if ('locales' in docField && locale && locale in docField.locales) {
                return _.get(docField, ['locales', locale, 'value']);
            } else {
                return undefined;
            }
        }

        const normalizeUrl = (urlPath: string) => urlPath.replace(/\/+/g, '/');

        // For projects using Git CMS, the URL needs to be computed from the `srcObjectId` and pageModel.
        if (document.srcType === 'git') {
            const pageObjects = this.contentStoreAdapter.getLocalizedApiObjects({
                objectIds: [document.srcObjectId]
            });
            const pageObject = pageObjects.find((pageObject) => pageObject.srcProjectId === document.srcProjectId && pageObject.srcType === document.srcType);
            if (!pageObject) {
                throw new Error(`Can't get page url, object with given objectId not found: ${document.srcObjectId}`);
            }
            const pageData: any = {};
            for (const fieldName in document.fields) {
                const fieldValue = getLocalizedFieldFromPageEntry(document, fieldName);
                if (typeof fieldValue !== 'undefined') {
                    pageData[fieldName.replace(/^_filePath_/, '')] = fieldValue;
                }
            }
            return normalizeUrl(
                interpolatePageUrlFromFilePath({
                    pageFilePath: document.srcObjectId,
                    pageModel,
                    pageData,
                    pagesDir,
                    logger: this.userLogger
                })
            );
        }

        // For projects that use urlPath
        if (pageModel.urlPathTokens) {
            return pageModel.urlPathTokens.reduce((urlPath: string | null, fieldName) => {
                if (!urlPath) {
                    return null;
                }
                let fieldValue: string | undefined;
                if (fieldName.startsWith('params.')) {
                    const paramFieldName = fieldName.replace('params.', '');
                    fieldValue = _.get(urlPathTemplateParams, paramFieldName);
                } else {
                    fieldValue = getLocalizedFieldFromPageEntry(document, fieldName);
                }
                if (typeof fieldValue === 'undefined') {
                    return null;
                }
                return normalizeUrl(urlPath.replace(`{${fieldName}}`, fieldValue));
            }, pageModel.urlPath);
        }

        // For API-based CMS projects, we have a `slugField` that contains the name of the field
        // used to compute the slug. We can just take it and replace its value directly.
        const slugFieldValue = getLocalizedFieldFromPageEntry(document, pageModel.slugField);

        // For projects not using stackbit-pull but do have 'stackbit_url_path' (nextjs + sourcebit),
        // use the value of 'stackbit_url_path' as page URL
        if (pageModel.slugField === this.stackbitUrlPathField) {
            return slugFieldValue ?? null;
        }

        if (!slugFieldValue) {
            return pageModel.urlPath;
        }

        return normalizeUrl(pageModel.urlPath.replace('{slug}', slugFieldValue));
    }

    async getSchema({ locale, user }: { locale?: string; user?: ContentStoreTypes.User }): Promise<Schema> {
        this.logger.debug('getSchema');
        const stackbitVersion = this.stackbitConfig?.stackbitVersion;
        const sidebarButtons = this.stackbitConfig?.sidebarButtons;
        const pageData = _.get(this.stackbitConfig, 'pageData');
        const duplicatableModels = _.get(this.stackbitConfig, 'duplicatableModels');
        const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ locale, user });
        const pageModels = this.getPageModels({ forSchema: true, user });
        const locales = this.contentStoreAdapter.getLocales();
        const isCSIEnabled = this.contentStoreAdapter.isContentStoreEnabled();
        const actions = await this.contentStoreAdapter.getGlobalActions({ locale, user });

        // status vs settings:
        // settings takes values directly from the stackbit.config (e.g. nodeVersion: 16)
        // status contains more dynamic values which might change even without config change or on the fly
        // and show more realistic values (e.g. nodeVersion: 16.20.0 <- real version, while in config it's just major 16)
        const status: Schema['status'] = omitByNil({
            hasConfig: !!this.stackbitConfig,
            isCSIEnabled,
            contentSourceTypes: isCSIEnabled ? this.contentStoreAdapter.getContentSourceTypes() : undefined,
            contentSourceMeta: isCSIEnabled ? this.contentStoreAdapter.getContentSourceMeta() : undefined,
            nodeVersion: process.version
        });

        const schema: Schema = {
            sidebarButtons,
            stackbitVersion,
            pageData,
            schema: modelsByContentSourceType,
            pageModels,
            locales,
            duplicatableModels,
            presets: this.contentStoreAdapter.getPresets({ locale }),
            assetSources: this.contentStoreAdapter.getAssetSources(),
            actions: actions,
            settings: {
                hcrHandled: this.stackbitConfig?.hcrHandled,
                ssgName: this.stackbitConfig?.ssgName,
                ssgVersion: this.stackbitConfig?.ssgVersion,
                nodeVersion: this.stackbitConfig?.nodeVersion,
                viewports: this.stackbitConfig?.viewports
            },
            status
        };

        return omitByNil(schema);
    }

    async getUrl(srcDocumentId: string, srcProjectId: string, srcType: string, locale?: string): Promise<string | null> {
        if (this.stackbitConfig?.siteMap) {
            const siteMapEntriesForDocument = this.contentStoreAdapter.getSiteMapEntriesForDocument({
                srcType: srcType,
                srcProjectId: srcProjectId,
                srcDocumentId: srcDocumentId,
                locale: locale
            });
            return _.isEmpty(siteMapEntriesForDocument) ? null : siteMapEntriesForDocument[0]!.urlPath;
        }
        const document = this.contentStoreAdapter.getDocument({
            srcDocumentId: srcDocumentId,
            srcProjectId: srcProjectId,
            srcType: srcType
        });
        if (!document) {
            throw PageNotFoundError;
        }
        const modelName = document.srcModelName;
        const allPageModels = this.getPageModels();
        const pageModels = _.filter(allPageModels, { modelName: modelName });

        if (pageModels.length === 0) {
            throw PageNotFoundError;
        }

        // DEPRECATED: This check exists for backwards-compatibility with projects that define multiple page models with
        // the same name (currently only PX). Therefore when we detect that more than one model matches the current
        // pageEntry and we're using a Git-based CMS, then try to find which of the page models is a match and return
        // a URL for that page.
        //
        // TODO: convert legacy pageModels to standard format and allow defining multiple urlPath and filePath per model
        //   as described here: https://www.notion.so/stackbit/Container-Revise-page-urlPath-logic-a6b902cdedb54add98b713de86d0a576
        //
        // Example:
        // pageModels:
        //   - modelName: blog-post
        //     label: Blog Post
        //     url: "/resources/blog/%slug%"
        //     filePath: "src/pages/resources/blog/%slug%.md"
        //   - modelName: blog-post
        //     label: Tech Blog Post
        //     url: "/tech-blog/%slug%"
        //     filePath: "src/pages/tech-blog/%slug%.md"
        //   - modelName: default-form
        //     label: "Whitepaper"
        //     url: "/resources/whitepapers/%slug%"
        //     filePath: "src/pages/resources/whitepapers/%slug%.md"
        //   - modelName: default-form
        //     label: "Report"
        //     url: "/resources/reports/%slug%"
        //     filePath: "src/pages/resources/reports/%slug%.md"
        if (pageModels.length > 1 && document.srcType === 'git') {
            let urlPath;

            _.forEach(pageModels, (pageModel) => {
                if (typeof pageModel.filePath !== 'string') {
                    return false;
                }
                const { slug } = getNameSlugFromPath(document.srcObjectId, pageModel.filePath);
                const currentFilePath = pageModel.filePath.replace('{slug}', slug);

                if (currentFilePath === document.srcObjectId) {
                    urlPath = pageModel.urlPath.replace('{slug}', slug);
                    return false;
                }
            });

            return urlPath ?? null;
        }

        const pageModel = pageModels[0]!;

        return this.buildUrlForPage(pageModel, document, locale, { locale });
    }

    getPageModels(options: { forSchema?: boolean; user?: ContentStoreTypes.User } = {}): PageModel[] {
        this.logger.debug('getPageModels');

        const pagesDir = this.stackbitConfig?.pagesDir || '';
        const documents = this.contentStoreAdapter.getDocuments({});

        // Legacy syntax using the `pageModels` key or the `CONTENT_PAGE_MODELS` environment variable.
        const legacyPageModels =
            _.get(this.stackbitConfig, 'pageModels') || (process.env.CONTENT_PAGE_MODELS ? JSON.parse(process.env.CONTENT_PAGE_MODELS) : undefined);

        if (Array.isArray(legacyPageModels)) {
            this.logger.debug('project uses legacy pageModels');
            return legacyPageModels.reduce((pageModels: PageModel[], model) => {
                const document = _.find(documents, (document) => document.srcModelName === model.modelName);

                if (!document) {
                    return pageModels;
                }

                const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ user: options.user });
                const schemaModels = _.get(modelsByContentSourceType, [document.srcType, document.srcProjectId]);
                const schemaModel = _.find(schemaModels, (schemaModel) => schemaModel.name === model.modelName);

                model.srcProjectId = document.srcProjectId;

                const urlPath = _.has(model, 'url') ? convertToRegularTokens(model.url) : '/{slug}';
                const filePath = _.has(model, 'filePath') ? convertToRegularTokens(model.filePath) : null;
                const pageModel: PageModel = {
                    modelName: model.modelName,
                    srcProjectId: model.srcProjectId,
                    srcEnvironment: document.srcEnvironment,
                    cmsId: document.srcType,
                    label: model.label || schemaModel?.label,
                    url: urlPath,
                    urlPath: urlPath,
                    filePath: filePath ?? _.trimStart(path.join(pagesDir, urlPath + '.md'), '/'),
                    slugField: model.slugField
                };

                return pageModels.concat(pageModel);
            }, []);
        } else {
            this.logger.debug('project uses stackbit config models');
            const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ user: options.user });
            return _.reduce(
                modelsByContentSourceType,
                (pageModels: PageModel[], modelsByContentSourceProjectId, srcType) => {
                    return _.reduce(
                        modelsByContentSourceProjectId,
                        (pageModels, modelsByName, srcProjectId) => {
                            return _.reduce(
                                modelsByName,
                                (pageModels, model, modelName) => {
                                    if (model.type !== 'page') {
                                        return pageModels;
                                    }

                                    const document = _.find(documents, (document) => document.srcModelName === modelName);
                                    if (document && _.get(options, 'forSchema') && (_.has(model, 'file') || _.get(model, 'singleInstance'))) {
                                        this.logger.debug(`page model '${modelName}' is singleInstance with existing instance`);
                                        return pageModels;
                                    }

                                    const urlPath = model.urlPath || '/{slug}';
                                    let filePath;
                                    let slugField: string;
                                    let urlPathTokens: string[] | undefined;

                                    if (!model.filePath || (options.forSchema && typeof model.filePath !== 'string')) {
                                        filePath = _.trimStart(path.join(pagesDir, urlPath + '.md'), '/');
                                    } else {
                                        filePath = model.filePath;
                                    }

                                    // In API-based CMS projects generated by Stackbit prior to v2, models have the 'stackbit_url_path'
                                    // field which stores the full url of the page. In these projects the urlPath is '/{slug}'.
                                    // Therefore we set the slugField to 'stackbit_url_path' which effectively makes the urlPath
                                    // to represent full page URL.
                                    if (_.find(model.fields, { name: this.stackbitUrlPathField })) {
                                        slugField = this.stackbitUrlPathField;
                                    } else {
                                        // Extract tokens from 'urlPath' and send them to the client.
                                        // These tokens will serve as parameters for the user to fill before creating a page.
                                        // for 404 pages urlPath could be parsed as number, cast it to string
                                        const tokens = extractTokensFromString(String(urlPath));
                                        // backwards compatibility until we migrate to using urlPathTokens
                                        // last token in urlPath is normally what user needs to provide
                                        slugField = _.last(tokens)!;
                                        urlPathTokens = tokens;
                                    }

                                    const pageModel: PageModel = {
                                        modelName: modelName,
                                        srcProjectId: srcProjectId,
                                        srcEnvironment: this.contentStoreAdapter.getContentSourceEnvironmentForContentSourceTypeAndId({
                                            srcType,
                                            srcProjectId
                                        }),
                                        cmsId: srcType,
                                        label: model.label!,
                                        url: urlPath,
                                        urlPath: urlPath,
                                        filePath: filePath,
                                        slugField: slugField,
                                        urlPathTokens: urlPathTokens
                                    };

                                    return pageModels.concat(pageModel);
                                },
                                pageModels
                            );
                        },
                        pageModels
                    );
                },
                []
            );
        }
    }

    async getSiteMap({ locale, user }: { locale?: string; user?: ContentStoreTypes.User }): Promise<SiteMap> {
        if (this.stackbitConfig?.siteMap) {
            const siteMapEntries = this.contentStoreAdapter.getSiteMapEntries({ locale, user });
            return _.reduce(
                siteMapEntries,
                (siteMap: SiteMap, siteMapEntry) => {
                    const urlPath = _.trim(siteMapEntry.urlPath, '/');
                    const urlPathParts = urlPath.split('/');

                    const documentData =
                        'document' in siteMapEntry
                            ? {
                                  srcType: siteMapEntry.document.srcType,
                                  srcProjectId: siteMapEntry.document.srcProjectId,
                                  srcModelName: siteMapEntry.document.modelName,
                                  objectId: siteMapEntry.document.id
                              }
                            : null;

                    let siteMapNode: SiteMap = siteMap;
                    urlPathParts.forEach((urlPart, index) => {
                        if (index === urlPathParts.length - 1) {
                            siteMapNode[urlPart] = {
                                url: `/${urlPath}`,
                                ...(siteMapEntry.locale ? { locale: siteMapEntry.locale } : {}),
                                title: siteMapEntry.label,
                                stableId: siteMapEntry.stableId,
                                ...(siteMapEntry.isHomePage ? { isHomePage: siteMapEntry.isHomePage } : {}),
                                ...documentData,
                                children: siteMapNode[urlPart]?.children ?? {}
                            };
                        } else if (!siteMapNode[urlPart]) {
                            siteMapNode[urlPart] = {
                                url: ['', ...urlPathParts.slice(0, index + 1)].join('/'),
                                children: {}
                            };
                        }
                        siteMapNode = siteMapNode[urlPart]!.children;
                    });

                    return siteMap;
                },
                {}
            );
        } else {
            return this.getSiteMap_deprecated({ locale });
        }
    }

    async getSiteMap_deprecated({ locale }: { locale?: string }): Promise<SiteMap> {
        const documents = this.contentStoreAdapter.getDocuments({ locale });
        const pageModels = this.getPageModels();
        const locales = this.contentStoreAdapter.getLocales();
        const pageModelsByName = _.keyBy(pageModels, 'modelName');
        const pageDocuments = documents.filter(({ srcModelName }) => pageModelsByName[srcModelName] !== undefined);
        const siteMap: SiteMap = {};

        const extendSiteMapForDocument = (pageDocument: ContentStoreTypes.Document, locale?: string) => {
            const pageModel = pageModelsByName[pageDocument.srcModelName]!;
            const pageUrl = this.buildUrlForPage(pageModel, pageDocument, locale, { locale });
            if (pageUrl === null) {
                return;
            }
            const url = _.trim(pageUrl, '/');
            const urlNodes = url.split('/');
            const leafNode = urlNodes.pop()!;

            let head: SiteMap = siteMap;

            urlNodes.forEach((node, index) => {
                head[node] = head[node] || {
                    children: {},
                    url: ['', ...urlNodes.slice(0, index), node].join('/')
                };
                head = head[node]!.children;
            });

            head[leafNode] = {
                children: {},
                environment: pageDocument.srcEnvironment,
                objectId: pageDocument.srcObjectId,
                srcType: pageDocument.srcType,
                srcProjectId: pageDocument.srcProjectId,
                srcModelName: pageDocument.srcModelName,
                ...(pageDocument.locale ? { locale: pageDocument.locale } : {}),
                source: 'schema',
                title: pageDocument.getPreview({ locale }).previewTitle,
                url: '/' + url,
                ...head[leafNode]
            };
        };

        pageDocuments.forEach((pageDocument) => {
            const localesForDocument = locales?.find(
                ({ srcType, srcProjectId }) => pageDocument.srcType === srcType && pageDocument.srcProjectId === srcProjectId
            );
            if (locale) {
                extendSiteMapForDocument(pageDocument, locale);
            } else if (localesForDocument?.locales.length) {
                localesForDocument.locales.forEach((localeCode) => {
                    extendSiteMapForDocument(pageDocument, localeCode);
                });
            } else {
                extendSiteMapForDocument(pageDocument, undefined);
            }
        });

        return siteMap;
    }

    populateReferenceLabels(
        objects: ContentStoreTypes.APIObject[],
        documentMap: Record<string, ContentStoreTypes.Document | ContentStoreTypes.Asset>,
        locale?: string
    ) {
        for (const object of objects) {
            forEachField(
                object,
                (field) => {
                    if (field && field.type === 'unresolved_reference' && field.refId) {
                        const document = documentMap[field.refId];
                        field.isMissing = !document;
                        if (document) {
                            field.srcObjectLabel = document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle;
                            field.srcModelLabel = document.srcModelLabel;
                        }
                    }

                    if (field && field.type === 'cross-reference' && field.refId) {
                        const document = documentMap[field.refId];
                        field.isMissing = !document;
                        if (document) {
                            field.refObjectLabel = document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle;
                            field.refModelLabel = document.srcModelLabel;
                            field.refModelName = document.srcModelName;
                        }
                    }
                },
                { includeKeyPath: false }
            );
        }
    }

    async getObjects({
        objectIds,
        locale,
        user
    }: {
        objectIds?: string[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ objects: ContentStoreTypes.APIObject[] }> {
        const apiDocuments = this.contentStoreAdapter.getLocalizedApiObjects({ locale, objectIds, user });
        const documentMap = _.keyBy([...this.contentStoreAdapter.getDocuments({ user }), ...this.contentStoreAdapter.getAssets({ user })], 'srcObjectId');
        if (objectIds) {
            this.populateReferenceLabels(apiDocuments, documentMap, locale);
        }
        return { objects: apiDocuments };
    }

    async getObjectsWithAnnotations({
        annotationTree = null,
        clientAnnotationErrors = [],
        resolveAllReferences = false,
        locale,
        reportAllErrors = false,
        user
    }: {
        annotationTree: any;
        clientAnnotationErrors: any;
        resolveAllReferences?: boolean;
        locale?: string;
        reportAllErrors: boolean;
        user?: ContentStoreTypes.User;
    }) {
        const cachedApiDocuments: Record<string, ContentStoreTypes.APIObject> = {};

        const { objects, pathMap, errors } = lazilyResolveObjectsWithAnnotationTree(
            annotationTree,
            (objectId: string) => {
                const object = cachedApiDocuments[objectId] ?? this.contentStoreAdapter.getLocalizedApiObjects({ locale, objectIds: [objectId], user })[0];
                if (object) {
                    cachedApiDocuments[objectId] = object;
                }
                return object;
            },
            { resolveAllReferences }
        );

        const documentMap = _.keyBy([...this.contentStoreAdapter.getDocuments({ user }), ...this.contentStoreAdapter.getAssets({ user })], 'srcObjectId');
        this.populateReferenceLabels(objects, documentMap, locale);

        if (!reportAllErrors) {
            const allErrors = [...errors, ...clientAnnotationErrors];
            const displayErrors = allErrors.slice(0, 5);
            _.forEach(displayErrors, (error) => {
                const errorProps = _.omit(error, ['type', 'message']);
                this.userLogger.error(
                    `${error.message} ${_.map(errorProps, (val, key) => `${key}:'${val && val.toString ? val.toString() : val}'`).join(', ')}`
                );
            });
            const diffErrors = allErrors.length - displayErrors.length;
            if (diffErrors > 0) {
                this.userLogger.error(
                    `${displayErrors.length} Annotation errors shown (out of ${allErrors.length}). Use \`stackbit dev\` locally to view all.`
                );
            }
        }

        // TODO: map over objects and return documents here as well
        return { objects, pathMap, errors };
    }

    async getCollections({ locale, user }: { locale?: string; user?: ContentStoreTypes.User }): Promise<Collections> {
        const referenceMap = this.contentStoreAdapter.getReferenceMap();
        const content: (ContentStoreTypes.Asset | ContentStoreTypes.Document)[] = [
            ...this.contentStoreAdapter.getDocuments({ locale, user }),
            ...this.contentStoreAdapter.getAssets({ locale, user })
        ];
        const mappedModels = this.contentStoreAdapter.getModelsByContentSourceType({ locale, user });
        const getId = (srcType: string, srcProjectId: string, modelName: string) => `${srcType}:${srcProjectId}:${modelName}`;
        const documentGroups = _.groupBy(content, (obj) => getId(obj.srcType, obj.srcProjectId, obj.srcModelName));
        const acceptedModels = getFlattenModels(mappedModels ?? {}).filter(({ model }) => {
            return model.type === 'page' || model.type === 'data' || model.type === 'image';
        });

        const styleObjectModelName = this.stackbitConfig?.styleObjectModelName;
        const objectsByModelName = _.groupBy(content, 'srcModelName');
        const styleObjectId = styleObjectModelName ? _.get(objectsByModelName, [styleObjectModelName, 0, 'srcObjectId'], null) : null;
        const collections = _.map(acceptedModels, ({ model, srcType, srcProjectId }) => {
            const documents = documentGroups[getId(srcType, srcProjectId, model.name)];
            return {
                srcType,
                srcProjectId,
                srcModelName: model.name,
                srcModelLabel: model.label,
                objects:
                    documents?.map(
                        (document) =>
                            omitByNil({
                                ..._.pick(document, ['srcObjectId', 'createdAt', 'updatedAt', 'updatedBy', 'srcObjectUrl', 'locale', 'status', 'permissions']),
                                srcObjectLabel: document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle,
                                referencedBy: referenceMap[document.srcType]?.[document.srcProjectId]?.[document.srcObjectId],
                                hidden: document.hidden
                            }) as Omit<CollectionItem, 'srcProjectId' | 'srcType'>
                    ) ?? []
            };
        }).filter(({ srcModelName }) => srcModelName !== styleObjectModelName);

        // Sort by collectionType (page, data, object) and then by collectionName.
        const sortOrder = ['page', 'data', 'object'];
        const sortedByModelName = _.sortBy(collections, 'srcModelName');
        const sortedCollections = _.sortBy(sortedByModelName, (collection) => {
            const collectionType = _.get(mappedModels, [collection.srcType, collection.srcProjectId, collection.srcModelName, 'type'])!;
            return sortOrder.indexOf(collectionType);
        });
        return {
            collections: sortedCollections,
            styleObjectId
        };
    }

    async createPreset(dir: string, fieldDataPath: string[], presetParams: PresetParams, dryRun: boolean, user?: ContentStoreTypes.User) {
        const documents = this.contentStoreAdapter.getDocuments({});
        const assets = this.contentStoreAdapter.getAssets({});
        const documentsById = _.keyBy(documents, 'srcObjectId');
        const assetsById = _.keyBy(assets, 'srcObjectId');
        const contentStoreLocales = this.contentStoreAdapter.getLocales();
        const preset = await createPreset({
            documentsById,
            assetsById,
            fieldDataPath,
            presetParams,
            contentStoreLocales,
            staticAssetsPublicPath: this.staticAssetsPublicPath,
            referenceBehavior: {
                behavior: this.stackbitConfig?.presetReferenceBehavior,
                duplicatableModels: this.stackbitConfig?.duplicatableModels,
                nonDuplicatableModels: this.stackbitConfig?.nonDuplicatableModels
            }
        });
        if (dryRun) {
            const presetFileName = generatePresetFileName(preset);
            return {
                files: [presetFileName],
                preset
            };
        }
        return this.contentStoreAdapter.createPreset({ dir, presetParams, preset, user });
    }

    async deletePreset(dir: string, presetId: string, user?: ContentStoreTypes.User) {
        return this.contentStoreAdapter.deletePreset({ dir, presetId, user });
    }

    async searchDocuments(data: {
        query?: string;
        models: Array<{
            srcProjectId: string;
            srcType: string;
            modelName: string;
        }>;
        locale?: string;
        filter: ContentStoreTypes.SearchFilter;
        user?: ContentStoreTypes.User;
    }): Promise<{
        total: number;
        items: CollectionItemWithModel[];
    }> {
        const referenceMap = this.contentStoreAdapter.getReferenceMap();
        const result = await this.contentStoreAdapter.searchDocuments(data);
        const items = result.items.map(
            (document) =>
                omitByNil({
                    ..._.pick(document, [
                        'srcObjectId',
                        'createdAt',
                        'updatedAt',
                        'srcProjectId',
                        'srcType',
                        'srcModelName',
                        'srcModelLabel',
                        'srcObjectUrl',
                        'status',
                        'locale'
                    ]),
                    srcObjectLabel: document.getPreview({ locale: data.locale }).previewTitle,
                    referencedBy: referenceMap[document.srcType]?.[document.srcProjectId]?.[document.srcObjectId]
                }) as CollectionItemWithModel
        );

        return {
            ...result,
            items
        };
    }

    async getDocumentVersions(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ versions: ContentStoreTypes.APIDocumentVersion[] }> {
        const { versions } = await this.contentStoreAdapter.getDocumentVersions(data);
        if (versions.length) {
            const documentMap = _.keyBy([...this.contentStoreAdapter.getDocuments({}), ...this.contentStoreAdapter.getAssets({})], 'srcObjectId');
            const objects = versions.map((version) => version.object).filter(isTruthy);
            this.populateReferenceLabels(objects, documentMap, data.locale);
        }
        return { versions };
    }

    async getDocumentForVersion(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        versionId: string;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ version: ContentStoreTypes.APIDocumentVersionWithDocument }> {
        const { version } = await this.contentStoreAdapter.getDocumentForVersion(data);
        if (version.object) {
            const documentMap = _.keyBy([...this.contentStoreAdapter.getDocuments({}), ...this.contentStoreAdapter.getAssets({})], 'srcObjectId');
            this.populateReferenceLabels([version.object], documentMap, data.locale);
        }
        return { version };
    }
}
