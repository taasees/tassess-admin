const _ = require('lodash');
const chalk = require('chalk');
const { forEachField } = require('../../utils/code-utils');
const { fieldPathToString, fieldPathToFieldDataPath, appendOrArray } = require('./annotation-utils');
const REGEX_ENDS_WITH_TEXT_PATH = /text\(\)(\[\d*\])?$/;
const ANNOTATION_XPATH_SELF = ['self::node()', '.'];
const ANNOTATION_ERROR = 'AnnotationError';

/**
 * Receive a list of objectIds, and the annotationTree, and resolves the annotations into a pathMap, and returns any additional referenced objects that were used in the annotations.
 * Also returns validation errors to the client.
 * @param annotationTree
 * @param {object} fieldData
 * @param resolveAllReferences
 * @returns {{pathMap: {}, objects, errors: *[]}}
 */
function resolveObjectsWithAnnotationTree(annotationTree = {}, fieldData, { resolveAllReferences = true } = {}) {
    return lazilyResolveObjectsWithAnnotationTree(annotationTree, (oid) => _.get(fieldData, oid), { resolveAllReferences });
}

/**
 * Receive a list of objectIds, and the annotationTree, and resolves the annotations into a pathMap, and returns any additional referenced objects that were used in the annotations.
 * Also returns validation errors to the client.
 * @param annotationTree
 * @param {object} getObjectById
 * @param resolveAllReferences
 * @returns {{pathMap: {}, objects, errors: *[]}}
 */
function lazilyResolveObjectsWithAnnotationTree(annotationTree = {}, getObjectById, { resolveAllReferences = true } = {}) {
    const { objectIds } = annotationTree;
    const rtObjects = _.reduce(
        objectIds,
        (objectsById, objectId) => {
            const obj = getObjectById(objectId);
            if (obj) {
                objectsById[objectId] = obj;
            }
            return objectsById;
        },
        {}
    );
    const { pathMap, pathMapForResolving, errors } = parseAnnotationTree(annotationTree, getObjectById);
    const objects = _.values(rtObjects);
    for (let i = 0; i < objects.length; i++) {
        forEachField(objects[i], (value, keyPath) => {
            const fieldType = _.get(value, 'type');
            if (fieldType === 'unresolved_reference' || fieldType === 'cross-reference') {
                const path = fieldPathToString(keyPath);
                // optional improvement, create an index of pathMapForResolving paths for quicker search.
                const shouldResolve = !!Object.keys(pathMapForResolving).some((key) => {
                    return key.startsWith(path);
                });
                if (shouldResolve || resolveAllReferences) {
                    if (!_.has(rtObjects, value.refId)) {
                        const refObj = getObjectById(value.refId);
                        if (refObj) {
                            rtObjects[value.refId] = refObj;
                            objects.push(refObj);
                        }
                    }
                }
            }
            return value;
        });
    }

    return {
        objects: _.values(rtObjects),
        pathMap,
        errors
    };
}

/**
 * Recursion that goes over annotationTree, and parses out annotations using the fieldData to resolve and infer objectIds and partial fieldPaths (.field).
 * Steps:
 * 1. parse 'data-sb-object-id' annotations and store context in parentOid to append to child annotations if they don't specify objectId explicitly
 * 2. parse 'data-sb-field-path' annotations (using resolveFp to resolve partials (.field), and parent objectIds), and create a pathMap that maps fieldPaths to xPaths.
 * 2.1. determine if any of the annotations is a container annotation and store it in context to pass to descendants.
 * 3. go over child nodes and run the recursion, merging any returned validation errors, and xpath matches.
 *
 * Return any resolved annotations as a pathMap,
 * also returns pathMapForResolving, which includes partial fieldPaths for resolving references from any ancestor objectId.
 * @param annotationTree
 * @param getObjectById
 * @param parentOid
 * @param parentFp
 * @returns {{pathMap: {}, pathMapForResolving: {}, errors: *[]}}
 */
function parseAnnotationTree(annotationTree, getObjectById, { parentOid, parentFp } = {}) {
    const errors = [];
    const pathMap = {};
    const pathMapForResolving = {};
    if (annotationTree.oid) {
        const obj = getObjectById(annotationTree.oid);
        if (obj) {
            appendOrArray(pathMap, [fieldPathToString([annotationTree.oid])], {
                xpath: annotationTree.xpath.join('/'),
                type: 'element'
            });
            parentOid = annotationTree.oid;
            parentFp = { oid: annotationTree.oid, fp: '' };
        } else {
            errors.push({
                message: `AnnotationError: Object ${chalk.bold(chalk.cyan(annotationTree.oid))} defined in sb-object-id not found`,
                attrValue: annotationTree.oid,
                elementXPath: annotationTree.xpath.join('/'),
                type: ANNOTATION_ERROR
            });
        }
    }

    let childParentFp;
    _.each(annotationTree.fp, (annotationFp) => {
        const { resolvedOid, resolvedFp, error } = resolveFp(annotationFp, annotationTree, { parentOid, parentFp });
        if (error) {
            errors.push(error);
            return;
        }
        const { fieldDataPath, fieldDataPathStr, fieldDataPathsFromRoot } = fieldPathToFieldDataPath(resolvedOid, resolvedFp, getObjectById);
        let field = null;
        if (fieldDataPath) {
            const fieldObj = getObjectById(fieldDataPath[0]);
            field = fieldObj;
            if (fieldDataPath.length > 1) {
                field = _.get(fieldObj, fieldDataPath.slice(1));
            }
        }
        if (!field) {
            const fieldPath = fieldDataPathStr ? fieldDataPathStr : resolvedFp;
            errors.push({
                message: `AnnotationError: Field path ${chalk.bold(chalk.cyan(fieldPath))} not found or does not match content schema`,
                fieldPath,
                value: JSON.stringify(annotationFp),
                elementXPath: annotationTree.xpath.join('/'),
                type: ANNOTATION_ERROR
            });
            return;
        }
        const location = resolveLocation(annotationFp, field);
        const resolvedMatchType = resolveMatchType(location);
        if (isContainerField(field, annotationFp)) {
            if (childParentFp) {
                errors.push({
                    message: 'AnnotationError: Multiple container objects are not allowed in a single element',
                    fieldPath: fieldDataPathStr,
                    value: JSON.stringify(annotationFp),
                    elementXPath: annotationTree.xpath.join('/'),
                    type: ANNOTATION_ERROR
                });
                return;
            }
            childParentFp = { oid: resolvedOid, fp: resolvedFp };
        }

        appendOrArray(pathMap, [fieldDataPathStr], {
            xpath: annotationFp.loc ? annotationTree.xpath.concat(annotationFp.loc).join('/') : annotationTree.xpath.join('/'),
            type: resolvedMatchType
        });

        // fieldDataPathsFromRoot is an array that contains paths to the current object from any possible ancestor with an id in the original annotation chain.
        for (let i = 0; i < fieldDataPathsFromRoot.length; i++) {
            const partialFieldDataPath = fieldDataPathsFromRoot[i];
            if (!pathMapForResolving[partialFieldDataPath]) {
                pathMapForResolving[partialFieldDataPath] = pathMap[fieldDataPathStr];
            } else {
                break;
            }
        }
    });

    _.each(annotationTree.children, (childTree) => {
        const {
            pathMap: childMap,
            pathMapForResolving: childPathMapForResolving,
            errors: childErrors
        } = parseAnnotationTree(childTree, getObjectById, {
            parentOid: annotationTree.oid || parentOid,
            parentFp: childParentFp || parentFp
        });
        _.assignWith(pathMap, childMap, (pathMapVal, childMapVal) => {
            if (!_.isEmpty(pathMapVal) && !_.isEmpty(childMapVal)) {
                return pathMapVal.concat(childMapVal);
            }
        });
        _.assignWith(pathMapForResolving, childPathMapForResolving, (pathMapVal, childMapVal) => {
            if (!_.isEmpty(pathMapVal) && !_.isEmpty(childMapVal)) {
                return pathMapVal.concat(childMapVal);
            }
        });
        errors.push(...childErrors);
    });

    return { pathMap, pathMapForResolving, errors };
}

/**
 * receives the xpath location, and resolves the matchType for highlighting (text, element, attribute)
 * @param location
 * @returns {string}
 */
function resolveMatchType(location) {
    let matchType;
    const lastLocationPart = _.last(location);
    if (lastLocationPart && lastLocationPart.startsWith('@')) {
        matchType = 'attribute';
    } else {
        matchType = lastLocationPart && lastLocationPart.match(REGEX_ENDS_WITH_TEXT_PATH) ? 'text' : 'element';
    }
    return matchType;
}

/**
 * parses the xpath location partial of an annotation ('objectId:field.path#location') and resolves defaults and fallbacks to return the final xpath.
 * @param annotationFp
 * @param field
 * @returns {string[]}
 */
function resolveLocation(annotationFp, field) {
    let xpath = _.compact(annotationFp.loc.split('/'));
    const lastPart = _.last(xpath);
    const isExplicitLocation = lastPart && (lastPart.startsWith('@') || !!lastPart.match(REGEX_ENDS_WITH_TEXT_PATH));

    // append text node to xpath if it's a [string, text, number], if no explicit location or explicit self was set
    if (
        !isExplicitLocation &&
        !ANNOTATION_XPATH_SELF.includes(lastPart) &&
        ['string', 'text', 'number'].includes(field.type) &&
        annotationFp.hasOnlyTextNodes
    ) {
        xpath.push('text()');
    }

    // If xpath ends with self (. or self::node()), remove that part as it's redundant for studio
    if (ANNOTATION_XPATH_SELF.includes(lastPart)) {
        xpath = xpath.slice(0, -1);
    }
    return xpath;
}

/**
 * Receives an annotation, the annotationTree, and the annotation context, and returns the inferred fieldPath and objectId.
 * This function combines partial fieldpaths (.field) and looks for a parent objectId, and computes the full resolved annotation path.
 * @param annotationFp
 * @param annotationTree
 * @param parentOid
 * @param parentFp
 * @returns {{resolvedFp, resolvedOid: *}|{resolvedFp: *, resolvedOid}|{error: {elementXPath, fieldPath, message: string, type: string, value}}}
 */
function resolveFp(annotationFp, annotationTree, { parentOid, parentFp }) {
    if (annotationFp.fp.startsWith('.')) {
        if (!parentFp) {
            return {
                error: {
                    message: 'AnnotationError: Field path starts with accessor (.) but parent field path not found',
                    fieldPath: annotationFp.fp,
                    value: annotationFp,
                    elementXPath: annotationTree.xpath.join('/'),
                    type: ANNOTATION_ERROR
                }
            };
        }

        // parentFp.fp might be an empty string if the closest parentFp is an oid annotation
        const resolvedFp = parentFp.fp ? parentFp.fp + annotationFp.fp : annotationFp.fp.replace(/^\./, '');
        return { resolvedOid: parentFp.oid, resolvedFp };
    }

    if (!annotationFp.oid && !parentOid) {
        return {
            error: {
                message: 'AnnotationError: Annotation is missing an object ID, and a parent object ID was not found',
                fieldPath: annotationFp.fp,
                value: annotationFp,
                elementXPath: annotationTree.xpath.join('/'),
                type: ANNOTATION_ERROR
            }
        };
    }

    return { resolvedOid: annotationFp.oid || parentOid, resolvedFp: annotationFp.fp };
}

/**
 * Returns a boolean flag if an annotation needs to open a container context for descendant annotations.
 * Meaning descendants can use partial fieldpaths (.field) that will be appended to this annotation.
 * @param field
 * @param annotationFp
 * @returns {boolean}
 */
function isContainerField(field, annotationFp) {
    const xpath = _.compact(annotationFp.loc.split('/'));
    const lastLocationPart = _.last(xpath);
    const isExplicitLocation = lastLocationPart && (lastLocationPart.startsWith('@') || !!lastLocationPart.match(REGEX_ENDS_WITH_TEXT_PATH));
    return ['object', 'list'].includes(field.type) && !isExplicitLocation;
}

module.exports = {
    resolveObjectsWithAnnotationTree,
    lazilyResolveObjectsWithAnnotationTree
};
