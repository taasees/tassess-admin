import _ from 'lodash';
import path from 'path';
import { ensureDir, pathExists, unlink, writeJSON } from 'fs-extra';
import { v4 as uuidv4 } from 'uuid';
import { parseFile, outputData } from '@stackbit/cms-core/dist/utils';
import { ContentStoreTypes, getDocumentFieldAtFieldPath, getDocumentFieldForLocale, IMAGE_MODEL } from '@stackbit/cms-core';
import { sanitizeSlug } from '../utils/cms-utils';
import { GitBasedAssetsManager } from '../cms/git/git-based-assets-manager';
import { Preset } from '@stackbit/sdk';

export interface PresetParams {
    label: string;
    metadata: any;
    thumbnail: any;
    locale?: string;
}

export interface ReferenceBehavior {
    behavior?: 'copyReference' | 'duplicateContents';
    nonDuplicatableModels?: string[];
    duplicatableModels?: string[];
}

function convertDocumentFieldsToPresetData({
    assetsById,
    documentsById,
    object,
    locale,
    defaultLocale,
    referenceBehavior,
    staticAssetsPublicPath
}: {
    assetsById: Record<string, ContentStoreTypes.Asset>;
    documentsById: Record<string, ContentStoreTypes.Document>;
    object: ContentStoreTypes.Document | (ContentStoreTypes.DocumentModelFieldNonLocalized & { isUnset?: false });
    locale?: string;
    defaultLocale?: string;
    referenceBehavior?: ReferenceBehavior;
    staticAssetsPublicPath?: string;
}): any {
    function _deepMapDocumentField(documentField: ContentStoreTypes.DocumentField, seenReferences: string[]): any {
        const docField = getDocumentFieldForLocale(documentField, locale ?? defaultLocale);
        if (!docField) {
            return null;
        }
        if ('isUnset' in docField && docField.isUnset) {
            return null;
        }
        if (docField.type === 'object') {
            return _.mapValues(docField.fields, (field) => {
                return _deepMapDocumentField(field, seenReferences);
            });
        } else if (docField.type === 'model') {
            return {
                $$type: docField.srcModelName,
                ..._.mapValues(docField.fields, (field) => {
                    return _deepMapDocumentField(field, seenReferences);
                })
            };
        } else if (docField.type === 'list') {
            return _.map(docField.items, (item) => {
                return _deepMapDocumentField(item, seenReferences);
            });
        } else if (docField.type === 'image') {
            if (docField.sourceData) {
                return docField.sourceData;
            }
            const url = getDocumentFieldForLocale(docField.fields?.url, locale ?? defaultLocale)?.value;
            if (staticAssetsPublicPath && url?.startsWith(staticAssetsPublicPath)) {
                return url.substr(staticAssetsPublicPath.length);
            }
            return url ?? null;
        } else if (docField.type === 'reference') {
            if (docField.refType === 'asset') {
                const referencedAsset = assetsById[docField.refId];
                if (!referencedAsset) {
                    return null;
                }
                return {
                    $$ref: docField.refId,
                    $$type: referencedAsset.srcModelName
                };
            }
            const referencedDocument = documentsById[docField.refId];
            if (!referencedDocument) {
                return null;
            }
            const modelName = referencedDocument.srcModelName;
            const shouldDuplicate = shouldDuplicateReference(docField, modelName, referenceBehavior, seenReferences);
            if (shouldDuplicate) {
                seenReferences.push(docField.refId);
                return {
                    $$type: referencedDocument.srcModelName,
                    $$refSrcType: referencedDocument.srcType,
                    $$refProjectId: referencedDocument.srcProjectId,
                    ..._.mapValues(referencedDocument.fields, (field) => {
                        return _deepMapDocumentField(field, seenReferences);
                    })
                };
            }
            return {
                $$ref: docField.refId,
                $$type: modelName
            };
        } else if (docField.type === 'cross-reference') {
            if (docField.refType === 'asset') {
                const referencedAsset = assetsById[docField.refId];
                if (!referencedAsset) {
                    return null;
                }
                return {
                    $$ref: docField.refId,
                    $$refSrcType: referencedAsset.srcType,
                    $$refProjectId: referencedAsset.srcProjectId,
                    $$type: referencedAsset.srcModelName
                };
            }
            const referencedDocument = documentsById[docField.refId];
            if (!referencedDocument) {
                return null;
            }
            const modelName = referencedDocument.srcModelName;
            const shouldDuplicate = shouldDuplicateReference(docField, modelName, referenceBehavior, seenReferences);
            if (shouldDuplicate) {
                seenReferences.push(docField.refId);
                return {
                    $$type: referencedDocument.srcModelName,
                    $$refSrcType: referencedDocument.srcType,
                    $$refProjectId: referencedDocument.srcProjectId,
                    ..._.mapValues(referencedDocument.fields, (field) => {
                        return _deepMapDocumentField(field, seenReferences);
                    })
                };
            }
            return {
                $$ref: docField.refId,
                $$type: modelName,
                $$refSrcType: referencedDocument.srcType,
                $$refProjectId: referencedDocument.srcProjectId
            };
        }
        // for all other fields, return its value as is
        return docField.value ?? null;
    }

    return _.mapValues(object.fields, (field) => {
        return _deepMapDocumentField(field, object.type === 'document' ? [object.srcObjectId] : []);
    });
}

function shouldDuplicateReference(
    referenceField: (ContentStoreTypes.DocumentReferenceFieldNonLocalized | ContentStoreTypes.DocumentCrossReferenceFieldNonLocalized) & { isUnset?: false },
    modelName: string,
    referenceBehavior?: ReferenceBehavior,
    seenReferences?: string[]
): boolean {
    return (
        seenReferences?.includes(referenceField.refId) !== true &&
        modelName !== IMAGE_MODEL.name &&
        ((referenceBehavior?.behavior === 'duplicateContents' && !(referenceBehavior?.nonDuplicatableModels ?? []).includes(modelName)) ||
            (referenceBehavior?.behavior !== 'duplicateContents' && (referenceBehavior?.duplicatableModels ?? []).includes(modelName)))
    );
}

async function handleThumbnail(dir: string, presetFileName: string, thumbnail: any, logger?: any) {
    const assetsManager = new GitBasedAssetsManager({
        rootDir: dir,
        appDir: dir,
        staticAssetsFilePath: '',
        staticAssetsPublicPath: ''
    });
    assetsManager.assetsDir = '';
    assetsManager.staticDir = '';
    try {
        const filePath = path.join(dir, '.stackbit/presets/images', path.parse(presetFileName).name + path.extname(_.get(thumbnail, 'metadata.name')));
        await assetsManager.uploadFileTo(thumbnail.url, filePath, thumbnail.data);
        return filePath;
    } catch (err) {
        logger?.error('Error getting thumbnail', { err });
    }
    return null;
}

export async function createPreset({
    documentsById,
    assetsById,
    fieldDataPath,
    presetParams,
    contentStoreLocales,
    referenceBehavior,
    staticAssetsPublicPath
}: {
    documentsById: Record<string, ContentStoreTypes.Document>;
    assetsById: Record<string, ContentStoreTypes.Asset>;
    fieldDataPath: string[];
    presetParams: PresetParams;
    contentStoreLocales?: ContentStoreTypes.ContentStoreLocale[];
    referenceBehavior?: ReferenceBehavior;
    staticAssetsPublicPath?: string;
}): Promise<Preset> {
    const documentId = fieldDataPath[0];
    if (!documentId) {
        throw new Error('fieldDataPath is empty');
    }
    const document = documentsById[documentId];
    if (!document) {
        throw new Error(`'document with id '${documentId}' not found'`);
    }
    const defaultLocale = contentStoreLocales?.find(
        (contentStoreLocale) => contentStoreLocale.srcType === document.srcType && contentStoreLocale.srcProjectId === document.srcProjectId
    )?.defaultLocale;
    let modelName = document.srcModelName;
    let presetData: any;
    if (fieldDataPath.length === 1) {
        presetData = convertDocumentFieldsToPresetData({
            documentsById,
            assetsById,
            object: document,
            locale: presetParams.locale,
            defaultLocale,
            referenceBehavior,
            staticAssetsPublicPath
        });
    } else {
        const documentField = getDocumentFieldAtFieldPath({
            document: document,
            fieldPath: fieldDataPath.slice(1),
            locale: presetParams.locale,
            isFullFieldPath: true
        });
        // in tests, old git-cms returns model fields with type === object
        // if (documentField.type !== 'model') {
        if (!('srcModelName' in documentField)) {
            throw new Error('object for preset must be a document or a field of type model');
        }
        if (documentField.isUnset) {
            throw new Error(`object has no value for locale '${presetParams.locale}'`);
        }
        modelName = documentField.srcModelName;
        presetData = convertDocumentFieldsToPresetData({
            documentsById,
            assetsById,
            object: documentField,
            locale: presetParams.locale,
            defaultLocale,
            referenceBehavior,
            staticAssetsPublicPath
        });
    }
    return {
        ..._.omit(presetParams, 'thumbnail'),
        modelName,
        srcType: document.srcType,
        srcProjectId: document.srcProjectId,
        data: presetData
    };
}

export async function savePreset(dir: string, presetParams: PresetParams, preset: Preset, logger?: any) {
    const presetsDir = path.join(dir, '.stackbit/presets');
    const presetsImagesDir = path.join(presetsDir, 'images');
    await ensureDir(presetsImagesDir);

    const presetFileName = generatePresetFileName(preset);
    const presetFilePath = path.join(presetsDir, presetFileName);
    const files = [presetFilePath];
    let thumbnailFilePath;

    if (presetParams.thumbnail) {
        const thumbnailFileName = await handleThumbnail(dir, presetFileName, presetParams.thumbnail, logger);
        if (thumbnailFileName) {
            thumbnailFilePath = path.relative(presetsDir, thumbnailFileName);
            files.push(thumbnailFileName);
        }
    }

    const fullPreset = {
        ...preset,
        thumbnail: thumbnailFilePath
    };
    const { modelName, srcType, srcProjectId, ...innerPreset } = fullPreset;

    const presetFileData = {
        model: modelName,
        srcType,
        srcProjectId,
        presets: [innerPreset]
    };
    await writeJSON(presetFilePath, presetFileData, {
        spaces: 4
    });

    return {
        files: files.map((fileName) => path.relative(dir, fileName)),
        preset: fullPreset
    };
}

export async function createAndSavePreset(
    dir: string,
    documentsById: Record<string, ContentStoreTypes.Document>,
    assetsById: Record<string, ContentStoreTypes.Asset>,
    fieldDataPath: string[],
    presetParams: PresetParams,
    referenceBehavior?: ReferenceBehavior,
    contentStoreLocales?: ContentStoreTypes.ContentStoreLocale[],
    logger?: any
) {
    const preset = await createPreset({
        documentsById,
        assetsById,
        fieldDataPath,
        presetParams,
        contentStoreLocales,
        referenceBehavior
    });
    return savePreset(dir, presetParams, preset, logger);
}

export function generatePresetFileName(preset: Preset) {
    return `${sanitizeSlug(_.startCase(preset.modelName))}-${sanitizeSlug(preset.label)}-${uuidv4().slice(0, 4)}.json`;
}

export async function deletePreset(dir: string, presetId: string, logger?: any): Promise<string[]> {
    const [fileName, presetPath] = presetId.split(':');
    if (!fileName || !presetPath) {
        return [];
    }
    const filePath = path.join(dir, fileName);
    if (!(await pathExists(filePath))) {
        return [];
    }
    const data = await parseFile(filePath);
    const presetData = _.get(data, presetPath);
    if (!presetData) {
        return [];
    }

    const result = [fileName];

    if (data.presets?.length === 1) {
        await unlink(filePath);
    } else {
        data.presets = data.presets.filter((preset: any) => preset !== presetData);
        await outputData(filePath, data);
    }

    if (presetData.thumbnail) {
        const thumbnailFilePath = path.join('.stackbit/presets', presetData.thumbnail);
        await unlink(path.join(dir, thumbnailFilePath));
        result.push(thumbnailFilePath);
    }

    return result;
}
