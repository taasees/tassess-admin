import { Request, Response } from 'express';
import url from 'url';
import zlib from 'zlib';
import util from 'util';
import _ from 'lodash';

const gzip = util.promisify(zlib.gzip);
const gunzip = util.promisify(zlib.gunzip);

export function isGzip(req: Request) {
    return _.get(req, ['headers', 'content-encoding'], '').includes('gzip');
}

export function isHtml(req: Request) {
    return _.get(req, ['headers', 'content-type'], '').includes('text/html');
}

export function isJs(req: Request) {
    return _.get(req, ['headers', 'content-type'], '').includes('application/javascript');
}

export function createProxyModifyResponseMiddleware(options: any) {
    return (proxyRes: Request, req: Request, res: Response) => {
        proxyModifyResponseHandler(proxyRes, req, res, options);
    };
}

export function proxyModifyResponseHandler(proxyRes: Request, req: Request, res: Response, options: any = {}) {
    const logTagName = _.get(options, 'logTagName', 'onProxyRes');

    if (options.logger) {
        proxyRes.on('error', (error: any) => {
            options.logger.error(`[${logTagName}] error proxying response`, { error: error, url: req.url, method: req.method });
        });
    }
    setRedirectHostRewrite(proxyRes, req);

    const passThrough = _.isFunction(options.shouldModifyBody) && !options.shouldModifyBody(proxyRes, req, res);
    if (passThrough) {
        const headers = proxyRes.headers;
        delete headers['x-frame-options'];
        delete headers['content-security-policy'];
        setHeaders(res, headers);
        if (proxyRes.statusCode) {
            res.status(proxyRes.statusCode);
        }
        proxyRes.on('data', (data: any) => res.write(data));
        proxyRes.on('end', () => res.end());
        return;
    }

    const _isGzip = isGzip(proxyRes);
    const chunks: any = [];

    proxyRes.on('data', (data: any) => {
        chunks.push(data);
    });

    proxyRes.on('end', async () => {
        let body: any = Buffer.concat(chunks);

        if (_isGzip) {
            try {
                body = await gunzip(body);
            } catch (error) {
                options.logger?.error(`[${logTagName}] error while unzipping response`, { error: error, url: req.url, method: req.method });
                setHeaders(res, proxyRes.headers);
                if (proxyRes.statusCode) {
                    res.status(proxyRes.statusCode);
                }
                res.end(body);
                return;
            }
        }

        body = body.toString('utf8');

        if (_.isFunction(options.modifyBody)) {
            body = options.modifyBody(body, proxyRes, req, res);
        }

        if (_isGzip) {
            body = await gzip(body);
        }

        // don't copy content-length because we are changing it when updating html
        setHeaders(res, _.omit(proxyRes.headers, ['content-length']));
        if (proxyRes.statusCode) {
            res.status(proxyRes.statusCode);
        }
        res.end(body);
    });
}

// When `followRedirects` is set to `false`, we need to make sure that browser receives correct redirected host.
// Because when modifying response we are setting `selfHandleResponse` to `true`, we are preventing http-proxy from
// rewriting redirect host (even when using `autoRewrite` is set to `true`).
// Therefore, manually rewrite the redirect host location as it is done in http-proxy module:
// https://github.com/http-party/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L50
const redirectRegex = /^201|30(1|2|7|8)$/;
function setRedirectHostRewrite(proxyRes: Request, req: Request) {
    if (!proxyRes.headers['location'] || !proxyRes.statusCode || !redirectRegex.test(proxyRes.statusCode!.toString())) {
        return;
    }

    const u: any = url.parse(proxyRes.headers['location']);
    // rewrite host header if redirect location contains one
    if (u.host) {
        u.host = req.headers['host'];
    }
    proxyRes.headers['location'] = u.format();
}

export function injectScript(html: string, url?: string, code?: string) {
    const injectedHtml = url ? `<script type="text/javascript" src="${url}"></script>` : `<script type="text/javascript">${code}</script>`;
    if (html) {
        if (html.includes('</head>')) {
            return html.replace('</head>', `${injectedHtml}</head>`);
        } else if (html.includes('<title>')) {
            return html.replace('<title>', `${injectedHtml}<title>`);
        } else if (html.includes('</body>')) {
            return html.replace('</body>', `${injectedHtml}</body>`);
        } else {
            return html + injectedHtml;
        }
    }
    return html;
}

function setHeaders(res: Response, headers: Record<string, any>) {
    res.set(headers);
    const contentType = headers['content-type'];
    if (contentType && !contentType.includes('charset')) {
        // if original response header doesn't include charset - don't include it here as well
        // for instance, it fixes proxy nextjs 14 which checks for content-type strictly and because express applies charset
        // here, next does hard reload instead of soft
        res.writeHead(200, { 'content-type': contentType });
    }
}
