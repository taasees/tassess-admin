import _ from 'lodash';
import fse from 'fs-extra';
import chalk from 'chalk';
import path from 'path';
import axios from 'axios';
import semver from 'semver';
import { ContentSourceInterface, Logger, Version, getInterfaceVersion } from '@stackbit/types';

const containerPackages = ['@stackbit/dev-common', '@stackbit/cms-core'];

export async function getVersionsForStackbitPackages(logger?: Logger): Promise<Record<string, string[]>> {
    try {
        // we don't want to wait longer than 2 secs. for the versions to load
        const result = await axios.get('https://versions.stackbit.com/all.json', { timeout: 2000 });
        return result.data;
    } catch (err) {
        logger?.warn('Failed to load versions for Stackbit packages', { err });
        return {};
    }
}

export async function getNewerVersionsForStackbitPackages(packageVersions: Record<string, string>, logger?: Logger): Promise<Record<string, string[]>> {
    const result: Record<string, string[]> = {};
    const allVersions: Record<string, string[]> = await exports.getVersionsForStackbitPackages(logger);
    for (const [packageName, currentVersion] of Object.entries(packageVersions)) {
        let versions = allVersions[packageName];
        if (!versions) {
            continue;
        }
        const prereleaseVersion = semver.prerelease(currentVersion);
        if (prereleaseVersion) {
            // only consider prerelease version in the same prerelease tag
            versions = versions.filter((version) => !semver.prerelease(version) || semver.prerelease(version)![0] === prereleaseVersion[0]);
        } else {
            // only consider stable versions if current version isn't prerelease
            versions = versions.filter((version) => !semver.prerelease(version));
        }
        const newerVersions = _.uniq(
            [
                semver.maxSatisfying(versions, `^${currentVersion}`, { includePrerelease: !!prereleaseVersion }), // next compatible version
                semver.maxSatisfying(versions, `>${currentVersion}`, { includePrerelease: !!prereleaseVersion }), // largest available version
                semver.maxSatisfying(versions, `>${currentVersion}`) // largest available version
            ]
                .filter(Boolean)
                .filter((version) => version !== currentVersion)
        ) as string[];
        if (newerVersions.length) {
            result[packageName] = newerVersions;
        }
    }
    return result;
}

export async function getLocalStackbitPackageVersions(dir: string): Promise<Record<string, string>> {
    const nodeModulesDir = path.join(dir, 'node_modules');
    if (!(await fse.pathExists(nodeModulesDir))) {
        return {};
    }
    const packageJsonPath = path.join(dir, 'package.json');
    if (!(await fse.pathExists(packageJsonPath))) {
        return {};
    }
    const packageJson = await fse.readJson(packageJsonPath);
    const packageNames = _.uniq(Object.keys({ ...packageJson.dependencies, ...packageJson.devDependencies })).filter((packageName) =>
        packageName.startsWith('@stackbit')
    );

    const result: Record<string, string> = {};
    for (const packageName of packageNames) {
        const packageJsonPath = path.join(nodeModulesDir, packageName, 'package.json');
        if (!(await fse.pathExists(packageJsonPath))) {
            continue;
        }
        const packageJson = await fse.readJson(packageJsonPath);
        if (packageJson.name && packageJson.version) {
            result[packageJson.name] = packageJson.version;
        }
    }
    return result;
}

export async function checkAndLogNewerVersions({ dir, knownVersions, logger }: { dir: string; knownVersions: Record<string, string>; logger: Logger }) {
    const localVersions: Record<string, string> = await exports.getLocalStackbitPackageVersions(dir);
    const currentVersions = { ...knownVersions, ...localVersions };
    const newerVersions: Record<string, string[]> = await exports.getNewerVersionsForStackbitPackages(currentVersions, logger);
    const packagesWithNewerVersions = Object.keys(_.omit(newerVersions, containerPackages));
    if (packagesWithNewerVersions.length) {
        logger.info('ℹ️  Newer version(s) available for:');
    }
    for (let i = 0; i < packagesWithNewerVersions.length; i++) {
        const packageName = packagesWithNewerVersions[i]!;
        const versions = newerVersions[packageName];
        if (versions && versions.length > 0) {
            const connector = i === packagesWithNewerVersions.length - 1 ? '└──' : '├──';
            logger.info(`${connector} ${chalk.cyan(packageName)}: ${chalk.yellow(currentVersions[packageName])} → ${chalk.green(versions.join(', '))}`);
        }
    }
    const containerPackagesWithNewVersions = _.intersection(Object.keys(newerVersions), Object.keys(knownVersions), containerPackages);
    if (!_.isEmpty(containerPackagesWithNewVersions)) {
        // only display this message when running on container
        logger.info(
            `ℹ️  There is a new container version available${
                containerPackagesWithNewVersions.includes('stackbit/container') ? `: ${newerVersions['stackbit/container']}` : ''
            }.`
        );
    }
}

export async function checkAndLogContentSourceVersions({
    contentSources,
    isLocalDev,
    logger
}: {
    contentSources: ContentSourceInterface[];
    isLocalDev?: boolean;
    logger: Logger;
}): Promise<void> {
    const runningInterfaceVersion = await getInterfaceVersion();

    // log content sources and their versions
    const messageParts = [];
    let contentSourceMaxInterfaceVersion: string | null = null;
    for (const contentSource of contentSources) {
        const versions: Version = await (_.invoke(contentSource, 'getVersion') || Promise.resolve());
        let part = `${contentSource.getContentSourceType()} (project: ${contentSource.getProjectId()}`;
        if (versions && versions.contentSourceVersion) {
            part += `, version: ${versions.contentSourceVersion}`;
        }
        part += ')';
        messageParts.push(part);

        if (
            versions &&
            versions.interfaceVersion &&
            (!contentSourceMaxInterfaceVersion || semver.gt(versions.interfaceVersion, contentSourceMaxInterfaceVersion))
        ) {
            contentSourceMaxInterfaceVersion = versions.interfaceVersion;
        }
    }
    if (messageParts.length) {
        logger.info(`Content sources found: ${messageParts.join(', ')}`);
    }

    // check if content source interface versions are compatible with the running interface version
    if (
        contentSourceMaxInterfaceVersion &&
        semver.gt(contentSourceMaxInterfaceVersion, runningInterfaceVersion) &&
        ['major', 'premajor', 'minor', 'preminor'].includes(semver.diff(runningInterfaceVersion, contentSourceMaxInterfaceVersion) ?? '')
    ) {
        const containingRuntime = isLocalDev ? 'Stackbit CLI' : 'Stackbit Container';
        logger.error(
            `Your local package versions are incompatible with this version of the ${containingRuntime}. Upgrade your ${containingRuntime} version or downgrade your local packages.`
        );
        logger.error(
            `${containingRuntime} is running interface v${runningInterfaceVersion}, but content sources are using v${contentSourceMaxInterfaceVersion}.`
        );
    }
}
