import path from 'path';
import _ from 'lodash';
import fse from 'fs-extra';
import { Preset, PresetMap, Model, Field, FieldEnumOptionThumbnails, mapModelFieldsRecursively } from '@stackbit/sdk';
import * as StackbitTypes from '@stackbit/types';

export async function handleSchemaAssets<T extends Model>({
    models,
    presets,
    rootDir,
    stackbitYamlDir,
    logger,
    userLogger,
    staticThemeAssetsPublicPath,
    staticThemeAssetsFilePath
}: {
    models?: T[];
    presets?: PresetMap;
    rootDir: string;
    stackbitYamlDir: string;
    logger: StackbitTypes.Logger;
    userLogger: StackbitTypes.Logger;
    staticThemeAssetsPublicPath: string;
    staticThemeAssetsFilePath: string;
}): Promise<{ models: T[]; presets: PresetMap }> {
    let imagePathsToCopy: string[] = [];

    const joinThumbnailIfNeeded = <T extends { thumbnail?: string }>(obj: T): T => {
        if (obj.thumbnail && !isRemoteUrl(obj.thumbnail)) {
            imagePathsToCopy.push(obj.thumbnail);
            return {
                ...obj,
                thumbnail: path.join(staticThemeAssetsPublicPath, obj.thumbnail)
            };
        }
        return obj;
    };

    const mappedPresets = _.mapValues(presets, (preset: Preset) => {
        return joinThumbnailIfNeeded(preset);
    });

    const mappedModels = _.map(models, (model: T) => {
        model = joinThumbnailIfNeeded(model);
        model = mapModelFieldsRecursively(model, (field: Field) => {
            // copy custom controlTypes files and set controlUrl to static URL
            if ('controlType' in field && (field.controlType === 'custom-modal-html' || field.controlType === 'custom-inline-html') && field.controlFilePath) {
                if (typeof field.controlFilePath === 'string' && !isRemoteUrl(field.controlFilePath)) {
                    imagePathsToCopy.push(field.controlFilePath);
                    field = {
                        ...field,
                        controlUrl: path.join(staticThemeAssetsPublicPath, field.controlFilePath)
                    };
                }
            }

            // copy images of 'thumbnails' controlType and rewrite their path to static URL
            if (field.type === 'object') {
                field = joinThumbnailIfNeeded(field);
            } else if (field.type === 'enum' && field.controlType === 'thumbnails') {
                field = {
                    ...field,
                    options: _.map(field.options, (option: FieldEnumOptionThumbnails) => {
                        return joinThumbnailIfNeeded(option);
                    })
                };
            }
            return field;
        });
        return model;
    });

    imagePathsToCopy = _.uniq(imagePathsToCopy);
    if (!_.isEmpty(imagePathsToCopy)) {
        logger.debug(`Copying ${imagePathsToCopy.length} theme assets`);
        try {
            await Promise.all(
                imagePathsToCopy.map(async (imagePathToCopy) => {
                    const imagePath = path.join(stackbitYamlDir, imagePathToCopy);
                    const imageExists = await fse.pathExists(imagePath);
                    if (!imageExists) {
                        userLogger.warn('Missing file: ' + imagePathToCopy);
                        logger.debug('Missing file', {
                            imagePathToCopy,
                            imagePath,
                            imageExists
                        });
                        return;
                    }
                    const destPath = path.join(rootDir, staticThemeAssetsFilePath, imagePathToCopy);
                    await fse.ensureDir(path.dirname(destPath));
                    await fse.copyFile(imagePath, destPath);
                })
            );
        } catch (err) {
            logger.error('Error copying assets', { err, imagePathsToCopy });
        }
    }

    return {
        models: mappedModels,
        presets: mappedPresets
    };
}

function isRemoteUrl(url: string) {
    return url.match(/^https?:\/\//i);
}
