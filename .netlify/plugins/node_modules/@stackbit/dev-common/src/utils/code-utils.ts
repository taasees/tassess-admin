import fse from 'fs-extra';
import path from 'path';
import moment from 'moment';
import slugify from 'slugify';
import _ from 'lodash';
import crypto from 'crypto';
import { Stats } from 'fs';
import { utils as cmsCoreUtils } from '@stackbit/cms-core';
import { KeyPath } from '@stackbit/utils';
import { Logger } from '@stackbit/types';
import { PageModel } from '../types';

const momentFormatRe = /moment_format\(\s*(?:(?<param>.+?)\s*,\s*)?['"](?<format>[^'"]+)['"]\s*\)/;
const momentFormatEscapedRe = /moment_format\\\(\s*(?:(?<param>.+?)\s*,\s*)?['"](?<format>[^'"]+)['"]\s*\\\)/;
const momentDateToken = 'moment_date';

export { deepMap, KeyPath } from '@stackbit/utils';

export function forEachField(object: any, iteratee: (value: any, keyPath: KeyPath | null) => void, options?: { context?: any; includeKeyPath?: boolean }) {
    const context = _.get(options, 'context');
    const includeKeyPath = _.get(options, 'includeKeyPath', true);
    function _walkDeep(value: any, keyPath: KeyPath | null) {
        iteratee.call(context, value, keyPath);
        if (value.type === 'object') {
            _.forEach(value.fields, (val: any, key: string) => {
                return _walkDeep(val, includeKeyPath ? _.concat(keyPath!, ['fields', key]) : null);
            });
        } else if (value.type === 'list') {
            _.forEach(value.items, (val: any, key: number) => {
                return _walkDeep(val, includeKeyPath ? _.concat(keyPath!, ['items', key]) : null);
            });
        }
    }

    return _walkDeep(object, [object.srcObjectId]);
}

export function findIndexes(array: any[], cb: (item: any) => boolean, findFirst: boolean): number[] {
    const indexes: number[] = [];
    _.forEach(array, (el: any, ix: number) => {
        if (cb(el)) {
            indexes.push(ix);
            if (findFirst) {
                return false;
            }
        }
    });
    return indexes;
}

export function findParentArray(
    obj: any[],
    keyPath: KeyPath,
    targetKeyPath: KeyPath = []
): { arr: any[]; targetKeyPath: KeyPath; keyPath: KeyPath } | undefined {
    if (keyPath.length === 0) {
        return;
    }
    const value = _.get(obj, keyPath.join('.'));
    if (_.isUndefined(value)) {
        return;
    }
    if (Array.isArray(value)) {
        return { arr: value, targetKeyPath, keyPath };
    }
    targetKeyPath.unshift(_.last(keyPath)!);
    return findParentArray(obj, keyPath.slice(0, -1), targetKeyPath);
}

/**
 * Iterates over array items and invokes callback function for each of them.
 * The callback must return a promise and is called with three parameters: array item,
 * item index, array itself. Callbacks are invoked serially, such that callback for the
 * following item will not be called until the promise returned from the previous callback
 * is not fulfilled.
 *
 * @param {array} array
 * @param {function} callback
 * @param {object} [thisArg]
 * @return {Promise<any>}
 */
export function forEachPromise<T, U>(array: T[], callback: (item: T, index: number, array: T[]) => Promise<U>, thisArg: any): Promise<U[]> {
    return new Promise((resolve, reject) => {
        const results: U[] = [];

        function next(index: number) {
            if (index < array.length) {
                callback
                    .call(thisArg, array[index]!, index, array)
                    .then((result) => {
                        results[index] = result;
                        next(index + 1);
                    })
                    .catch((error: any) => {
                        reject(error);
                    });
            } else {
                resolve(results);
            }
        }

        next(0);
    });
}

export function decodeEnvVar(dataString: string): Record<string, any> {
    const data = JSON.parse(dataString);
    return _.mapValues(data, (val: any) => (_.isObject(val) ? JSON.stringify(val) : val));
}

export function pathDifferences(a: any, b: any): string[] {
    function diff(a: any, b: any, result: string[], path: string = '') {
        if (_.isEqual(a, b)) {
            return;
        }
        if (typeof a !== typeof b) {
            result.push(path);
        } else if (_.isArray(a)) {
            if (a.length !== b.length) {
                result.push(path);
            }
            (a.length < b.length ? a : b).forEach((val: any, i: number) => {
                if (!_.isEqual(a[i], b[i]) && a.find((item) => _.isEqual(item, b[i])) && b.find((item: any) => _.isEqual(item, a[i]))) {
                    // handle reordering
                    if (!result.includes(path)) {
                        result.push(path);
                    }
                } else {
                    diff(a[i], b[i], result, `${path}.${i}`);
                }
            });
        } else if (_.isObjectLike(a) && _.isObjectLike(b)) {
            const keys = Object.keys(a);
            const changedKeys = _.xor(keys, Object.keys(b));
            changedKeys.forEach((key) => {
                result.push(_.isEmpty(path) ? key : `${path}.${key}`);
            });
            keys.forEach((key) => {
                if (changedKeys.includes(key)) {
                    return;
                }
                diff(a[key], b[key], result, _.isEmpty(path) ? key : `${path}.${key}`);
            });
        } else {
            result.push(path);
        }
    }
    const result: string[] = [];
    diff(a, b, result);
    return result;
}

/**
 * Get array of difference properties between passed a and b objects
 * @param {Object} a
 * @param {Object} b
 * @returns {Array<String>} changed properties
 */
export function difference(a: Record<string, any>, b: Record<string, any>): string[] {
    const aKeys = Object.keys(a);
    const changedKeys = _.xor(aKeys, Object.keys(b));
    if (changedKeys.length) {
        return changedKeys;
    }
    return _.reduce(
        aKeys,
        (res: string[], aKey) => {
            if (!_.isEqual(a[aKey], b[aKey])) {
                res.push(aKey);
            }
            return res;
        },
        []
    );
}

export interface DeferredPromise {
    resolve: (value: unknown) => void;
    reject: (reason?: any) => void;
    promise: Promise<any>;
}

export function deferredPromise(): DeferredPromise {
    let _resolve: (value: unknown) => void;
    let _reject: (reason?: any) => void;
    const promise = new Promise((resolve, reject) => {
        _resolve = resolve;
        _reject = reject;
    });
    // The executor function is called before the Promise constructor returns:
    // https://262.ecma-international.org/6.0/#sec-promise-executor
    // so it is safe to use Non-null Assertion Operator "!"
    return {
        promise: promise,
        resolve: _resolve!,
        reject: _reject!
    };
}

export async function readDirRecursively(
    dir: string,
    options: { relativeFilePaths?: boolean; filter?: (filePath: string, stats: Stats) => boolean } = {}
): Promise<{ filePath: string; stats: Stats }[]> {
    const dirExists = await fse.pathExists(dir);
    if (!dirExists) {
        return [];
    }
    const rootDir = _.get(options, 'rootDir', dir);
    const files = await fse.readdir(dir);
    const promises = _.map(files, async (file) => {
        const absFilePath = path.join(dir, file);
        const stats: Stats = await fse.stat(absFilePath);
        const filePath = options.relativeFilePaths ? path.relative(rootDir, absFilePath) : absFilePath;
        if (options.filter && !options.filter(filePath, stats)) {
            return null;
        }
        if (stats.isDirectory()) {
            return readDirRecursively(absFilePath, Object.assign({ rootDir }, options));
        } else if (stats.isFile()) {
            return { filePath, stats };
        } else {
            return null;
        }
    });
    const recFiles = await Promise.all(promises);
    return _.chain(recFiles).compact().flatten().value();
}

/**
 * Interpolates page url from file path.
 *
 * This function is useful for git-based CMS projects where page URL depends on
 * the physical file path of the page.
 *
 * @param {string} pageFilePath The file path of the page relative to project root
 * @param {Object} pageModel The computed pageModel of the page
 * @param {Object} pageData The fields of the page object
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The url of the page
 */
export function interpolatePageUrlFromFilePath({
    pageFilePath,
    pageModel,
    pageData,
    pagesDir,
    logger
}: {
    pageFilePath: string;
    pageModel: PageModel;
    pageData: any;
    pagesDir: string;
    logger?: Logger;
}): string {
    const urlPath = pageModel.urlPath;

    // if page's model does not have a 'urlPath' infer the url by getting the relative path between pagesDir and pagePath
    if (!urlPath) {
        return getPageUrlPathFromFilePath(pageFilePath, pagesDir);
    }

    // if page's model defines a 'urlPath', extract tokens and their values from pageModel's filePath
    // and page's physical file path, and interpolate the URL by applying extracted tokens to page pageModel.urlPath.

    // Example 1:
    // In the simple case, the 'urlPath' is '{slug}', and 'filePath' is not defined, the extracted slug would be the file name:
    // urlPath: /posts/{slug}
    // filePath: src/pages/posts/{slug}.md
    // page file: src/pages/posts/hello.md
    // tokens: {slug: 'hello'}
    // interpolated urlPath: /posts/hello

    // Example 2:
    // In more advanced case, the 'filePath' could be different than `urlPath` (e.g.: Jekyll posts),
    // additionally, the date in the filePath can be formatted differently than in the urlPath.
    // In this case, tokens are extracted from filepath and used to interpolate page url.
    // urlPath: /posts/{moment_format(date, "YYYY")}/{slug}
    // filePath: _posts/{moment_format(date, "YYYY-MM-DD")}-{slug}.md
    // actual file: _posts/2020-11-04-hello.md
    // tokens: { slug: 'hello', date: new Date('2020-11-04') }
    // interpolated urlPath: /posts/2020/hello

    let data = pageData;
    if (typeof pageModel.filePath === 'string') {
        const filePathPattern = convertToRegularTokens(cmsCoreUtils.convertToPosixFilePath(pageModel.filePath));
        const tokens = extractTokensAndValuesFromFilePath(pageFilePath, filePathPattern);
        data = _.assign(tokens, pageData);
    }

    try {
        return interpolateUrlPathFromData(urlPath, data);
    } catch (error: any) {
        logger?.error(
            error.message +
                `This may be due to the token missing from the data stored in the "${pageFilePath}" file, ` +
                'or the token could not be extracted from the file path using the ' +
                `"${typeof pageModel.filePath === 'function' ? 'Function' : pageModel.filePath}". ` +
                'provided in the model.filePath. To resolve this issue, use the "siteMap" function ' +
                'to specify the URL paths of pages, or provide a tokenized string for "model.filePath" ' +
                'to allow Stackbit to extract tokens from existing files and use them to interpolate the "model.urlPath"'
        );
        return getPageUrlPathFromFilePath(pageFilePath, pagesDir);
    }
}

/**
 * Computes page url from page's file path.
 * Use this method only when page model urlPath is not defined.
 *
 * @example
 * getPageUrlPathFromFilePath('src/pages/blog/my-blog-post.md', 'src/pages') => blog/my-blog-post
 * getPageUrlPathFromFilePath('content/about.md', 'content') => about
 * getPageUrlPathFromFilePath('projects/index.md', '') => projects
 *
 * @param {string} filePath The file path of the page relative to project root
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The inferred url of the page
 */
export function getPageUrlPathFromFilePath(filePath: string, pagesDir: string): string {
    const relativePath = path.relative(pagesDir, filePath);
    const pathObject = path.parse(relativePath);
    const urlPath = path.join(pathObject.dir, pathObject.name);
    return trimUrlPathIndex(urlPath);
}

/**
 * Extract tokens and their values from filePath based on the filePathPattern.
 *
 * @example
 * extractTokensAndValuesFromFilePath(
 *   '_posts/2020-09-20-hello.md',
 *   '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md'
 * ) => { moment_date: '2020-09-20', slug: 'hello' }
 *
 * @param {string} filePath
 * @param {string} filePathPattern
 * @return {Object} Object with extracted tokens and their values
 */
function extractTokensAndValuesFromFilePath(filePath: string, filePathPattern: string): Record<string, string> {
    // filePath: '_posts/2020-11-04-hello.md'
    // filePathPattern: '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md'
    const usedTokens: Record<string, boolean> = {};
    const regExpStr = filePathPattern
        // escape characters that may conflict with regular expression
        .replace(/[\\.*+\-?^$|()[\]]/g, '\\$&')
        // replace tokens with named capturing group: (?<token>x)
        .replace(/{([^}]+)}(\/?)/g, (match, tokenName: string, slashAfter: string, offset: number) => {
            const momentFormatMatch = tokenName.match(momentFormatEscapedRe);
            if (momentFormatMatch) {
                // for now use naive approach, assume moment's basic format tokens D, DD, M, MM, YY, YYYY, H, HH, m, mm (everything else will fail)
                const dateRe = momentFormatMatch.groups!.format!.replace(/[MYDHm]+/g, '\\d+');
                const dateToken = momentFormatMatch.groups!.param || momentDateToken;
                return `(?<${dateToken}>${dateRe})${slashAfter}`;
            }
            // if token was used, assume it has the same value
            // _posts/{slug}/{moment_format("YYYY-MM-DD")}-{slug}.md
            // _posts/welcome-to-jekyll/2020-08-29-welcome-to-jekyll.md
            if (_.has(usedTokens, tokenName)) {
                return `(?:.+?)${slashAfter}`;
            }
            usedTokens[tokenName] = true;
            // if token is left and right bounded by slashes or the beginning
            // of the string: /pages/{slug}/index.md, then generate regular
            // expression that puts the whole token with the following slash
            // as an optional match: /\/pages\/(?:(?<slug>.+?)/)?\/index.md/
            // Such that the following file path will match '/pages/index.md'
            // this regular expression and produce a match with 'undefined' slug
            // named capturing group which will be converted to an empty string.
            const tokenLeftBounded = offset === 0 || filePathPattern[offset - 1] === '/';
            const tokenRightBounded = slashAfter === '/';
            if (tokenLeftBounded && tokenRightBounded) {
                return `(?:(?<${tokenName}>.+?)/)?`;
            }
            return `(?<${tokenName}>.+?)${slashAfter}`;
        });
    // regExpStr = '_posts/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md'
    const regExp = new RegExp(regExpStr);
    // regExp = /_posts\/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md/
    const match = regExp.exec(filePath);
    // match.groups = {slug: 'hello', moment_date: <DateString>}
    return _.mapValues(match?.groups, (value) => (typeof value === 'undefined' ? '' : value));
}

/**
 * Interpolates url path pattern from data.
 * If token does not exist in data returns original token.
 * When 'moment_format' function does not specify the 'date' parameter, the data should include 'moment_date' field.
 * This is useful when interpolating urls with date tokens based on the dates extracted from physical files.
 *
 * @example
 * interpolateUrlPathFromData('posts/{slug}', { slug: 'hello' })
 * => 'posts/hello'
 *
 * interpolateUrlPathFromData('posts/{moment_format(date, "YYYY-MM-DD")}-{slug}', {
 *   slug: 'hello',
 *   date: new Date('2020-10-10')
 * })
 * => 'posts/2020-10-10-hello'
 *
 * @param urlPath
 * @param data
 * @return {*}
 */
export function interpolateUrlPathFromData(urlPath: string, data: any): string {
    let interpolatedUrlPath = urlPath.replace(/{([^}]+)}/g, (match, tokenName) => {
        const momentFormatMatch = tokenName.match(momentFormatRe);
        if (momentFormatMatch) {
            const date = _.get(data, momentFormatMatch.groups.param || momentDateToken);
            if (!date) {
                throw new Error(`Could not interpolate token "${tokenName}" in model.urlPath: "${urlPath}".`);
            }
            return moment(date).format(momentFormatMatch.groups.format);
        }
        const value = _.get(data, tokenName);
        if (_.isNil(value)) {
            throw new Error(`Could not interpolate token "${tokenName}" in model.urlPath: "${urlPath}".`);
        }
        return value;
    });
    interpolatedUrlPath = interpolatedUrlPath
        .replace(/\/+/g, '/')
        .split('/')
        .map((part) => slugify(part, { lower: true }))
        .join('/');
    return trimUrlPathIndex(interpolatedUrlPath);
}

function trimUrlPathIndex(urlPath: string): string {
    const urlParts = _.split(urlPath, '/');
    if (['index', '_index'].includes(_.last(urlParts)!)) {
        urlParts.pop();
    }
    return urlParts.join('/');
}

export function extractTokensFromString(input: string): string[] {
    const tokens = input.match(/(?<={)[^}]+(?=})/g) || [];
    return _.chain(tokens)
        .map((token) => {
            const momentFormatMatch = token.match(momentFormatRe);
            if (momentFormatMatch) {
                return momentFormatMatch.groups!.param || null;
            }
            return token;
        })
        .compact()
        .value();
}

export function convertToRegularTokens(input: string): string {
    return input.replace(/%([^%]+)%/g, (match, tokenName) => `{${tokenName}}`);
}

export function rename(object: any, oldPath: string | KeyPath, newPath: any | KeyPath) {
    if (_.has(object, oldPath)) {
        _.set(object, newPath, _.get(object, oldPath));
        oldPath = _.toPath(oldPath);
        if (oldPath.length > 1) {
            object = _.get(object, _.initial(oldPath));
        }
        delete object[_.last(oldPath)!];
    }
}

export function obfuscateString(str: string, { showFirst = 3, showLast = 3 }: { showFirst?: number; showLast?: number } = {}): string {
    if (_.isString(str)) {
        if (str.length > (showFirst + showLast) * 3) {
            str = str.slice(0, showFirst) + '...' + str.slice(str.length - showLast);
        } else if (str.length > showFirst * 3) {
            str = str.slice(0, showFirst) + '...';
        } else {
            str = '***';
        }
    }
    return str;
}

export function delayPromise(delay: number) {
    return new Promise((resolve) => setTimeout(resolve, delay));
}

export function withRetry<T>(f: () => Promise<T>, logger: any, maxRetry: number = 2, retryDelay: number = 0, retryCount: number = 0): Promise<T> {
    return f().catch((err) => {
        if (retryCount > maxRetry) {
            if (logger) {
                logger.error('[retry] reached max retry. failing...', { retryCount, maxRetry, err });
            }
            throw err;
        }
        if (logger) {
            logger.warn('[retry] retrying operation', { retryCount, maxRetry, err });
        }
        return delayPromise(retryDelay).then(() => withRetry(f, logger, maxRetry, retryDelay, retryCount + 1));
    });
}

/**
 * Finds an images in the markdown, calls handler with the image path as an argument and replaces
 * the image path within markdown with the returned value of the handler
 *
 * @param {string} markdown
 * @param {Function} handler
 * @returns {string}
 */
export function processMarkdownImagePaths(markdown: string, handler: (imagePath: string) => string): string {
    const re = /(!\[[^\]]*])\(([^)\s]+?)(\s+"[^"]*")?\)/g;
    let reResult;
    let result = '';
    let lastIndex = 0;
    while ((reResult = re.exec(markdown)) !== null) {
        const altText = reResult[1];
        const path = handler(reResult[2]!);
        const title = reResult[3] || '';
        result += markdown.substring(lastIndex, reResult.index);
        result += `${altText}(${path}${title})`;
        lastIndex = re.lastIndex;
    }
    result += markdown.substring(lastIndex);
    return result;
}

export function randomString(): string {
    return crypto.randomBytes(4).toString('hex');
}

// taken from https://github.com/xxorax/node-shell-escape
export function escapeShellValue(value: string): string {
    if (!value || !/[^A-Za-z0-9_/:=-]/.test(value)) {
        return value;
    }
    return (
        "'" +
        value.replace(/'/g, "'\\''") +
        "'"
            .replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
            .replace(/\\'''/g, "\\'")
    );
}
