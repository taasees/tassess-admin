const os = require('os');
const path = require('path');
const fse = require('fs-extra');
const toml = require('@iarna/toml');
const yaml = require('js-yaml');
const rimraf = require('rimraf');
const _ = require('lodash');

module.exports = {
    getNameSlugFromPath,
    parseFile,
    parseFileSync,
    parseDataByFilePath,
    outputData,
    outputDataIfNeeded,
    outputDataSync,
    stringifyDataByFilePath,
    trapPath,
    removeDirectory
};

function trapPath(baseDir, p) {
    if (!p) {
        return p;
    }
    const fullPath = path.join(baseDir, p);
    if (!fullPath.startsWith(baseDir)) {
        return null;
    }
    return _.trimStart(p, '/');
}

function getNameSlugFromPath(filePath, filePathTemplate) {
    const { name, dir, root } = path.parse(filePath);
    const cleanFilePath = path.format({
        base: name,
        dir,
        root
    });
    const baseFilePath = filePathTemplate.split('/').slice(0, -1).join('/');
    let slug = path.relative(baseFilePath, cleanFilePath);
    if (slug === 'index') {
        slug = '';
    }
    return { name, slug };
}

async function parseFile(filePath) {
    const data = await fse.readFile(filePath, 'utf8');
    return parseDataByFilePath(data, filePath);
}

function parseFileSync(filePath) {
    const data = fse.readFileSync(filePath, 'utf8');
    return parseDataByFilePath(data, filePath);
}

function parseDataByFilePath(data, filePath) {
    const extension = path.extname(filePath).substring(1);
    let result;
    switch (extension) {
        case 'yml':
        case 'yaml':
            result = yaml.safeLoad(data, { schema: yaml.JSON_SCHEMA });
            break;
        case 'json':
            result = JSON.parse(data);
            break;
        case 'toml':
            result = toml.parse(data);
            break;
        case 'md':
            data = parseMarkdownWithFrontMatter(data);
            break;
        default:
            throw new Error(`could not parse '${filePath}', extension '${extension}' is not supported`);
    }
    return result;
}

function parseMarkdownWithFrontMatter(string) {
    let frontmatter = null;
    let markdown = string;
    const frontMatterTypes = [
        {
            type: 'yaml',
            startDelimiter: '---\n',
            endDelimiter: '\n---',
            parse: (string) => yaml.safeLoad(string, { schema: yaml.JSON_SCHEMA })
        },
        {
            type: 'toml',
            startDelimiter: '+++\n',
            endDelimiter: '\n+++',
            parse: (string) => toml.parse(string)
        },
        {
            type: 'json',
            startDelimiter: '{\n',
            endDelimiter: '\n}',
            parse: (string) => JSON.parse(string)
        }
    ];
    _.forEach(frontMatterTypes, (fmType) => {
        if (string.startsWith(fmType.startDelimiter)) {
            const index = string.indexOf(fmType.endDelimiter);
            if (index !== -1) {
                // The end delimiter must be followed by EOF or by a new line (possibly preceded with spaces)
                // For example ("." used for spaces):
                //   |---
                //   |title: Title
                //   |---...
                //   |
                //   |Markdown Content
                //   |
                // "index" points to the beginning of the second "---"
                // "endDelimEndIndex" points to the end of the second "---"
                // "afterEndDelim" is everything after the second "---"
                // "afterEndDelimMatch" is the matched "...\n" after the second "---"
                // frontmatter will be: {title: "Title"}
                // markdown will be "\nMarkdown Content\n" (the first \n after end delimiter is discarded)
                const endDelimEndIndex = index + fmType.endDelimiter.length;
                const afterEndDelim = string.substring(endDelimEndIndex);
                const afterEndDelimMatch = afterEndDelim.match(/^\s*?(\n|$)/);
                if (afterEndDelimMatch) {
                    const data = string.substring(fmType.startDelimiter.length, index);
                    frontmatter = fmType.parse(data);
                    markdown = afterEndDelim.substring(afterEndDelimMatch[0].length);
                }
            }
        }
    });
    return _.assign({}, frontmatter, {
        content: markdown
    });
}

async function outputData(filePath, data) {
    const res = stringifyDataByFilePath(data, filePath);
    await fse.outputFile(filePath, res);
}

async function outputDataIfNeeded(filePath, data) {
    const res = stringifyDataByFilePath(data, filePath);
    const fileExists = await fse.pathExists(filePath);
    const existingContent = fileExists ? await fse.readFile(filePath, 'utf8') : null;
    if (!fileExists || res !== existingContent) {
        await fse.outputFile(filePath, res);
        return true;
    }
    return false;
}

function outputDataSync(filePath, data) {
    const res = stringifyDataByFilePath(data, filePath);
    fse.outputFileSync(filePath, res);
}

function stringifyDataByFilePath(data, filePath) {
    const extension = path.extname(filePath).substring(1);
    let result;
    switch (extension) {
        case 'yml':
        case 'yaml':
            result = yaml.safeDump(data, { noRefs: true });
            break;
        case 'toml':
            result = toml.stringify(data);
            break;
        case 'json':
            result = JSON.stringify(data, null, 4);
            break;
        case 'md':
            result = markdownStringify(data);
            break;
        case 'html':
            result = _.get(data, 'content', '');
            break;
        default:
            throw new Error(`Build error, data file '${filePath}' could not be created, extension '${extension}' is not supported`);
    }
    return result;
}

function markdownStringify(data) {
    const frontmatterData = _.omit(data, ['content']);
    const frontmatter = yaml.safeDump(frontmatterData, { noRefs: true });
    const content = _.get(data, 'content', '');
    // yaml.safeDump adds new line at the end of its output
    return `---\n${frontmatter}---\n${content}`;
}

function removeDirectory(dir) {
    return new Promise((resolve, reject) => {
        rimraf(dir, (err) => {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
