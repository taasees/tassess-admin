import _ from 'lodash';
import path from 'path';

import { Config, Model, ImageModel, Preset, loadConfigWithModelsPresetsAndValidate } from '@stackbit/sdk';
import {
    Logger,
    UserCommandSpawner,
    SiteMapEntry,
    DistributiveOmit,
    AssetSource,
    ScheduledActionActionType,
    ScheduledActionWithSource,
    TreeViewNode,
    DocumentSpecifier
} from '@stackbit/types';
import * as StackbitTypes from '@stackbit/types';
import type { ContentfulContentSource } from '@stackbit/cms-contentful';
import type { SanityContentSource } from '@stackbit/cms-sanity';
import type { GitContentSource } from '@stackbit/cms-git';

import { ContentStore, ContentStoreTypes, FieldDataRootItem, searchUtils, getCommandRunner, GitService, referencesUtils } from '@stackbit/cms-core';

import { CMSInterface, ContentStoreMeta } from '../types';
import socketService from '../services/socket-service';
import { Worker } from '@stackbit/utils';
import { handleSchemaAssets } from '../utils/schema-assets-manager';
import { Contentful as ContentfulCMS } from './contentful/contentful';
import SanityCMS from './sanity/sanity';
import GitCMS from './git/git';
import { deletePreset, PresetParams, savePreset } from '../services/presets-service';

export interface CommitFile {
    filePath: string;
    description: string;
}

export interface CommitAuthor {
    email: string;
    name?: string;
}

export type CommitAndPushChanges = (files: CommitFile[], author: CommitAuthor) => Promise<void>;

export interface ContentStoreAdapterOptions {
    cmsType: string;
    csiEnabled?: boolean;
    webhookUrl?: string;
    contentfulAccessToken?: string;
    contentfulSpaces?: { spaceId: string; previewToken: string; environment?: string }[];
    sanityProject?: { projectId: string; token: string; studioPath: string; dataset: string; projectUrl: string };
    sanityQuery?: string;
    workers: { gitApp: Worker };
    rootDir: string;
    projectDir: string;
    appDir: string;
    repoUrl?: string;
    repoBranch?: string;
    repoPublishBranch?: string;
    runEnv?: NodeJS.ProcessEnv;
    runUid?: number;
    logger: Logger;
    userLogger: Logger;
    userCommandSpawner?: UserCommandSpawner;
    localDev: boolean;
    skipPush?: boolean;
    assetIdPrefix: string;
    staticAssetsFilePath: string;
    staticAssetsPublicPath: string;
    staticThemeAssetsFilePath: string;
    staticThemeAssetsPublicPath: string;
    defaultContentTypeExtensions: string[];
    commitAndPushChanges?: CommitAndPushChanges;
    devAppRestartNeeded?: () => void;
}

export class ContentStoreAdapter {
    private cmsType: string;
    private csiEnabled: boolean;
    private webhookUrl?: string;
    private stackbitConfig: Config | null = null;
    private workers: { gitApp: Worker };
    private rootDir: string;
    private projectDir: string;
    private appDir: string;
    private repoUrl?: string;
    private repoBranch?: string;
    private repoPublishBranch?: string;
    private runEnv?: NodeJS.ProcessEnv;
    private runUid?: number;
    private logger: Logger;
    private userLogger: Logger;
    private localDev: boolean;
    private skipPush?: boolean;
    private userCommandSpawner?: UserCommandSpawner;
    private assetIdPrefix: string;
    private staticAssetsFilePath: string;
    private staticAssetsPublicPath: string;
    private staticThemeAssetsFilePath: string;
    private staticThemeAssetsPublicPath: string;
    private defaultContentTypeExtensions: string[];
    private commitAndPushChanges?: CommitAndPushChanges;
    private readonly devAppRestartNeeded?: () => void;
    private gitService!: GitService;

    private contentfulAccessToken?: string;
    private contentfulSpaces?: { spaceId: string; previewToken: string; environment?: string }[];
    private sanityProject?: { projectId: string; token: string; studioPath: string; dataset: string; projectUrl: string };
    private sanityQuery?: string;

    private cms?: CMSInterface;
    private contentStore?: ContentStore;

    constructor(options: ContentStoreAdapterOptions) {
        this.cmsType = options.cmsType;
        this.csiEnabled = options.csiEnabled ?? false;
        this.webhookUrl = options.webhookUrl;
        this.workers = options.workers;
        this.rootDir = options.rootDir;
        this.projectDir = options.projectDir;
        this.appDir = options.appDir;
        this.repoUrl = options.repoUrl;
        this.repoBranch = options.repoBranch;
        this.repoPublishBranch = options.repoPublishBranch;
        this.runEnv = options.runEnv;
        this.runUid = options.runUid;
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.localDev = options.localDev;
        this.skipPush = options.skipPush;
        this.userCommandSpawner = options.userCommandSpawner;
        this.assetIdPrefix = options.assetIdPrefix;
        this.staticAssetsFilePath = options.staticAssetsFilePath;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.defaultContentTypeExtensions = options.defaultContentTypeExtensions;
        this.commitAndPushChanges = options.commitAndPushChanges;
        this.devAppRestartNeeded = options.devAppRestartNeeded;

        this.contentfulAccessToken = options.contentfulAccessToken;
        this.contentfulSpaces = options.contentfulSpaces;
        this.sanityProject = options.sanityProject;
        this.sanityQuery = options.sanityQuery;
    }

    async init({ stackbitConfig }: { stackbitConfig: Config | null }) {
        const runCommand = getCommandRunner({
            env: this.runEnv ?? {},
            uid: this.runUid
        });
        this.gitService = new GitService({
            repoUrl: this.repoUrl ?? '',
            repoDir: this.projectDir,
            repoBranch: this.repoBranch ?? 'preview',
            repoPublishBranch: this.repoPublishBranch ?? 'master',
            worker: this.workers.gitApp,
            runCommand,
            skipPush: this.skipPush,
            logger: this.logger,
            userLogger: this.userLogger
        });
        this.stackbitConfig = await this.extendStackbitConfigWithContentSources(stackbitConfig);
        if (this.stackbitConfig?.contentSources || this.stackbitConfig?.connectors) {
            this.userLogger.info('Using Content Source Interface');
            const stackbitYamlDir = this.stackbitConfig.dirPath;
            this.contentStore = new ContentStore({
                logger: this.logger,
                userLogger: this.userLogger,
                localDev: this.localDev,
                staticAssetsPublicPath: this.staticAssetsPublicPath,
                webhookUrl: this.webhookUrl,
                runCommand,
                git: this.gitService,
                userCommandSpawner: this.userCommandSpawner,
                onSchemaChangeCallback: () => socketService.notifySchemaChange(),
                onContentChangeCallback: (contentChanges) => {
                    socketService.notifyObjectsChanged({
                        changedObjects: _.reduce(
                            _.pick(contentChanges, [
                                'createdDocuments',
                                'createdAssets',
                                'updatedDocuments',
                                'updatedAssets',
                                'deletedDocuments',
                                'deletedAssets'
                            ]),
                            (changedObjects, changedItems, key) => {
                                let type: ContentStoreTypes.ContentChangeType;
                                let srcObjectType: ContentStoreTypes.ContentChangeResultItem['srcObjectType'];
                                switch (key) {
                                    case 'createdDocuments':
                                        type = 'added';
                                        srcObjectType = 'document';
                                        break;

                                    case 'createdAssets':
                                        type = 'added';
                                        srcObjectType = 'asset';
                                        break;

                                    case 'updatedDocuments':
                                        type = 'modified';
                                        srcObjectType = 'document';
                                        break;

                                    case 'updatedAssets':
                                        type = 'modified';
                                        srcObjectType = 'asset';
                                        break;

                                    case 'deletedDocuments':
                                        type = 'deleted';
                                        srcObjectType = 'document';
                                        break;

                                    case 'deletedAssets':
                                        type = 'deleted';
                                        srcObjectType = 'asset';
                                        break;
                                }

                                const resultItems = changedItems.map((item) => ({
                                    ...item,
                                    type,
                                    srcObjectType
                                }));
                                changedObjects.push(...resultItems);

                                return changedObjects;
                            },
                            [] as ContentStoreTypes.ContentChangeResultItem[]
                        ),
                        changedScheduledActions: _.reduce(
                            _.pick(contentChanges, ['createdScheduledActions', 'updatedScheduledActions', 'deletedScheduledActions']),
                            (changedObjects, changedItems, key) => {
                                let type: ContentStoreTypes.ContentChangeType;
                                switch (key) {
                                    case 'createdScheduledActions':
                                        type = 'added';
                                        break;

                                    case 'updatedScheduledActions':
                                        type = 'modified';
                                        break;

                                    case 'deletedScheduledAction':
                                        type = 'deleted';
                                        break;
                                }
                                const resultItems = changedItems.map((item) => ({ ...item, type }));
                                changedObjects.push(...resultItems);
                                return changedObjects;
                            },
                            [] as ContentStoreTypes.ContentChangeResultScheduledAction[]
                        )
                    });
                },
                onActionStateChangeCallback: (actionStateChange) => socketService.notifyActionStateChange(actionStateChange),
                handleConfigAssets: async ({ models, presets }) => {
                    return handleSchemaAssets({
                        models,
                        presets,
                        rootDir: this.rootDir,
                        stackbitYamlDir: stackbitYamlDir,
                        logger: this.logger,
                        userLogger: this.userLogger,
                        staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                        staticThemeAssetsFilePath: this.staticThemeAssetsFilePath
                    });
                },
                devAppRestartNeeded: this.devAppRestartNeeded
            });
            await this.contentStore.init({ stackbitConfig: this.stackbitConfig });
        } else {
            this.userLogger.info(`Loading from ${this.cmsType || 'git'}...`);
            this.cms = this.createCms();
            await this.cms.run({ spawnRunner: this.userCommandSpawner });
        }
    }

    async destroy() {
        await this.contentStore?.destroy();
    }

    isContentStoreEnabled() {
        return Boolean(this.contentStore);
    }

    getGitService() {
        return this.gitService;
    }

    async onStackbitConfigChange({ stackbitConfig }: { stackbitConfig: Config | null }) {
        if (stackbitConfig?.filePath) {
            this.userLogger.info(`reloading stackbit config from: ${path.relative(this.rootDir, stackbitConfig.filePath)}`);
        }
        this.stackbitConfig = await this.extendStackbitConfigWithContentSources(stackbitConfig);

        if (this.contentStore) {
            try {
                await this.contentStore.onStackbitConfigChange({ stackbitConfig: this.stackbitConfig });
            } catch (error: any) {
                const errorMessage = 'error loading stackbit config';
                if (error.stack) {
                    this.userLogger.error(`${errorMessage}:\n ${error.stack}`);
                } else if (error.message) {
                    this.userLogger.error(`${errorMessage}: ${error.message}`);
                }
                this.userLogger.error(errorMessage, { error });
            }
        } else if (this.cms) {
            await this.cms.restart({ spawnRunner: this.userCommandSpawner }).catch(() => {});
        }

        socketService.notifySchemaChange();
    }

    private async extendStackbitConfigWithContentSources(config: Config | null): Promise<Config | null> {
        // if there is no config, or config already has contentSources, return it
        if (!config || config?.contentSources || config?.connectors) {
            return config;
        }

        // if CSI enabled, and cmsType is one of the CSI supported content-sources,
        // create content-sources according to the cmsType
        const supportedContentSources = ['git', 'contentful', 'sanity'];
        const forceCSI = (!this.cmsType || supportedContentSources.includes(this.cmsType)) && this.csiEnabled;
        if (!forceCSI) {
            return config;
        }

        // for backward compatibility use ContentfulContentSource when stackbit.yaml has cmsType === 'contentful'
        if (this.cmsType === 'contentful') {
            const contentfulContentSourceModule = await importContentSourceModule('@stackbit/cms-contentful');
            const contentSources = this.contentfulSpaces!.map((space) => {
                return new (contentfulContentSourceModule.ContentfulContentSource as typeof ContentfulContentSource)({
                    spaceId: space.spaceId,
                    previewToken: space.previewToken,
                    accessToken: this.contentfulAccessToken!
                });
            });
            return {
                ...config,
                contentSources
            };
        }

        // for backward compatibility use SanityContentSource when stackbit.yaml has cmsType === 'sanity'
        if (this.cmsType === 'sanity') {
            if (!this.sanityProject) {
                this.userLogger.error('Cannot create SanityContentSource, missing sanity project data');
                throw new Error('Cannot create SanityContentSource, missing sanity project data');
            }
            const sanityContentSourceModule = await importContentSourceModule('@stackbit/cms-sanity');
            const contentSources = [
                new (sanityContentSourceModule.SanityContentSource as typeof SanityContentSource)({
                    token: this.sanityProject.token,
                    projectId: this.sanityProject.projectId,
                    dataset: this.sanityProject.dataset || 'production',
                    studioPath: path.join(this.appDir, this.sanityProject.studioPath || 'studio'),
                    studioUrl: this.sanityProject.projectUrl,
                    rootPath: this.projectDir
                })
            ];
            return {
                ...config,
                contentSources
            };
        }

        if (!this.cmsType || this.cmsType === 'git') {
            const gitContentSourceModule = await importContentSourceModule('@stackbit/cms-git');
            const result = await loadConfigWithModelsPresetsAndValidate({
                dirPath: this.projectDir,
                isForcedGitCSI: true
            });
            for (const error of result.errors) {
                this.userLogger.warn('error in stackbit config: ' + error.message);
            }
            const contentSources = [
                new (gitContentSourceModule.GitContentSource as typeof GitContentSource)({
                    rootPath: this.projectDir,
                    contentDirs: [config.pagesDir, config.dataDir].filter(Boolean) as string[],
                    assetsConfig: config.assets,
                    models: result.config?.models ?? []
                })
            ];
            return {
                ...config,
                contentSources
            };
        }

        throw new Error(`no default content source for cmsType: ${this.cmsType}`);

        // for backward compatibility use ContentfulContentSource when stackbit.yaml has cmsType === 'git'
        // const gitContentSourceModule = await importContentSourceModule('@stackbit/cms-git');
        // return ...
    }

    private createCms(): CMSInterface {
        // Remove once sanity and git-cms are implemented as ContentSourceInterface
        if (this.cmsType === 'contentful') {
            return new ContentfulCMS({
                accessToken: this.contentfulAccessToken ?? null,
                spaces: this.contentfulSpaces!,
                stackbitConfig: this.stackbitConfig,
                encodeDelimiter: '',
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                watchForContentUpdates: true,
                onContentUpdate: () => {},
                logger: this.logger,
                userLogger: this.userLogger
            });
        } else if (this.cmsType === 'sanity') {
            return new SanityCMS({
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                stackbitConfig: this.stackbitConfig,
                sanityQuery: this.sanityQuery,
                encodeDelimiter: '',
                workers: this.workers,
                project: {
                    token: this.sanityProject?.token,
                    projectId: this.sanityProject?.projectId,
                    dataset: this.sanityProject?.dataset,
                    studioPath: this.sanityProject?.studioPath,
                    projectUrl: this.sanityProject?.projectUrl
                },
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                onContentUpdate: () => {},
                logger: this.logger,
                userLogger: this.userLogger
            });
        } else {
            return new GitCMS({
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                repoUrl: this.repoUrl,
                repoBranch: this.repoBranch,
                stackbitConfig: this.stackbitConfig,
                workers: this.workers,
                assetIdPrefix: this.assetIdPrefix,
                staticAssetsFilePath: this.staticAssetsFilePath,
                staticAssetsPublicPath: this.staticAssetsPublicPath,
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                defaultContentTypeExtensions: this.defaultContentTypeExtensions,
                commitAndPushChanges: this.commitAndPushChanges,
                logger: this.logger,
                userLogger: this.userLogger
            });
        }
    }

    async keepAlive() {
        if (this.contentStore) {
            this.contentStore.keepAlive().catch((error) => {
                this.logger.error('keepAlive error', { error });
            });
        } else if (this.cms) {
            _.invoke(this.cms, 'keepAlive');
        } else {
            throw new Error('Content source plugin missing required method: keepAlive');
        }
    }

    async handleFileChanges(filePaths: string[]): Promise<{ schemaChanged?: boolean }> {
        if (!filePaths.length) {
            this.logger.debug('no changes');
            return {
                schemaChanged: false
            };
        }

        let schemaChanged = false;

        if (this.contentStore) {
            const updatedFiles = filePaths.map((filePath) => path.relative(this.appDir, path.join(this.projectDir, filePath)));
            // schemaChanged and contentChanged events are handled within content-store
            await this.contentStore.onFilesChange(updatedFiles);
        } else if (this.cms) {
            const pullResult = await this.cms
                .postPull(
                    filePaths.map((filePath) => path.join(this.projectDir, filePath)),
                    {
                        spawnRunner: this.userCommandSpawner
                    }
                )
                .catch((err: any) => {
                    this.logger.debug('Error in postPull', { err });
                    throw err;
                });
            schemaChanged = !!pullResult?.schemaChanged;
        }

        if (schemaChanged) {
            socketService.notifySchemaChange();
        }

        return { schemaChanged };
    }

    getLocales(): ContentStoreTypes.ContentStoreLocale[] | undefined {
        if (this.contentStore) {
            return this.contentStore.getLocales();
        } else if (this.cms) {
            return _.result(this.cms, 'getLocales');
        } else {
            throw new Error('Content source plugin missing required method: getLocales');
        }
    }

    getPresets({ locale }: { locale?: string } = {}): Record<string, any> {
        if (this.contentStore) {
            return this.contentStore.getPresets({ locale });
        } else if (this.cms) {
            return _.result(this.cms, 'getPresets', {});
        } else {
            throw new Error('Content source plugin missing required method: getPresets');
        }
    }

    getModelsByContentSourceType({ locale, user }: { locale?: string; user?: ContentStoreTypes.User } = {}): Record<
        string,
        Record<string, Record<string, Model | ImageModel>>
    > | null {
        if (this.contentStore) {
            // contentStore models already localized to default locale
            return this.contentStore.getModels({ user });
        } else if (this.cms) {
            const schemaKey = this.cms.getSchemaKey();
            const mappedModels = this.cms.getMappedModels(locale);
            return { [schemaKey]: mappedModels };
        } else {
            throw new Error('Content source plugin missing required method: getModelsByContentSourceType');
        }
    }

    getContentSourceEnvironmentForContentSourceTypeAndId({ srcProjectId, srcType }: { srcProjectId: string; srcType: string }): string {
        if (this.contentStore) {
            return this.contentStore.getContentSourceEnvironment({ srcProjectId, srcType });
        } else if (this.cms) {
            return this.cms.getEnvironmentForProjectId(srcProjectId);
        } else {
            throw new Error('Content source plugin missing required method: getContentSourceEnvironmentForContentSourceTypeAndId');
        }
    }

    getContentSourceTypes(): string[] {
        if (this.contentStore) {
            return _.uniq(this.contentStore.getContentSourceMeta().map((source) => source.srcType));
        }
        return [];
    }

    getContentSourceMeta(): ContentStoreMeta[] {
        if (this.contentStore) {
            return this.contentStore.getContentSourceMeta();
        }
        return [];
    }

    async getGlobalActions(data: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<(ContentStoreTypes.APICustomAction & { type: 'global' | 'bulk' })[]> {
        if (this.contentStore) {
            return this.contentStore.getGlobalActions(data);
        }
        return [];
    }

    async getCustomActions(data: ContentStoreTypes.APIGetCustomActionRequest): Promise<ContentStoreTypes.APICustomAction[]> {
        if (this.contentStore) {
            return this.contentStore.getCustomActions(data);
        }
        return [];
    }

    async runCustomAction(data: ContentStoreTypes.APIRunCustomActionRequest) {
        if (this.contentStore) {
            return this.contentStore.runCustomAction(data);
        }
    }

    getAssetSources(): DistributiveOmit<AssetSource, 'transform' | 'preview'>[] {
        if (!this.contentStore) {
            return [];
        }
        return this.contentStore.getAssetSources();
    }

    async hasAccess(data: { srcType?: string; srcProjectId?: string; user?: ContentStoreTypes.User }): Promise<ContentStoreTypes.HasAccessResult> {
        if (this.contentStore) {
            return this.contentStore.hasAccess(data ?? {});
        } else if (this.localDev) {
            // we shouldn't reach this point because when content store isn't
            // enabled hasAccess would be handled by the API.
            return {
                hasConnection: true,
                hasPermissions: true,
                contentSources: []
            };
        }
        throw new Error('Content source plugin missing required method: hasAccess');
    }

    hasChanges({ documents }: { documents?: { srcType: string; srcProjectId: string; srcObjectId: string }[] }): {
        hasChanges: boolean;
        changedObjects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    } {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: hasChanges');
        }
        return this.contentStore.hasChanges({ documents });
    }

    getSiteMapEntries(options: { locale?: string; user?: ContentStoreTypes.User }): SiteMapEntry[] {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getSiteMapEntries');
        }
        return this.contentStore.getSiteMapEntries(options);
    }

    getTreeViews({ user }: { user?: ContentStoreTypes.User }): TreeViewNode[] {
        if (!this.contentStore) {
            throw new Error('not implemented');
        }
        return this.contentStore.getTreeViews({ user });
    }

    getSiteMapEntriesForDocument(options: { srcType: string; srcProjectId: string; srcDocumentId: string; locale?: string }): SiteMapEntry[] {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getSiteMapEntriesForDocument');
        }
        return this.contentStore.getSiteMapEntriesForDocument(options);
    }

    getDocument({
        srcDocumentId,
        srcProjectId,
        srcType,
        user
    }: {
        srcDocumentId: string;
        srcProjectId: string;
        srcType: string;
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.Document | undefined {
        if (this.contentStore) {
            return this.contentStore.getDocument({ srcDocumentId, srcProjectId, srcType, user });
        } else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = _.get(encodingResult, 'fieldData');
            const document = _.find(fieldData, { srcObjectId: srcDocumentId, srcProjectId: srcProjectId });
            if (!document) {
                return;
            }
            if (document.type !== 'object') {
                return;
            }
            return {
                ...document,
                getPreview: () => ({ previewTitle: document.srcObjectLabel }),
                type: 'document'
            };
        }
    }

    getDocumentsByContext({ context, srcProjectId, srcType }: { context: any; srcProjectId?: string; srcType: string }): ContentStoreTypes.Document[] {
        if (this.contentStore) {
            return this.contentStore.getDocumentsByContext({ context, srcProjectId, srcType });
        }
        return [];
    }

    getDocuments({ locale, user }: { locale?: string; user?: ContentStoreTypes.User }): ContentStoreTypes.Document[] {
        if (this.contentStore) {
            return this.contentStore.getDocuments({ locale, user });
        } else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = _.get(encodingResult, 'fieldData');
            return _.values(fieldData)
                .filter((object): object is FieldDataRootItem & { type: 'object' } => object.type === 'object')
                .map(({ type, ...rest }) => ({
                    type: 'document',
                    getPreview: () => ({ previewTitle: rest.srcObjectLabel }),
                    ...rest
                }));
        } else {
            throw new Error('Content source plugin missing required method: getDocuments');
        }
    }

    getReferenceMap(): ContentStoreTypes.ReferenceMap {
        if (this.contentStore) {
            return this.contentStore.getReferenceMap();
        } else if (this.cms) {
            const allContent: (ContentStoreTypes.Asset | ContentStoreTypes.Document)[] = [...this.getDocuments({}), ...this.getAssets({})];
            return referencesUtils.getReferenceMap(allContent);
        } else {
            throw new Error('Reference maps are not supported');
        }
    }

    getAssets({ locale, user }: { locale?: string; user?: ContentStoreTypes.User }): ContentStoreTypes.Asset[] {
        if (this.contentStore) {
            return this.contentStore.getAssets({ locale, user });
        } else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = _.get(encodingResult, 'fieldData');
            return _.values(fieldData)
                .filter((object): object is FieldDataRootItem & { type: 'image' | 'file' } => object.type === 'image' || object.type === 'file')
                .map(({ type, fields, ...rest }) => ({
                    type: 'asset',
                    ...rest,
                    fields: {
                        title: fields.title,
                        file: {
                            type: 'assetFile',
                            url: fields.url
                        }
                    }
                }));
        } else {
            throw new Error('Content source plugin missing required method: getAssets');
        }
    }

    getAssetFilePath(url: string) {
        const assets = this.getAssets({});
        const matchingAsset = assets.find((asset) => {
            if (asset.fields.file.localized) {
                return Object.values(asset.fields.file.locales).find((locale) => {
                    return locale.url === url;
                });
            }
            return asset.fields.file.url === url;
        });
        if (matchingAsset) {
            if (matchingAsset.fields.file.localized) {
                for (const locale in matchingAsset.fields.file.locales) {
                    return matchingAsset.fields.file.locales[locale]?.fileName;
                }
                return undefined;
            }
            return matchingAsset.fields.file.fileName;
        }
    }

    getLocalizedApiObjects({
        locale,
        objectIds,
        user
    }: {
        locale?: string;
        objectIds?: string[];
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.APIObject[] {
        if (this.contentStore) {
            return this.contentStore.getLocalizedApiObjects({ locale, objectIds, user });
        } else if (this.cms) {
            let fieldData = this.cms.getLocalizedFieldData(locale);
            if (!fieldData) {
                return [];
            }
            if (objectIds) {
                fieldData = _.pick(fieldData, objectIds);
            }
            return Object.values(fieldData) as ContentStoreTypes.APIObject[];
        } else {
            throw new Error('Content source plugin missing required method: getLocalizedApiObjects');
        }
    }

    async createPreset({
        dir,
        presetParams,
        preset,
        user
    }: {
        dir: string;
        presetParams: PresetParams;
        preset: Preset;
        user?: ContentStoreTypes.User;
    }): Promise<{ files: string[]; preset: Preset }> {
        if (this.contentStore?.usesContentSourcePresets()) {
            await this.contentStore.createPreset({ preset, thumbnailAsset: presetParams.thumbnail, user });
            return {
                files: [],
                preset
            };
        } else {
            const result = await savePreset(dir, presetParams, preset, this.logger);
            const changeLog = result.files.map((filePath) => ({
                filePath: path.join(dir, filePath),
                description: 'added preset: ' + preset.label
            }));
            if (user) {
                await this.commitAndPushChanges?.(changeLog, user);
            }
            return result;
        }
    }

    async deletePreset({ dir, presetId, user }: { dir: string; presetId: string; user?: ContentStoreTypes.User }) {
        if (this.contentStore?.usesContentSourcePresets()) {
            await this.contentStore.deletePreset({ presetId, user });
            return {
                changes: [],
                filesRemoved: []
            };
        } else {
            const filesRemoved = await deletePreset(dir, presetId, this.logger);
            const changeLog = filesRemoved.map((filePath) => ({
                filePath: path.join(dir, filePath),
                description: 'removed preset'
            }));
            if (user) {
                await this.commitAndPushChanges?.(changeLog, user);
            }
            return {
                changes: changeLog,
                filesRemoved: filesRemoved
            };
        }
    }

    async createDocument(data: {
        srcType: string;
        srcProjectId: string;
        modelName: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
        defaultLocaleDocumentId?: string;
    }): Promise<{ srcDocumentId: string }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: createDocument');
        }
        return this.contentStore.createDocument(data);
    }

    async createAndLinkDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        modelName: string;
        refSrcType?: string;
        refProjectId?: string;
        object?: Record<string, any>;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string; createdDocumentId: string }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: createAndLinkDocument');
        }
        return this.contentStore.createAndLinkDocument(data);
    }

    async uploadAndLinkAsset(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        asset: ContentStoreTypes.UploadAssetData;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: uploadAndLinkAsset');
        }
        return this.contentStore.uploadAndLinkAsset(data);
    }

    async duplicateDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: duplicateDocument');
        }
        return this.contentStore.duplicateDocument(data);
    }

    async updateDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        updateOperations: ContentStoreTypes.UpdateOperation[];
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        if (!this.contentStore?.updateDocument) {
            throw new Error('Content source plugin missing required method: updateDocument');
        }
        return this.contentStore.updateDocument(data);
    }

    async deleteDocument(data: { srcType: string; srcProjectId: string; srcDocumentId: string; user?: ContentStoreTypes.User }): Promise<void> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: deleteDocument');
        }
        return this.contentStore.deleteDocument(data);
    }

    async archiveDocument(data: { srcType: string; srcProjectId: string; srcDocumentId: string; user?: ContentStoreTypes.User }): Promise<void> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: archiveDocument');
        }
        return this.contentStore.archiveDocument(data);
    }

    async unarchiveDocument(data: { srcType: string; srcProjectId: string; srcDocumentId: string; user?: ContentStoreTypes.User }): Promise<void> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: unarchiveDocument');
        }
        return this.contentStore.unarchiveDocument(data);
    }

    async getScheduledActions(): Promise<{ scheduledActions: ScheduledActionWithSource[] }> {
        if (!this.contentStore?.getScheduledActions) {
            throw new Error('Content source plugin missing required method: getScheduledActions');
        }
        const scheduledActions = this.contentStore.getScheduledActions();
        return { scheduledActions };
    }

    async createScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        name: string;
        documentIds: string[];
        executeAt: string;
        action: ScheduledActionActionType;
        user?: ContentStoreTypes.User;
    }): Promise<{ newScheduledActionId: string }> {
        if (!this.contentStore?.createScheduledAction) {
            throw new Error('Content source plugin missing required method: createScheduledAction');
        }
        return this.contentStore.createScheduledAction(data);
    }

    async cancelScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ cancelledScheduledActionId: string }> {
        if (!this.contentStore?.cancelScheduledAction) {
            throw new Error('Content source plugin missing required method: cancelScheduledAction');
        }
        return this.contentStore.cancelScheduledAction(data);
    }

    async updateScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        name?: string;
        documentIds?: string[];
        executeAt?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ updatedScheduledActionId: string }> {
        if (!this.contentStore?.updateScheduledAction) {
            throw new Error('Content source plugin missing required method: updateScheduledAction');
        }
        return this.contentStore.updateScheduledAction(data);
    }

    async searchDocuments(data: {
        query?: string;
        filter?: ContentStoreTypes.SearchFilter;
        models: Array<{
            srcProjectId: string;
            srcType: string;
            modelName: string;
        }>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        total: number;
        items: ContentStoreTypes.Document[];
    }> {
        if (this.contentStore) {
            return this.contentStore.searchDocuments(data);
        }
        if (this.cms) {
            const { locale, user } = data;
            const documents = this.getDocuments({ locale, user });
            const schema = this.getModelsByContentSourceType({ locale, user }) ?? {};
            return searchUtils.searchDocuments({
                ...data,
                documents,
                schema
            });
        }
        throw new Error('Content source plugin missing required method: searchDocuments');
    }

    async getDocumentVersions(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ versions: ContentStoreTypes.APIDocumentVersion[] }> {
        if (!this.contentStore?.getDocumentVersions) {
            throw new Error('Content source plugin missing required method: getDocumentVersions');
        }

        return this.contentStore.getDocumentVersions(data);
    }

    async getDocumentForVersion(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        versionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ version: ContentStoreTypes.APIDocumentVersionWithDocument }> {
        if (!this.contentStore?.getDocumentForVersion) {
            throw new Error('Content source plugin missing required method: getDocumentForVersion');
        }
        return this.contentStore.getDocumentForVersion(data);
    }

    async validateDocuments(data: {
        objects: { srcType: string; srcProjectId: string; srcObjectId: string }[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ errors: ContentStoreTypes.ValidationError[] }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: validateDocuments');
        }
        return this.contentStore.validateDocuments(data);
    }

    async publishDocuments(data: { objects: { srcType: string; srcProjectId: string; srcObjectId: string }[]; user?: ContentStoreTypes.User }): Promise<void> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: publishDocuments');
        }
        return this.contentStore.publishDocuments(data);
    }

    async unpublishDocuments(data: {
        objects: { srcType: string; srcProjectId: string; srcObjectId: string }[];
        user?: ContentStoreTypes.User;
    }): Promise<void> {
        if (!this.contentStore?.unpublishDocuments) {
            throw new Error('Content source plugin missing required method: unpublishDocuments');
        }
        return this.contentStore.unpublishDocuments(data);
    }

    async getApiAssets(data: Parameters<ContentStore['getApiAssets']>[0] = {}): Promise<{
        assets: ContentStoreTypes.APIAsset[] | ContentStoreTypes.Asset[];
        pageSize: number;
        pageNum: number;
        totalPages: number;
    }> {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getApiAssets');
        }
        return this.contentStore.getApiAssets(data);
    }

    async getApiDocuments(data: { documentSpecs?: DocumentSpecifier[]; user?: ContentStoreTypes.User } = {}) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getApiDocuments');
        }
        return this.contentStore.getApiDocuments(data);
    }

    getCSIDocuments(
        data: {
            documentSpecs?: DocumentSpecifier[];
            srcType?: string;
            srcProjectId?: string;
            limit?: number;
            offset?: number;
        } = {}
    ): {
        total: number;
        offset: number;
        documents: StackbitTypes.Document[];
    } {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getCsiDocuments');
        }
        return this.contentStore.getCSIDocuments(data);
    }

    getStagedChanges(data: {
        objects: { srcType: string; srcProjectId: string; srcObjectId: string; srcEnvironment?: string }[];
        locale?: string;
        scope: 'all' | 'content';
        shallow?: boolean;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.StagedChange[]> {
        if (!this.contentStore?.getStagedChanges) {
            throw new Error('Content source plugin missing required method: getStagedChanges');
        }
        return this.contentStore.getStagedChanges(data);
    }

    async uploadAssets({
        srcType,
        srcProjectId,
        assets,
        locale,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        assets: ContentStoreTypes.UploadAssetData[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }) {
        if (this.contentStore) {
            return this.contentStore.uploadAssets({
                srcProjectId,
                srcType,
                assets,
                locale,
                user
            });
        } else if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.uploadAssets(assets, user);
        } else {
            throw new Error('Content source plugin missing required method: uploadAssets');
        }
    }

    onWebhook(data: { srcType: string; srcProjectId: string; data: unknown; headers: Record<string, string> }) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: onWebhook');
        }
        return this.contentStore.onWebhook(data);
    }

    getObject_deprecated({ objectId, projectId }: { objectId: string; projectId?: string }) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.getObject(objectId, projectId);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async listAssets_deprecated(filterParams: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.listAssets(filterParams);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async getAssets_deprecated(
        data: { pageSize?: number; pageId?: number; searchQuery?: string } = {}
    ): Promise<{ data: ContentStoreTypes.APIAsset[]; meta: { nextPage: number | null } }> {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            const pageId = data.pageId || 1;
            const result = (await this.cms.listAssets(data)) as any;
            return {
                data: result.assets,
                meta: {
                    nextPage: pageId < result.meta.totalPages ? pageId + 1 : null
                }
            };
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async uploadAsset_deprecated({ url, fileName, user }: { url: string; fileName: string; user: any }) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.uploadAsset({ url, fileName, user, data: null });
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async createObject_deprecated(data: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.createObject(data);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async duplicateObject_deprecated(data: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.duplicateObject(data);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async updateObject_deprecated(data: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.updateObject(data.changedFields, data.user);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async updateObject_api_deprecated(objectId: string, projectId: string, object: any, user: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.updateObject_api(objectId, projectId, object, user);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }

    async deleteObject_deprecated(data: any) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof GitCMS) {
            return this.cms.deleteObject(data.srcObjectId, data.user);
        } else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
}

async function importContentSourceModule(packageName: string) {
    let modulePath;
    try {
        modulePath = require.resolve(packageName);
    } catch (error) {
        throw new Error(`can not find ${packageName} package, please add it as a devDependency by running "npm i ${packageName} --save-dev"`);
    }
    let module;
    try {
        module = await import(modulePath);
    } catch (error: any) {
        throw new Error(`could not load ${packageName} module, error: ${error.message}`);
    }
    return module;
}
