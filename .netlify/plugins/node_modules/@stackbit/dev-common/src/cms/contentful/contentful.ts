import _ from 'lodash';
import path from 'path';
import { Config, Model, ImageModel, isStackbitYamlFile, loadConfigWithModelsPresetsAndValidate } from '@stackbit/sdk';
import { reducePromise } from '@stackbit/utils';
import { encodeData, EncodingResult, IMAGE_MODEL, ContentStoreTypes } from '@stackbit/cms-core';
import { localizeFieldData, localizeModels, ContentfulEncoderDelegate, SyncPoller, SyncResult } from '@stackbit/cms-contentful';
import {
    createPlainApiClient,
    fetchAllAssets,
    fetchAllEntries,
    fetchAllLocales,
    fetchAllUsers,
    EntryProps,
    AssetProps,
    LocaleProps,
    UserProps
} from '@stackbit/cms-contentful/dist/contentful-api-client';

import { CMSConstructorOptions, CMSInterface, OnContentUpdateOptions, PageModel } from '../../types';
import socketService from '../../services/socket-service';

const { handleSchemaAssets } = require('../../utils/schema-assets-manager');

const STACKBIT_URL_PATH_FIELD = 'stackbit_url_path';

export interface Space {
    spaceId: string;
    environment?: string;
    previewToken?: string;
}

interface SchemasBySpaceId {
    [spaceId: string]: Config;
}

interface LocalesBySpaceId {
    [spaceId: string]: LocaleProps[];
}

interface UsersBySpaceId {
    [spaceId: string]: UserProps[];
}

export interface ContentfulConstructorOptions extends CMSConstructorOptions {
    spaces: Space[];
    accessToken: string | null;
}

export class Contentful implements CMSInterface {
    private encodingResult: EncodingResult | null;
    private schemasBySpaceId: SchemasBySpaceId | null;
    private localesBySpaceId: LocalesBySpaceId | null;
    private usersBySpaceId: UsersBySpaceId | null;
    private defaultLocalesBySpaceId: Record<string, string> | null;
    private stackbitConfig: Config | null;
    private readonly encodeDelimiter: string;
    private readonly watchForContentUpdates: boolean;
    private readonly onContentUpdate: (options?: OnContentUpdateOptions) => void;
    private readonly spaces: Space[];
    private readonly accessToken: string | null;
    private readonly rootDir: string;
    private readonly appDir: string;
    private readonly repoDir: string;
    private readonly staticThemeAssetsPublicPath: string;
    private readonly staticThemeAssetsFilePath: string;
    private contentPollers: SyncPoller[] | null;
    private logger: any;
    private userLogger: any;

    constructor(options: ContentfulConstructorOptions) {
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.encodingResult = null;
        this.schemasBySpaceId = null;
        this.localesBySpaceId = null;
        this.usersBySpaceId = null;
        this.defaultLocalesBySpaceId = null;
        this.appDir = options.appDir;
        this.stackbitConfig = options.stackbitConfig;
        this.encodeDelimiter = options.encodeDelimiter;
        this.watchForContentUpdates = options.watchForContentUpdates ?? false;
        this.onContentUpdate = options.onContentUpdate ?? _.noop;
        this.spaces = options.spaces;
        this.accessToken = options.accessToken;
        this.rootDir = options.rootDir;
        this.repoDir = options.repoDir;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.contentPollers = null;
    }

    async run() {
        this.logger.debug('run');

        if (!this.accessToken) {
            this.userLogger.error('Contentful "Personal access token" or "OAuth token" was not provided. Please verify your Contentful configuration.');
            return;
        }
        if (_.isEmpty(this.spaces)) {
            this.userLogger.error('No Contentful spaces were configured. Please verify your Contentful configuration.');
            return;
        }

        await this.fetchSchema();
        await this.fetchUsers();
        await this.fetchDataAndEncode();
        this.startWatchingContentUpdates();
    }

    async restart() {
        this.logger.debug('restart');
        const { schemaChanged } = await this.fetchSchema();
        await this.fetchDataAndEncode();

        if (schemaChanged) {
            socketService.notifySchemaChange();
        }
    }

    startWatchingContentUpdates() {
        this.logger.debug('startWatchingContentUpdates');
        this.contentPollers = this.createSyncPollers();
    }

    createSyncPollers() {
        const accessToken = this.accessToken;
        if (_.isEmpty(this.spaces) || !accessToken) {
            return null;
        }
        this.logger.debug('createSyncPollers');
        return this.spaces
            .filter((space) => space.previewToken)
            .map((space) => {
                this.logger.debug('create SyncPoller for space', { spaceId: space.spaceId });
                return new SyncPoller({
                    spaceId: space.spaceId,
                    environment: space.environment ?? 'master',
                    accessToken: space.previewToken!,
                    managementToken: accessToken,
                    notificationCallback: (syncResult) => {
                        this.encodeSyncResult(syncResult, space.spaceId);
                        this.onContentUpdate();
                    },
                    logger: this.logger
                });
            });
    }

    encodeSyncResult(syncResult: SyncResult, spaceId: string) {
        // remove deleted entries and assets from fieldData
        // generally, the "sync" method of the preview API never notifies of deleted objects, therefore we rely on
        // the deleteObject method to notify the user that restart is needed. Then, once user restarts the SSG, it
        // will re-fetch the data effectively removing deleted objects
        // https://www.notion.so/stackbit/Contentful-Sync-API-preview-issue-6b4816ebceef4ab181cdf1603058d324
        this.logger.debug(
            `received sync data, entries: ${syncResult.entries.length}, assets: ${syncResult.assets.length}, deletedEntries: ${syncResult.deletedEntries.length}, deletedAssets: ${syncResult.deletedAssets.length}`
        );
        const fieldData = this.encodingResult?.fieldData;
        if (fieldData) {
            syncResult.deletedEntries.forEach((deletedEntry) => {
                delete fieldData[deletedEntry.sys.id];
            });
            syncResult.deletedAssets.forEach((deletedAsset) => {
                delete fieldData[deletedAsset.sys.id];
            });
        }

        // re-encode updated/new entries and assets
        const delegate = this.getEncoderDelegateForSpaceId(spaceId);
        this.encodingResult = encodeData({
            data: [...syncResult.entries, ...syncResult.assets],
            prevEncodingResult: this.encodingResult,
            delegate: delegate,
            encodeDelimiter: this.encodeDelimiter
        });

        if (syncResult.entries.length) {
            socketService.notifyObjectsChanged({
                changedObjects: syncResult.entries.map((entry) => ({
                    srcObjectId: entry.sys.id,
                    srcType: 'contentful',
                    srcProjectId: entry.sys.space.sys.id
                }))
            });
        }
    }

    getEncoderDelegateForSpaceId(spaceId: string) {
        const schema = _.get(this.schemasBySpaceId, spaceId);
        const defaultLocale = this.getDefaultLocaleForSpaceId(spaceId);
        const users = this.getUsersForSpaceId(spaceId);
        if (!schema) {
            return null;
        }
        return new ContentfulEncoderDelegate({
            schema,
            noEncodeFields: _.union(this.stackbitConfig?.noEncodeFields, [STACKBIT_URL_PATH_FIELD]),
            omitFields: this.stackbitConfig?.omitFields,
            encodedFieldTypes: this.stackbitConfig?.encodedFieldTypes as any,
            defaultLocale: defaultLocale || undefined,
            users
        });
    }

    getEncodingResult() {
        this.logger.debug('get encoding');
        return this.encodingResult;
    }

    getLocales(): ContentStoreTypes.ContentStoreLocale[] {
        return _.reduce(
            this.localesBySpaceId,
            (res, locales, srcProjectId) => {
                return res.concat({
                    srcType: this.getSchemaKey(),
                    srcProjectId,
                    locales: locales.map((locale) => locale.code),
                    defaultLocale: this.defaultLocalesBySpaceId?.[srcProjectId]
                });
            },
            [] as ContentStoreTypes.ContentStoreLocale[]
        );
    }

    getLocalizedFieldFromPageEntry(pageModel: PageModel, pageEntry: any, fieldName: string, locale: string): string {
        let fieldValue = _.get(pageEntry, ['fields', fieldName, 'value']);
        if (!fieldValue && locale) {
            fieldValue = _.get(pageEntry, ['fields', fieldName, 'locales', locale, 'value']);
        }
        return fieldValue;
    }

    getPresets() {
        return _.reduce(
            this.schemasBySpaceId,
            (presets: Record<string, any>, spaceSchema) => {
                return Object.assign(presets, spaceSchema.presets);
            },
            {}
        );
    }

    getSchemaKey() {
        return 'contentful';
    }

    getMappedModels(locale?: string) {
        return _.mapValues(this.schemasBySpaceId, (spaceSchema, spaceId) => {
            const defaultLocale = this.defaultLocalesBySpaceId?.[spaceId];
            const models = [...localizeModels(spaceSchema.models, defaultLocale, locale), IMAGE_MODEL];
            return _.keyBy(models, 'name');
        });
    }

    getModelsForProjectId(projectId: string): (Model | ImageModel)[] {
        return [...(this.schemasBySpaceId?.[projectId]?.models ?? []), IMAGE_MODEL];
    }

    getEnvironmentForProjectId(projectId: string) {
        const space = _.find(this.spaces, { spaceId: projectId });
        return space?.environment ?? 'master';
    }

    getLocalizedFieldData(locale?: string) {
        const fieldData = this.encodingResult?.fieldData;
        if (!fieldData) {
            return null;
        }
        return localizeFieldData(fieldData, locale, this.defaultLocalesBySpaceId);
    }

    getDefaultLocaleForSpaceId(spaceId: string): string | null {
        return this.defaultLocalesBySpaceId?.[spaceId] ?? null;
    }

    getUsersForSpaceId(spaceId: string): UserProps[] {
        return this.usersBySpaceId?.[spaceId] ?? [];
    }

    async fetchSchema(): Promise<{ schemaChanged: boolean }> {
        const accessToken = this.accessToken;
        if (_.isEmpty(this.spaces) || !accessToken) {
            this.userLogger.error('Error fetching Contentful schema. Please verify your Contentful configuration.');
            return { schemaChanged: false };
        }
        this.logger.info('Fetching Contentful schema...');

        const prevSchemasBySpaceId = this.schemasBySpaceId;

        try {
            this.logger.debug('fetch schemas for spaces', { spaceIds: _.map(this.spaces, 'spaceId') });
            this.schemasBySpaceId = await reducePromise(
                this.spaces,
                async (schemasBySpaceIds: SchemasBySpaceId, space: Space) => {
                    // The default @stackbit/cms-contentful is for backward compatibility, All future sites and themes
                    // that use contentful must have @stackbit/cms-contentful inside their package.json
                    const defaultContentfulCMSModel = require.resolve('@stackbit/cms-contentful');
                    const { config, errors } = await loadConfigWithModelsPresetsAndValidate({
                        dirPath: this.stackbitConfig?.dirPath ?? this.repoDir,
                        modelsSource: {
                            type: 'contentful',
                            module: defaultContentfulCMSModel,
                            accessToken: accessToken,
                            spaceId: space.spaceId,
                            environment: space.environment ?? 'master'
                        }
                    });
                    _.forEach(errors, (error) => {
                        this.userLogger.warn(error.message);
                    });
                    if (config) {
                        const { models, presets } = await handleSchemaAssets({
                            models: config.models,
                            presets: config.presets,
                            rootDir: this.rootDir,
                            stackbitYamlDir: this.stackbitConfig?.dirPath ?? this.repoDir,
                            logger: this.logger,
                            userLogger: this.userLogger,
                            staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                            staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath
                        });
                        schemasBySpaceIds[space.spaceId] = {
                            ...config,
                            models,
                            presets
                        };
                    }
                    return schemasBySpaceIds;
                },
                {}
            );
            this.logger.debug('successfully fetched all schemas');
        } catch (error) {
            this.logger.debug('error fetching schemas', { error });
            this.userLogger.error('Error fetching Contentful schema. Please verify your Contentful configuration.');
        }

        try {
            await this.fetchLocales();
        } catch (error) {
            this.logger.debug('error fetching locales', { error });
            this.userLogger.error('Error fetching Contentful schema locales. Please verify your Contentful configuration.');
        }

        let schemaChanged = false;
        if (!_.isUndefined(prevSchemasBySpaceId) && !_.isEqual(prevSchemasBySpaceId, this.schemasBySpaceId)) {
            schemaChanged = true;
            this.logger.debug('schema has been changed');
        }
        return {
            schemaChanged
        };
    }

    async fetchLocales() {
        const accessToken = this.accessToken;
        if (_.isEmpty(this.spaces) || !accessToken) {
            return Promise.resolve();
        }

        this.logger.debug('fetch locales for spaces');
        this.localesBySpaceId = await reducePromise(
            this.spaces,
            async (localesBySpaceIds: LocalesBySpaceId, space) => {
                const client = createPlainApiClient({
                    accessToken,
                    spaceId: space.spaceId,
                    environment: space.environment ?? 'master'
                });
                let locales: LocaleProps[];
                try {
                    locales = await fetchAllLocales(client);
                } catch (error: any) {
                    // The fetchAllLocales method uses Contentful's API client that handles errors and retries automatically.
                    // Consider adding retry mechanism to fetching everything again ONLY if we have identified cases were such retries would really help.
                    this.userLogger.error(`Failed fetching locales from Contentful, error: ${error.message}`);
                    return localesBySpaceIds;
                }

                // put the default locale first (for backward compatibility)
                const defaultLocaleIndex = locales.findIndex((locale) => locale.default);
                if (defaultLocaleIndex > -1) {
                    const defaultLocale = locales[defaultLocaleIndex]!;
                    locales.splice(defaultLocaleIndex, 1);
                    locales.unshift(defaultLocale);
                }

                localesBySpaceIds[space.spaceId] = locales;
                return localesBySpaceIds;
            },
            {}
        );
        this.defaultLocalesBySpaceId = _.reduce(
            this.localesBySpaceId,
            (defaultLocalesBySpaceId: Record<string, string>, locales, spaceId) => {
                const defaultLocale = locales.find((locale) => locale.default);
                if (!defaultLocale) {
                    return defaultLocalesBySpaceId;
                }
                defaultLocalesBySpaceId[spaceId] = defaultLocale.code;
                return defaultLocalesBySpaceId;
            },
            {}
        );
        this.logger.debug('successfully fetched all locales');
    }

    async fetchDataAndEncode() {
        const accessToken = this.accessToken;
        if (_.isEmpty(this.spaces) || !accessToken) {
            return;
        }
        this.logger.debug('fetchDataAndEncode');

        this.encodingResult = await reducePromise(
            this.spaces,
            async (encodingResult: EncodingResult | null, space) => {
                const environment = space.environment ?? 'master';
                const client = createPlainApiClient({
                    accessToken,
                    spaceId: space.spaceId,
                    environment: environment
                });
                let entries: EntryProps[];
                let assets: AssetProps[];
                try {
                    entries = await fetchAllEntries(client);
                    assets = await fetchAllAssets(client);
                } catch (error: any) {
                    // Stackbit won't be able to work properly even if one of the entries or the assets was not fetched.
                    // All fetch methods use Contentful's API client that handles errors and retries automatically.
                    // Consider adding retry mechanism to fetching everything again ONLY if we have identified cases were such retries would really help.
                    this.userLogger.error(`Failed fetching data from Contentful, error: ${error.message}`);
                    return null;
                }
                this.logger.debug(`fetched ${entries.length} entries and ${assets.length} assets from space ${space.spaceId} and environment ${environment}`);
                const delegate = this.getEncoderDelegateForSpaceId(space.spaceId);
                return encodeData({
                    data: [...entries, ...assets],
                    prevEncodingResult: encodingResult,
                    delegate: delegate,
                    encodeDelimiter: this.encodeDelimiter
                });
            },
            null
        );
    }

    async fetchUsers() {
        const accessToken = this.accessToken;
        if (_.isEmpty(this.spaces) || !accessToken) {
            return Promise.resolve();
        }

        this.logger.debug('fetch users for spaces');
        this.usersBySpaceId = await reducePromise(
            this.spaces,
            async (usersBySpaceIds: UsersBySpaceId, space) => {
                const client = createPlainApiClient({
                    accessToken,
                    spaceId: space.spaceId,
                    environment: space.environment ?? 'master'
                });
                let users: UserProps[];
                try {
                    users = await fetchAllUsers(client);
                } catch (error: any) {
                    this.userLogger.error(`Failed fetching users from Contentful, error: ${error.message}`);
                    return usersBySpaceIds;
                }

                usersBySpaceIds[space.spaceId] = users;
                return usersBySpaceIds;
            },
            {}
        );
        this.logger.debug('successfully fetched all users');
    }

    async postPull(updatedFiles: string[]) {
        this.logger.debug('postPull');

        const { updatedCodeFiles = [] as string[], updatedSchemaFiles = [] as string[] } = _.groupBy(updatedFiles, (filePath) => {
            const filePathRelativeToAppDir = path.relative(this.appDir, filePath);
            return isStackbitYamlFile(filePathRelativeToAppDir) ? 'updatedSchemaFiles' : 'updatedCodeFiles';
        });

        this.logger.debug(`found ${updatedSchemaFiles.length} updated code files`, { updatedSchemaFiles });
        const schemaFilesUpdated = updatedSchemaFiles.length > 0;
        if (schemaFilesUpdated) {
            await this.fetchSchema();
        }

        return {
            schemaChanged: schemaFilesUpdated,
            updatedCodeFiles
        };
    }

    keepAlive() {
        _.forEach(this.contentPollers, (contentPoller) => {
            contentPoller.resetSleepTimer();
        });
    }
}
