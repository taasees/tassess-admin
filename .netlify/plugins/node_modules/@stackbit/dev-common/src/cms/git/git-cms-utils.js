const path = require('path');
const _ = require('lodash');
const { getDefaultFieldsFromModel, generateNameId, interpolatePath, sanitizeSlug } = require('../../utils/cms-utils');

module.exports = {
    getFieldModelAtFieldPath,
    createObjectForReferenceField,
    createObject,
    fillObject,
    getListItemsFieldAndModelForNewListItem
};

function getFieldModelAtFieldPath({ object, fieldPath, model, modelsByName }) {
    if (_.isEmpty(fieldPath)) {
        return model;
    }

    const fieldName = _.head(fieldPath);
    const fieldPathTail = _.tail(fieldPath);

    const modelType = model.type;
    if (['object', 'page', 'data'].includes(modelType)) {
        return getFieldModelAtFieldPath({
            object: object[fieldName],
            fieldPath: fieldPathTail,
            model: _.find(model.fields, { name: fieldName }),
            modelsByName
        });
    } else if (modelType === 'model' || modelType === 'models') {
        // DEPRECATION NOTICE: modelType === 'models' is deprecated, can be removed after release of V2
        const modelName = _.get(object, '__metadata.srcModelName');
        const childModel = _.get(modelsByName, modelName);
        return getFieldModelAtFieldPath({
            object: object,
            fieldPath: fieldPath,
            model: childModel,
            modelsByName
        });
    } else if (modelType === 'reference') {
        // "reference" type can not appear in fieldPath
    } else if (modelType === 'list') {
        let itemModel;
        const item = object[fieldName];
        if (_.isArray(model.items)) {
            // in NetlifyCMS the type key is stored in 'model.typeKey', default is 'type'
            // in git-cms, the type key is always type
            const typeKey = _.get(model, 'typeKey', 'type');
            const objectType = _.get(item, typeKey);
            itemModel = _.find(model.items, { name: objectType });
        } else {
            itemModel = model.items;
        }
        return getFieldModelAtFieldPath({
            object: item,
            fieldPath: fieldPathTail,
            model: itemModel,
            modelsByName
        });
    }
}

function createObjectForReferenceField({ referenceField, values, modelName, schema }) {
    const { dirPath, fileExt } = referenceField;
    const model = _.get(schema, modelName);
    const fileName = generateNameId(modelName);
    // backward compatibility with older containers who send reference fields with fileExt and dirPath instead of the filePath on models
    const filePath = typeof fileExt !== 'undefined' ? path.join(dirPath, `{slug}.${fileExt}`) : model.filePath;
    const pageModel = {
        slugField: 'slug',
        filePath: filePath
    };
    return createObject(fileName, values, { model, pageModel, schema, parentField: referenceField });
}

function createObject(userSlug, object, { model, pageModel, schema, parentField }) {
    // slug can be 'some-page' but also might be '2020/some-page' where 2020 is a 'parent' folder
    let slug = sanitizeSlug(userSlug);
    if (slug.endsWith('/')) {
        slug += 'index';
    }
    const slugField = _.get(pageModel, 'slugField', 'slug');
    const filePathTemplate = _.get(pageModel, 'filePath');
    const instanceFields = fillObject({ cmsId: 'git', model, schema, parentField, values: object });
    if (_.has(instanceFields, slugField)) {
        instanceFields[slugField] = slug;
    }
    const context = Object.assign({}, instanceFields, { [slugField]: slug });
    const interpolatedFields = interpolateObjectFieldsWithContext(instanceFields, context);
    const filePath = interpolatePath(filePathTemplate, context);

    return {
        object: interpolatedFields,
        modelName: model.name,
        filePath
    };
}

function fillObject({ model, schema, parentField, cmsId, values }) {
    const defaultValue = getDefaultFieldsFromModel(model, schema, 2);
    // if parentField is of type 'model' (or 'models' to support backward compatibility with older stackbit.yaml version), add the 'type' field
    const addType = ['model', 'models'].includes(parentField?.type) && cmsId === 'git';
    // TODO: change 'type' to the value of objectTypeKey from stackbit.yaml, or move this logic to container
    const typeAttr = addType ? { type: model.name } : null;
    return typeof defaultValue === 'object'
        ? {
              ...typeAttr,
              ...defaultValue,
              ...values
          }
        : defaultValue;
}

function getListItemsFieldAndModelForNewListItem({ fieldModel, selectedModelName, schema }) {
    let itemModel = fieldModel.items;

    if (Array.isArray(itemModel)) {
        if (!selectedModelName) {
            throw new Error('Adding an item to array with multiple item types require passing selectedModelName');
        }
        itemModel = _.find(itemModel, (_itemModel) => {
            if (_itemModel.type === 'reference') {
                return _.includes(_itemModel.models, selectedModelName);
            }
            // DEPRECATION NOTICE: itemModel.type === 'models' is deprecated and can be removed after release of V2
            if (_itemModel.type === 'models') {
                return _.includes(_itemModel.models, selectedModelName);
            }
            if (_itemModel.type === 'model') {
                // DEPRECATION NOTICE: itemModel.model of itemModel.type === 'model' is deprecated and can be removed after release of V2
                return _itemModel.model ? _itemModel.model === selectedModelName : _.includes(_itemModel.models, selectedModelName);
            }
            if (_itemModel.type === 'object') {
                return _itemModel.name === selectedModelName;
            }
        });
        if (!itemModel) {
            throw new Error(`Could not resolve model for new list item for selectedModelName ${selectedModelName}`);
        }
    }

    const itemType = itemModel.type;

    if (itemType === 'reference') {
        const modelName = selectedModelName || _.get(itemModel, 'models.0');
        return {
            listItemsField: itemModel,
            model: schema[modelName]
        };
    } else if (itemType === 'models') {
        // DEPRECATION NOTICE: itemType === 'models' is deprecated and can be removed after release of V2
        const modelName = selectedModelName || _.get(itemModel, 'models.0');
        return {
            listItemsField: itemModel,
            model: schema[modelName]
        };
    } else if (itemType === 'model') {
        let model;
        // DEPRECATION NOTICE: itemModel.model of itemType === 'model' is deprecated, can be removed after release of V2
        if (itemModel.model) {
            model = schema[itemModel.model];
        } else {
            const modelName = selectedModelName || _.get(itemModel, 'models.0');
            model = schema[modelName];
        }
        return {
            listItemsField: itemModel,
            model: model
        };
    } else if (itemType === 'object') {
        return {
            listItemsField: itemModel,
            model: itemModel
        };
    } else {
        return {
            listItemsField: itemModel,
            model: itemModel
        };
    }
}

/**
 * Old projects like perimeterX have tokens (e.g.: %slug%) encoded right into the pageModels.fields
 * This function replaces these tokens with user provided param
 */
function interpolateObjectFieldsWithContext(field, context) {
    if (typeof field === 'string') {
        return field.replace(/%(.*?)%/g, (match, p) => _.get(context, p));
    } else if (Array.isArray(field)) {
        return field.map((value) => interpolateObjectFieldsWithContext(value, context));
    } else if (_.isObject(field)) {
        return _.mapValues(field, (value) => interpolateObjectFieldsWithContext(value, context));
    } else {
        return field;
    }
}
