const fse = require('fs-extra');
const path = require('path');
const yaml = require('js-yaml');
const _ = require('lodash');
const gitUrlParse = require('git-url-parse');

const cmsCore = require('@stackbit/cms-core');
const cmsGit = require('@stackbit/cms-git').default;
const { iterateObjectFieldsWithModelRecursively, isStackbitYamlFile } = require('@stackbit/sdk');

const socketService = require('../../services/socket-service');
const { pathDifferences, interpolatePageUrlFromFilePath, deepMap } = require('../../utils/code-utils');
const { PageAlreadyExistsError, PageSlugInvalidError } = require('../../services/response-errors');
const { convertValueToType, generateNameId, getObjectReferenceType, getObjectReferenceId, objectOmitInternalKeys } = require('../../utils/cms-utils');
const gitCmsUtils = require('./git-cms-utils');
const { GitBasedAssetsManager } = require('./git-based-assets-manager');
const { handleSchemaAssets } = require('../../utils/schema-assets-manager');
const { getRemoteAssetUrl } = require('../../utils/integration-utils');

module.exports = class Git {
    constructor(options) {
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.debug('initialize');

        this.originalSchema = null;
        this.schema = null;
        this.data = null;
        this.encoderDelegate = null;
        this.encodingResult = null;
        this.schemaLoadingErrors = null;
        this.contentLoadingErrors = null;

        this.ssgType = options.ssgType;
        this.appDir = options.appDir;
        this.rootDir = options.rootDir;
        this.repoDir = options.repoDir;

        this.repoBranch = options.repoBranch || 'preview';
        this.repoPublishBranch = options.repoPublishBranch || 'master';

        if (options.repoUrl) {
            // remove user/pass from url before passing to gitUrlParse
            const repoUrl = options.repoUrl.replace(/\/\/.*?:.*?@/, '//');
            const gitUrlResult = gitUrlParse(repoUrl);
            this.projectId = gitUrlResult.full_name;
            let path = '';
            if (gitUrlResult.resource === 'github.com') {
                path = `/blob/${this.repoBranch}`;
            } else if (gitUrlResult.resource === 'gitlab.com') {
                path = `/-/tree/${this.repoBranch}`;
            } else if (gitUrlResult.resource === 'bitbucket.org') {
                path = `/src/${this.repoBranch}`;
            }
            this.projectUrl = 'https://' + gitUrlResult.resource + '/' + gitUrlResult.full_name + path;
        } else {
            this.projectId = 'git_project';
            this.projectUrl = null;
        }

        this.stackbitConfig = options.stackbitConfig;
        this.contentDirs = _.get(options, 'contentDirs');
        this.encodeDelimiter = _.get(options, 'encodeDelimiter');
        this.beforeContentUpdate = _.get(options, 'beforeContentUpdate', () => {});
        this.onContentUpdate = _.get(options, 'onContentUpdate', () => {});
        this.commitAndPushChanges = options.commitAndPushChanges;

        this.assetIdPrefix = options.assetIdPrefix;
        this.staticAssetsFilePath = options.staticAssetsFilePath;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.defaultContentTypeExtensions = options.defaultContentTypeExtensions;

        this.gitWorker = options.workers.gitApp;
    }

    debug(message, data) {
        this.logger.debug(`[${this.constructor.name}] ${message}`, data);
    }

    error(message, data) {
        this.logger.error(`[${this.constructor.name}] ${message}`, data);
    }

    async run() {
        this.debug('run');
        await this.fetchSchemaAndReport();
        await this.fetchDataAndUpdate();
    }

    async restart() {
        this.debug('restart');
        await this.fetchSchemaAndReport();
        await this.fetchDataAndUpdate();
    }

    getEncodingResult() {
        return this.encodingResult;
    }

    getSchemaKey() {
        return 'git';
    }

    getEnvironmentForProjectId(projectId) {
        // there is only one project in git-based CMS
        return this.repoBranch || 'preview';
    }

    getModelsForProjectId(projectId) {
        // there is only one project in git-based CMS
        return _.get(this.schema, 'models');
    }

    getMappedModels() {
        const models = _.map(this.schema.models, (model) => {
            if (['config'].includes(model.type)) {
                model = _.assign({}, model, { type: 'data' });
            }
            return model;
        });
        const modelsByName = _.keyBy(models, 'name');
        return {
            [this.projectId]: modelsByName
        };
    }

    getPresets() {
        return _.get(this.schema, 'presets');
    }

    getCmsContentHandler() {
        return cmsGit;
    }

    async fetchSchema() {
        this.debug('fetchSchema');
        try {
            const { schema, errors } = await cmsCore.stackbit.fetchAndConvertSchema({ dirPath: this.stackbitConfig?.dirPath ?? this.repoDir });
            this.schema = schema;
            this.schemaLoadingErrors = errors;
            _.forEach(errors, (error) => {
                this.userLogger.warn(error.message);
            });
        } catch (err) {
            //TODO using STACKBIT_YAML is deprecated
            if (process.env.STACKBIT_YAML) {
                this.schema = yaml.safeLoad(process.env.STACKBIT_YAML, { schema: yaml.JSON_SCHEMA });
                this.debug('loaded stackbit.yaml from STACKBIT_YAML');
            } else {
                this.schema = {};
            }
        }
        this.originalSchema = this.schema;
        this.debug(`loaded schema, stackbitVersion: ${this.schema.stackbitVersion}`);

        this.assetsManager = new GitBasedAssetsManager({
            rootDir: this.rootDir,
            appDir: this.appDir,
            writer: this.writer,
            assetIdPrefix: this.assetIdPrefix,
            staticAssetsFilePath: this.staticAssetsFilePath,
            staticAssetsPublicPath: this.staticAssetsPublicPath
        });

        if (_.has(this.schema, 'assets')) {
            const assets = _.get(this.schema, 'assets');
            this.assetsManager.assetsDir = _.get(assets, 'assetsDir');
            this.assetsManager.staticDir = _.get(assets, 'staticDir', _.get(assets, 'assetsDir')); // assetsDir as staticDir for backward compatibility
            this.assetsManager.uploadDir = _.get(assets, 'uploadDir', '');
            this.assetsManager.publicPath = _.get(assets, 'publicPath', null);
            this.assetsManager.referenceType = _.get(assets, 'referenceType', 'static');
            this.debug('stackbit.yaml has assets', { assets });
        } else if (!_.isNil(this.schema.staticDir) && !_.isNil(this.schema.uploadDir)) {
            this.debug('stackbit.yaml has staticDir and uploadDir', { staticDir: this.schema.staticDir, uploadDir: this.schema.uploadDir });
            this.assetsManager.staticDir = path.join(this.schema.staticDir, this.schema.uploadDir);
            this.assetsManager.publicPath = this.schema.uploadDir;
        } else {
            this.assetsManager = null;
        }

        if (!this.assetsManager || (_.isNil(this.assetsManager.staticDir) && _.isNil(this.assetsManager.assetsDir))) {
            this.assetsManager = null;
        } else {
            await this.assetsManager.copyAssets();
        }

        const { models, presets } = await handleSchemaAssets({
            models: this.schema.models,
            presets: this.schema.presets,
            rootDir: this.rootDir,
            stackbitYamlDir: this.stackbitConfig?.dirPath ?? this.repoDir,
            logger: this.logger,
            userLogger: this.userLogger,
            staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
            staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath
        });
        this.schema = {
            ...this.schema,
            models,
            presets
        };
    }

    async fetchSchemaAndReport() {
        const prevSchema = this.schema;

        await this.fetchSchema();

        if (!this.assetsManager) {
            //TODO
            // if (_.isEmpty(this.schema)) {
            //     userLogger.warn('Image and asset handling unavailable. Define a stackbit.yaml to enable it.');
            // } else {
            //     userLogger.warn('Image and asset handling unavailable. Check "assets" configuration in stackbit.yaml. See https://www.stackbit.com/docs/stackbit-yaml/assets/ for more details.');
            // }
        }

        if (!_.isUndefined(prevSchema) && !_.isEqual(prevSchema, this.schema)) {
            socketService.notifySchemaChange();
        }
    }

    async fetchDataAndUpdate() {
        this.debug('fetchDataAndUpdate');
        this.data = await this.loadData();
        // encodeData needs to be executed in all versions if we do not use the encodedData response, because it generates a side-effect encodingResult which is used by fields response.
        this.encodeData(this.data, true);
    }

    async loadData() {
        this.debug('loadData');
        const { data, errors } = await this.getCmsContentHandler().loadContent({
            dirPath: this.appDir,
            schema: this.originalSchema || {}
        });
        this.contentLoadingErrors = errors;
        this.debug(`loaded ${_.size(data)} items`);
        const result = data;
        _.forEach(this.contentLoadingErrors, (error) => {
            this.userLogger.warn(error);
        });
        const encoderDelegateClass = this.getCmsContentHandler().EncoderDelegate;
        this.encoderDelegate = new encoderDelegateClass({
            schema: this.schema,
            projectId: this.projectId,
            projectUrl: this.projectUrl,
            branch: this.getEnvironmentForProjectId(this.projectId),
            noEncodeFields: _.compact(this.stackbitConfig?.noEncodeFields),
            omitFields: _.compact(_.union(this.stackbitConfig?.omitFields, [_.get(this.schema, 'pageLayoutKey')])),
            encodedFieldTypes: this.stackbitConfig?.encodedFieldTypes,
            staticAssetsPublicPath: this.staticAssetsPublicPath
        });
        return result;
    }

    async writeData(data, dir) {
        this.debug('writeData', { dir });
        return this.getCmsContentHandler().saveContent({
            dirPath: dir,
            data: data
        });
    }

    async deleteFile(path) {
        this.debug('deleteFile', { path });

        return fse.unlink(path);
    }

    encodeData(data, initial = false) {
        this.debug('encodeData, initial: ' + initial);
        data = _.castArray(data);
        this.encodingResult = cmsCore.encodeData({
            data: data,
            delegate: this.encoderDelegate,
            prevEncodingResult: initial ? null : this.encodingResult,
            encodeDelimiter: this.encodeDelimiter
        });
        return this.encodingResult.encodedData;
    }

    prepareObjectValues(object) {
        return deepMap(
            object,
            (value) => {
                const refId = getObjectReferenceId(value);
                if (refId) {
                    return refId;
                }
                const createType = getObjectReferenceType(value);
                if (createType) {
                    return {
                        ...objectOmitInternalKeys(_.omitBy(value, _.isNil)),
                        type: createType
                    };
                }
                return value;
            },
            { iteratePrimitives: false }
        );
    }

    async createObject({ modelName, fields, pageModel, object, filePath, user }) {
        this.debug('createObject', { modelName });
        const models = this.getMappedModels();
        const model = this.getModelByModelName(modelName);

        let isProcessedObject = false;

        if (pageModel && !filePath) {
            const userSlugFieldName = pageModel.slugField || '_stackbit_slug';
            const userSlug = _.get(fields, userSlugFieldName);
            const otherFields = this.prepareObjectValues(_.omit(fields, userSlugFieldName));
            isProcessedObject = true;
            const slug = userSlug || generateNameId(modelName);
            const schema = models[this.projectId];
            const result = gitCmsUtils.createObject(slug, otherFields, { model, pageModel, schema, cmsId: 'git' });
            filePath = result.filePath;
            object = result.object;
        }

        let existingObject = this.getObject(filePath);
        if (!existingObject) {
            // try to find possible duplicates, like test/index.md && test.md - which are different files, but in most ssg makes same url `test/`
            const extName = path.extname(filePath);
            const baseName = path.basename(filePath, extName);
            const filePathBaseParts = filePath.split('/').slice(0, -1);
            let duplicateName;
            if (['index', '_index'].includes(baseName)) {
                // test/index.md -> test.md
                duplicateName = filePathBaseParts.join('/') + extName;
            } else {
                // test.md -> test/index.md
                duplicateName = filePathBaseParts.concat([baseName, `index${extName}`]).join('/');
            }
            existingObject = this.getObject(duplicateName);
        }

        if (existingObject) {
            return Promise.reject(new PageAlreadyExistsError(filePath));
        }

        const extname = path.extname(filePath);
        if (!extname) {
            return Promise.reject(new PageSlugInvalidError());
        }

        let newObject = isProcessedObject ? object : this.prepareObjectValues(object);
        newObject = this.addMetadata(newObject, model, filePath);
        newObject = this.updateAssetLinks(newObject);

        const additionalData = typeof this.willCreateObject === 'function' ? this.willCreateObject({ filePath, model }) : {};

        this.data.push(newObject);

        const changeLog = [{ filePath, description: 'added' }, additionalData.changeLog].filter(Boolean);

        return this.encodeWriteAndCommitObject(newObject, changeLog, user, additionalData.writeData);
    }

    async duplicateObject({ pageId, srcProjectId, fields, pageModel }) {
        const userSlugFieldName = pageModel.slugField || '_stackbit_slug';
        const userSlug = _.get(fields, userSlugFieldName);
        const otherFields = _.omit(fields, userSlugFieldName);

        if (!userSlug) {
            throw new Error('Slug field not defined');
        }

        const object = this.getObject(pageId, srcProjectId);
        if (!object) {
            throw new Error('Object not found');
        }

        const modelName = pageModel.modelName;
        const model = this.getModelByModelName(modelName);
        const models = this.getMappedModels();
        const schema = models[this.projectId];
        const data = gitCmsUtils.createObject(userSlug, { ...object, ...otherFields, ...pageModel.fields }, { model, pageModel, schema, cmsId: 'git' });
        return this.createObject({ pageModel, ...data });
    }

    async deleteObject(objectId, user) {
        this.debug('deleteObject', { objectId, user });

        const index = this.getObjectIndex(objectId);

        if (index === -1) {
            throw new Error('Object not found');
        }

        const object = this.data[index];
        const modelName = _.get(object, '__metadata.srcModelName');
        const model = this.getModelByModelName(modelName);

        const errors = {};
        const modelsByName = _.keyBy(this.schema.models, 'name');
        for (const dataObject of this.data) {
            const dataObjectModelName = _.get(dataObject, '__metadata.srcModelName');
            const model = this.getModelByModelName(dataObjectModelName);
            const dataObjectId = _.get(dataObject, '__metadata.srcObjectId');
            iterateObjectFieldsWithModelRecursively(dataObject, model, modelsByName, (data) => {
                if ((_.get(data, 'field.type') === 'reference' || _.get(data, 'fieldListItem.type') === 'reference') && data.value === objectId) {
                    errors.validations = errors.validations || [];
                    errors.validations.push({
                        type: 'existsAsReference',
                        objectId: dataObjectId
                    });
                }
            });
        }

        if (!_.isEmpty(errors)) {
            return { errors };
        }

        this.data.splice(index, 1);

        const additionalData = typeof this.willDeleteObject === 'function' ? this.willDeleteObject({ model, object, objectId }) : {};
        const changeLog = [{ filePath: objectId, description: 'removed' }, additionalData.changeLog].filter(Boolean);

        return this.encodeDeleteAndCommitObject([objectId], changeLog, user, additionalData.writeData);
    }

    getUpdateMessage(object, newObject) {
        const diffLine = (diff) => {
            let result = 'updated';
            const path = _.filter(diff.split('.'), (part) => isNaN(part)); // skip array indexes
            const [field = null, parent = null] = _.take(_.reverse(path), 2);
            if (field) {
                result += ' ' + field;
            }
            if (parent) {
                result += ' in ' + parent;
            }
            return result;
        };
        const differences = pathDifferences(object, newObject);
        if (differences && differences.length === 1) {
            return diffLine(differences[0]);
        } else if (differences && differences.length > 1) {
            return 'Multiple updates:\n' + _.map(differences, (diff) => '* ' + diffLine(diff)).join('\n');
        }
        return 'updated';
    }

    encodeWriteAndCommitObject(object, changeLog, user, writeAdditionalData) {
        this.debug('encodeWriteAndCommitObject');
        return this.gitWorker.schedule(() => {
            this.debug('beforeContentUpdate');
            this.beforeContentUpdate();
            this.debug('encodeData');
            this.encodeData([object]);
            this.debug('writeData');
            return Promise.all([this.writeData([object], this.appDir), writeAdditionalData ? writeAdditionalData() : null])
                .then(([didUpdatePreviewContentFiles, didUpdateIMContentFiles]) => {
                    this.debug('onContentUpdate');
                    this.onContentUpdate({
                        updatedContentFiles: [_.get(object, '__metadata.srcObjectId')],
                        didUpdatePreviewContentFiles,
                        didUpdateIMContentFiles
                    });
                    return this.commitAndPushChanges?.(changeLog, user);
                })
                .then(() => {
                    return {
                        id: _.get(object, '__metadata.srcObjectId'),
                        srcProjectId: this.projectId,
                        srcEnvironment: this.repoBranch
                    };
                })
                .then((result) => {
                    socketService.notifyObjectsChanged({
                        changedObjects: [
                            {
                                srcObjectId: result.id,
                                srcType: 'git',
                                srcProjectId: result.srcProjectId
                            }
                        ]
                    });
                    return result;
                });
        });
    }

    encodeDeleteAndCommitObject(deletedFiles, changeLog, user, writeAdditionalData) {
        const data = _.cloneDeep(this.data);

        return this.gitWorker.schedule(() => {
            this.beforeContentUpdate();
            this.encodeData(data, true);

            const filePaths = deletedFiles.reduce((filePaths, filePath) => {
                const appFile = path.join(this.appDir, filePath);
                return _.compact([...filePaths, appFile]);
            }, []);
            const ops = [...filePaths.map((filePath) => this.deleteFile(filePath)), writeAdditionalData ? writeAdditionalData() : null];

            return Promise.all(ops)
                .then(() => {
                    this.onContentUpdate({
                        didUpdatePreviewContentFiles: true,
                        didUpdateIMContentFiles: true
                    });
                    return this.commitAndPushChanges?.(changeLog, user);
                })
                .then(() => {
                    socketService.notifyObjectsChanged({
                        changedObjects: deletedFiles.map((objectId) => ({
                            srcObjectId: objectId,
                            srcType: 'git',
                            srcProjectId: this.projectId
                        }))
                    });
                });
        });
    }

    /**
     * This method is called after pulling appDir.
     *
     * If updatedFiles include code files that are not schema neither content files, copy them to IM
     * If updatedFiles include schema files, re-fetch the schema
     * If updatedFiles include content files, reload all data, encode, and save it to IM
     *
     * @param {Array<string>} updatedFiles Array of changed file paths relative to appDir
     */
    async postPull(updatedFiles) {
        this.debug('post pull', { updatedFiles });

        if (!updatedFiles.length) {
            this.debug('no changes');
            return {};
        }

        const contentFiles = _.map(this.data, _.property('__metadata.srcObjectId'));

        const {
            updatedCodeFiles = [],
            updatedContentFiles = [],
            updatedSchemaFiles = []
        } = _.groupBy(updatedFiles, (filePath) => {
            const filePathRelativeToAppDir = path.relative(this.appDir, filePath);
            if (this.isSchemaFile(filePathRelativeToAppDir)) {
                return 'updatedSchemaFiles';
            }
            return _.includes(contentFiles, filePathRelativeToAppDir) ? 'updatedContentFiles' : 'updatedCodeFiles';
        });

        const promises = [];

        this.debug(`found ${updatedSchemaFiles.length} updated schema files`, { updatedSchemaFiles });
        const didSchemaFilesUpdate = !_.isEmpty(updatedSchemaFiles);
        const refetchSchema = _.isEmpty(this.schema) || didSchemaFilesUpdate;
        if (refetchSchema) {
            promises.push(this.fetchSchema());
        }

        await Promise.all(promises);

        // consider code files with certain extensions as potential content files for purposes of updating all data
        const updatedPotentialContentFiles = updatedCodeFiles.filter((filePath) => {
            const ext = path.extname(filePath).substring(1);
            return this.defaultContentTypeExtensions.includes(ext);
        });

        // if content files or schema files were updated, reload the data and re-encode it with the new schema
        this.debug(`found ${updatedContentFiles.length} updated content files`, { updatedContentFiles, updatedPotentialContentFiles });
        if (updatedContentFiles.length || updatedSchemaFiles.length || updatedPotentialContentFiles.length) {
            this.beforeContentUpdate();
            await this.fetchDataAndUpdate();
            this.onContentUpdate({
                didUpdatePreviewContentFiles: updatedContentFiles.length > 0,
                didUpdateIMContentFiles: false
            });
            if (!_.isEmpty(updatedContentFiles)) {
                socketService.notifyObjectsChanged({
                    changedObjects: updatedContentFiles.map((filePath) => {
                        return {
                            srcObjectId: path.relative(this.appDir, filePath),
                            srcProjectId: this.projectId,
                            srcType: 'git'
                        };
                    })
                });
            }
        }

        return {
            schemaChanged: didSchemaFilesUpdate,
            updatedCodeFiles
        };
    }

    /**
     * Interface method. Called after site was pulled.
     * Override and return true if the filePath is responsible for site schema.
     * Returning true will re-fetch the schema.
     *
     * @param {string} filePath File path relative to appDir
     * @return {boolean}
     */
    isSchemaFile(filePath) {
        return isStackbitYamlFile(filePath);
    }

    isAssetFile(filePath) {
        if (!this.schema) {
            return false;
        }

        const assetsDir = _.get(this.schema, 'assets.assetsDir');
        const pathObject = path.parse(filePath);
        return pathObject.dir.startsWith(assetsDir);
    }

    addMetadata(object, model, filePath, existingObject) {
        const result = cmsGit.addMetadata(object, model, {
            filePath: filePath,
            modelsByName: _.keyBy(this.schema.models, 'name')
        });
        const existingMetadata = _.get(existingObject, '__metadata');
        if (existingMetadata) {
            result.data['__metadata'] = _.merge(existingMetadata, result.data['__metadata']);
        }
        return result.data;
    }

    updateAssetLinks(object) {
        if (!this.assetsManager) {
            return object;
        }
        const objectId = _.get(object, '__metadata.srcObjectId');
        return deepMap(object, (value) => {
            if (_.isString(value)) {
                return this.assetsManager.replaceAssetLinks(value, objectId);
            }
            return value;
        });
    }

    getLocalizedFieldData() {
        return _.get(this.encodingResult, 'fieldData', null);
    }

    getObject(objectId, projectId) {
        return _.find(this.data, _.matchesProperty('__metadata.srcObjectId', objectId));
    }

    getObjectIndex(objectId, projectId) {
        return _.findIndex(this.data, _.matchesProperty('__metadata.srcObjectId', objectId));
    }

    getModelByModelName(modelName) {
        return _.find(this.schema.models, { name: modelName });
    }

    listAssets(filter) {
        if (!this.assetsManager) {
            throw new Error('Assets Unavailable');
        }
        return this.assetsManager.list(filter);
    }

    async uploadAsset({ url, fileName, data, user }) {
        if (!this.assetsManager) {
            throw new Error('Assets Unavailable');
        }

        const asset = await this.assetsManager.upload(url, fileName, data, user);
        const relFilePath = this.assetsManager.getAssetFilePath(asset.objectId);
        const filePath = path.join(this.appDir, relFilePath);

        const changes = [
            {
                filePath,
                description: 'added'
            }
        ];

        await this.gitWorker.schedule(() => {
            return this.commitAndPushChanges?.(changes, user);
        });

        return asset;
    }

    uploadAssets(assets, user) {
        return Promise.all(
            assets.map((uploadAsset) =>
                this.uploadAsset({
                    fileName: _.get(uploadAsset, 'metadata.name'),
                    url: uploadAsset.url,
                    data: uploadAsset.data,
                    user
                })
            )
        );
    }

    getPageUrlFromObjectId(objectId, pageModel, pagesDir) {
        const pageObject = this.getObject(objectId);
        if (!pageObject) {
            throw new Error(`Can't get page url, object with given objectId not found: ${objectId}`);
        }
        const pageData = _.omit(pageObject, '__metadata');
        return interpolatePageUrlFromFilePath({
            pageFilePath: objectId,
            pageModel,
            pageData,
            pagesDir
        });
    }

    async updateSingleObject(object, newObject, user) {
        this.debug('updateSingleObject');
        const description = this.getUpdateMessage(object, newObject);
        const objectId = _.get(object, '__metadata.srcObjectId');
        const modelName = _.get(object, '__metadata.srcModelName');
        const index = this.getObjectIndex(objectId);
        const model = this.getModelByModelName(modelName);

        newObject = this.addMetadata(newObject, model, objectId, this.data[index]);
        newObject = this.updateAssetLinks(newObject);
        newObject = this.prepareObjectValues(newObject);

        this.data[index] = newObject;

        const files = [
            {
                filePath: objectId,
                description
            }
        ];

        return this.encodeWriteAndCommitObject(newObject, files, user);
    }

    async updateObject(changedFields, user) {
        const models = this.getMappedModels();
        const fieldsByEntity = _.groupBy(changedFields, 'srcObjectId');
        return Promise.all(
            Object.keys(fieldsByEntity).map(async (srcObjectId) => {
                const fields = fieldsByEntity[srcObjectId];
                const { srcProjectId } = fields[0];
                const schema = models[srcProjectId];
                const existingObject = this.getObject(srcObjectId, srcProjectId);
                let object = _.cloneDeep(existingObject);
                for (const field of fields) {
                    object = await this.modifyItem({ object, field, schema });
                }
                try {
                    this.debug('updateObject', { user });
                    await this.updateSingleObject(existingObject, object, user);
                    return object;
                } catch (err) {
                    console.log(err);
                    this.error('Error updating object');
                }
            })
        );
    }

    async updateObject_api(objectId, projectId, object, user) {
        const existingObject = await this.getObject(objectId, projectId);
        if (!existingObject) {
            throw new Error('Object not found');
        }
        return this.updateSingleObject(existingObject, object, user);
    }

    modifyItem({ object, field, schema }) {
        const { order, add, remove, value, fieldPath, linkAsset, uploadAsset, setObject } = field;
        const fieldModel = gitCmsUtils.getFieldModelAtFieldPath({
            object,
            model: schema[object.__metadata.srcModelName],
            modelsByName: schema,
            fieldPath: fieldPath
        });

        if (order || add || (remove && fieldModel.type === 'list')) {
            return this.modifyList({ object, fieldModel, fieldPath, field, schema });
        } else if (remove) {
            _.unset(object, fieldPath);
        } else if (linkAsset) {
            if (linkAsset.id) {
                _.set(object, fieldPath, linkAsset.id);
            } else if (linkAsset.source) {
                if (fieldModel.source === linkAsset.source) {
                    // if explicit source provided in the field model - store entire object as for the image
                    _.set(object, fieldPath, linkAsset.asset);
                } else {
                    const assetUrl = getRemoteAssetUrl(linkAsset);
                    _.set(object, fieldPath, assetUrl);
                }
            } else {
                _.unset(object, fieldPath);
            }
        } else if (uploadAsset && uploadAsset.url) {
            return this.uploadAsset({
                url: uploadAsset.url,
                fileName: uploadAsset.metadata.name
            }).then((response) => {
                const newField = _.omit(field, ['uploadAsset']);
                newField.linkAsset = { id: response.objectId };
                return this.modifyItem({
                    object,
                    field: newField,
                    schema
                });
            });
        } else if (setObject) {
            const { values } = setObject;
            const { selectedObjectId, selectedModelName } = setObject;
            if (fieldModel.type === 'reference') {
                let objectPromise;
                if (selectedObjectId) {
                    objectPromise = Promise.resolve({ id: selectedObjectId });
                } else {
                    const data = gitCmsUtils.createObjectForReferenceField({
                        referenceField: fieldModel,
                        modelName: selectedModelName,
                        schema: schema,
                        cmsId: 'git',
                        values
                    });
                    objectPromise = this.createObject(data);
                }
                return objectPromise
                    .then((selectedObject) => {
                        _.set(object, fieldPath, selectedObject.id);
                        return object;
                    })
                    .catch((err) => {
                        this.error('GitBased: Failed to create an object', {
                            error: err.toString(),
                            stack: err.stack
                        });
                        throw err;
                    });
            } else if (fieldModel.type === 'object') {
                const newObj = gitCmsUtils.fillObject({
                    parentField: fieldModel,
                    model: fieldModel,
                    schema,
                    cmsId: 'git',
                    values
                });
                _.set(object, fieldPath, newObj);
            } else if (['model', 'models'].includes(fieldModel.type)) {
                let model = fieldModel;
                if (selectedModelName) {
                    model = schema[selectedModelName];
                } else {
                    // This should not happen, client should always send `selectedModelName` for field of type `model`
                    // But in case it didn't, maybe because there is only one model, then pick the first one.
                    // check 'model' for backward compatibility with old projects
                    const modelName = _.head(_.get(fieldModel, 'models')) || _.get(fieldModel, 'model');
                    model = schema[modelName];
                }
                const newObj = gitCmsUtils.fillObject({
                    parentField: fieldModel,
                    model,
                    schema,
                    cmsId: 'git',
                    values
                });
                _.set(object, fieldPath, newObj);
            } else {
                // This should never happen, because 'setObject' can either be for `reference`, `object` or `model` field.
                return Promise.reject(new Error('Illegal call setObject'));
            }
        } else if (_.isNil(value) || value === '') {
            _.unset(object, fieldPath);
        } else {
            const adjustedValue = convertValueToType(value, fieldModel.type);
            _.set(object, fieldPath, adjustedValue);
        }

        return Promise.resolve(object);
    }

    modifyList({ object, fieldModel, fieldPath, field, schema }) {
        const { order, add, remove } = field;
        if (!_.has(object, fieldPath)) {
            _.set(object, fieldPath, []);
        }
        const arr = _.get(object, fieldPath);
        if (order) {
            const entryArr = arr.slice();
            const newEntryArr = order.map((newIndex) => entryArr[newIndex]);
            _.set(object, fieldPath, newEntryArr);
            return Promise.resolve(object);
        } else if (add) {
            const { selectedModelName, selectedObjectId, values, position = arr.length } = field.add;
            const processedValues = this.prepareObjectValues(values);
            if (selectedObjectId) {
                arr.splice(position, 0, selectedObjectId);
                return Promise.resolve(object);
            } else {
                const { model, listItemsField } = gitCmsUtils.getListItemsFieldAndModelForNewListItem({ fieldModel, selectedModelName, schema });
                if (listItemsField.type === 'reference') {
                    const data = gitCmsUtils.createObjectForReferenceField({
                        referenceField: listItemsField,
                        modelName: selectedModelName,
                        schema,
                        values: processedValues
                    });
                    return this.createObject(data).then((newObject) => {
                        arr.splice(position, 0, newObject.id);
                        return object;
                    });
                } else if (listItemsField.type === 'image') {
                    // if image inserted as link it's passed via objectId
                    // here image wanted to be inserted in full (e.g. entire cloudinary object)
                    // so we need to verify sources are correct
                    if (values?.source === fieldModel.items.source) {
                        arr.splice(position, 0, values.asset);
                        return Promise.resolve(object);
                    } else {
                        return Promise.reject(new Error('Add image with wrong source'));
                    }
                } else {
                    const value = gitCmsUtils.fillObject({ parentField: listItemsField, model, schema, values: processedValues, cmsId: 'git' });
                    arr.splice(position, 0, value);
                    return Promise.resolve(object);
                }
            }
        } else if (remove) {
            const { index } = remove;
            if (typeof index === 'number') {
                arr.splice(index, 1);
            }
            _.set(object, fieldPath, arr);
            return Promise.resolve(object);
        }
    }
};
