/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Config, Model, ImageModel, Preset } from '@stackbit/sdk';
import { Logger, UserCommandSpawner, SiteMapEntry, DistributiveOmit, AssetSource, ScheduledActionActionType, ScheduledActionWithSource, TreeViewNode, DocumentSpecifier } from '@stackbit/types';
import * as StackbitTypes from '@stackbit/types';
import { ContentStore, ContentStoreTypes, GitService } from '@stackbit/cms-core';
import { ContentStoreMeta } from '../types';
import { Worker } from '@stackbit/utils';
import { PresetParams } from '../services/presets-service';
export interface CommitFile {
    filePath: string;
    description: string;
}
export interface CommitAuthor {
    email: string;
    name?: string;
}
export type CommitAndPushChanges = (files: CommitFile[], author: CommitAuthor) => Promise<void>;
export interface ContentStoreAdapterOptions {
    cmsType: string;
    csiEnabled?: boolean;
    webhookUrl?: string;
    contentfulAccessToken?: string;
    contentfulSpaces?: {
        spaceId: string;
        previewToken: string;
        environment?: string;
    }[];
    sanityProject?: {
        projectId: string;
        token: string;
        studioPath: string;
        dataset: string;
        projectUrl: string;
    };
    sanityQuery?: string;
    workers: {
        gitApp: Worker;
    };
    rootDir: string;
    projectDir: string;
    appDir: string;
    repoUrl?: string;
    repoBranch?: string;
    repoPublishBranch?: string;
    runEnv?: NodeJS.ProcessEnv;
    runUid?: number;
    logger: Logger;
    userLogger: Logger;
    userCommandSpawner?: UserCommandSpawner;
    localDev: boolean;
    skipPush?: boolean;
    assetIdPrefix: string;
    staticAssetsFilePath: string;
    staticAssetsPublicPath: string;
    staticThemeAssetsFilePath: string;
    staticThemeAssetsPublicPath: string;
    defaultContentTypeExtensions: string[];
    commitAndPushChanges?: CommitAndPushChanges;
    devAppRestartNeeded?: () => void;
}
export declare class ContentStoreAdapter {
    private cmsType;
    private csiEnabled;
    private webhookUrl?;
    private stackbitConfig;
    private workers;
    private rootDir;
    private projectDir;
    private appDir;
    private repoUrl?;
    private repoBranch?;
    private repoPublishBranch?;
    private runEnv?;
    private runUid?;
    private logger;
    private userLogger;
    private localDev;
    private skipPush?;
    private userCommandSpawner?;
    private assetIdPrefix;
    private staticAssetsFilePath;
    private staticAssetsPublicPath;
    private staticThemeAssetsFilePath;
    private staticThemeAssetsPublicPath;
    private defaultContentTypeExtensions;
    private commitAndPushChanges?;
    private readonly devAppRestartNeeded?;
    private gitService;
    private contentfulAccessToken?;
    private contentfulSpaces?;
    private sanityProject?;
    private sanityQuery?;
    private cms?;
    private contentStore?;
    constructor(options: ContentStoreAdapterOptions);
    init({ stackbitConfig }: {
        stackbitConfig: Config | null;
    }): Promise<void>;
    destroy(): Promise<void>;
    isContentStoreEnabled(): boolean;
    getGitService(): GitService;
    onStackbitConfigChange({ stackbitConfig }: {
        stackbitConfig: Config | null;
    }): Promise<void>;
    private extendStackbitConfigWithContentSources;
    private createCms;
    keepAlive(): Promise<void>;
    handleFileChanges(filePaths: string[]): Promise<{
        schemaChanged?: boolean;
    }>;
    getLocales(): ContentStoreTypes.ContentStoreLocale[] | undefined;
    getPresets({ locale }?: {
        locale?: string;
    }): Record<string, any>;
    getModelsByContentSourceType({ locale, user }?: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Record<string, Record<string, Record<string, Model | ImageModel>>> | null;
    getContentSourceEnvironmentForContentSourceTypeAndId({ srcProjectId, srcType }: {
        srcProjectId: string;
        srcType: string;
    }): string;
    getContentSourceTypes(): string[];
    getContentSourceMeta(): ContentStoreMeta[];
    getGlobalActions(data: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<(ContentStoreTypes.APICustomAction & {
        type: 'global' | 'bulk';
    })[]>;
    getCustomActions(data: ContentStoreTypes.APIGetCustomActionRequest): Promise<ContentStoreTypes.APICustomAction[]>;
    runCustomAction(data: ContentStoreTypes.APIRunCustomActionRequest): Promise<void>;
    getAssetSources(): DistributiveOmit<AssetSource, 'transform' | 'preview'>[];
    hasAccess(data: {
        srcType?: string;
        srcProjectId?: string;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.HasAccessResult>;
    hasChanges({ documents }: {
        documents?: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    }): {
        hasChanges: boolean;
        changedObjects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    };
    getSiteMapEntries(options: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): SiteMapEntry[];
    getTreeViews({ user }: {
        user?: ContentStoreTypes.User;
    }): TreeViewNode[];
    getSiteMapEntriesForDocument(options: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        locale?: string;
    }): SiteMapEntry[];
    getDocument({ srcDocumentId, srcProjectId, srcType, user }: {
        srcDocumentId: string;
        srcProjectId: string;
        srcType: string;
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.Document | undefined;
    getDocumentsByContext({ context, srcProjectId, srcType }: {
        context: any;
        srcProjectId?: string;
        srcType: string;
    }): ContentStoreTypes.Document[];
    getDocuments({ locale, user }: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.Document[];
    getReferenceMap(): ContentStoreTypes.ReferenceMap;
    getAssets({ locale, user }: {
        locale?: string;
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.Asset[];
    getAssetFilePath(url: string): string | undefined;
    getLocalizedApiObjects({ locale, objectIds, user }: {
        locale?: string;
        objectIds?: string[];
        user?: ContentStoreTypes.User;
    }): ContentStoreTypes.APIObject[];
    createPreset({ dir, presetParams, preset, user }: {
        dir: string;
        presetParams: PresetParams;
        preset: Preset;
        user?: ContentStoreTypes.User;
    }): Promise<{
        files: string[];
        preset: Preset;
    }>;
    deletePreset({ dir, presetId, user }: {
        dir: string;
        presetId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        changes: {
            filePath: string;
            description: string;
        }[];
        filesRemoved: string[];
    }>;
    createDocument(data: {
        srcType: string;
        srcProjectId: string;
        modelName: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
        defaultLocaleDocumentId?: string;
    }): Promise<{
        srcDocumentId: string;
    }>;
    createAndLinkDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        modelName: string;
        refSrcType?: string;
        refProjectId?: string;
        object?: Record<string, any>;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
        createdDocumentId: string;
    }>;
    uploadAndLinkAsset(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        asset: ContentStoreTypes.UploadAssetData;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    duplicateDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    updateDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        updateOperations: ContentStoreTypes.UpdateOperation[];
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    deleteDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    archiveDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    unarchiveDocument(data: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    getScheduledActions(): Promise<{
        scheduledActions: ScheduledActionWithSource[];
    }>;
    createScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        name: string;
        documentIds: string[];
        executeAt: string;
        action: ScheduledActionActionType;
        user?: ContentStoreTypes.User;
    }): Promise<{
        newScheduledActionId: string;
    }>;
    cancelScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        cancelledScheduledActionId: string;
    }>;
    updateScheduledAction(data: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        name?: string;
        documentIds?: string[];
        executeAt?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        updatedScheduledActionId: string;
    }>;
    searchDocuments(data: {
        query?: string;
        filter?: ContentStoreTypes.SearchFilter;
        models: Array<{
            srcProjectId: string;
            srcType: string;
            modelName: string;
        }>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        total: number;
        items: ContentStoreTypes.Document[];
    }>;
    getDocumentVersions(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        versions: ContentStoreTypes.APIDocumentVersion[];
    }>;
    getDocumentForVersion(data: {
        srcType: string;
        srcProjectId: string;
        documentId: string;
        versionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        version: ContentStoreTypes.APIDocumentVersionWithDocument;
    }>;
    validateDocuments(data: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        errors: ContentStoreTypes.ValidationError[];
    }>;
    publishDocuments(data: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    unpublishDocuments(data: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    getApiAssets(data?: Parameters<ContentStore['getApiAssets']>[0]): Promise<{
        assets: ContentStoreTypes.APIAsset[] | ContentStoreTypes.Asset[];
        pageSize: number;
        pageNum: number;
        totalPages: number;
    }>;
    getApiDocuments(data?: {
        documentSpecs?: DocumentSpecifier[];
        user?: ContentStoreTypes.User;
    }): Promise<{
        documents: ContentStoreTypes.APIDocument[];
    }>;
    getCSIDocuments(data?: {
        documentSpecs?: DocumentSpecifier[];
        srcType?: string;
        srcProjectId?: string;
        limit?: number;
        offset?: number;
    }): {
        total: number;
        offset: number;
        documents: StackbitTypes.Document[];
    };
    getStagedChanges(data: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
            srcEnvironment?: string;
        }[];
        locale?: string;
        scope: 'all' | 'content';
        shallow?: boolean;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.StagedChange[]>;
    uploadAssets({ srcType, srcProjectId, assets, locale, user }: {
        srcType: string;
        srcProjectId: string;
        assets: ContentStoreTypes.UploadAssetData[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<any[]>;
    onWebhook(data: {
        srcType: string;
        srcProjectId: string;
        data: unknown;
        headers: Record<string, string>;
    }): Promise<void>;
    getObject_deprecated({ objectId, projectId }: {
        objectId: string;
        projectId?: string;
    }): any;
    listAssets_deprecated(filterParams: any): Promise<{
        assets: {
            objectId: string;
            fileName: string;
            url: any;
            size: any;
            createdAt: any;
        }[];
        meta: {
            totalPages: number;
        };
    }>;
    getAssets_deprecated(data?: {
        pageSize?: number;
        pageId?: number;
        searchQuery?: string;
    }): Promise<{
        data: ContentStoreTypes.APIAsset[];
        meta: {
            nextPage: number | null;
        };
    }>;
    uploadAsset_deprecated({ url, fileName, user }: {
        url: string;
        fileName: string;
        user: any;
    }): Promise<{
        objectId: string;
        fileName: string;
        url: any;
        size: any;
        createdAt: any;
    }>;
    createObject_deprecated(data: any): Promise<any>;
    duplicateObject_deprecated(data: any): Promise<any>;
    updateObject_deprecated(data: any): Promise<any[]>;
    updateObject_api_deprecated(objectId: string, projectId: string, object: any, user: any): Promise<any>;
    deleteObject_deprecated(data: any): Promise<any>;
}
//# sourceMappingURL=content-store-adapter.d.ts.map