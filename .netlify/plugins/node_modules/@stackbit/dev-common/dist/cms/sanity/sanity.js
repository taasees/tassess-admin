"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require('lodash');
const fse = require('fs-extra');
const path = require('path');
const { SanityClient } = require('@stackbit/cms-sanity/dist/sanity-api-client');
const { isStackbitYamlFile } = require('@stackbit/sdk');
const cmsCore = require('@stackbit/cms-core');
const cmsSanity = require('@stackbit/cms-sanity');
const socketService = require('../../services/socket-service');
const { handleSchemaAssets } = require('../../utils/schema-assets-manager');
module.exports = class Sanity {
    constructor(options) {
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.debug('initialize sanity', { project: _.omit(options.project, 'token') });
        this.schema = null;
        this.encodingResult = null;
        this.encoderDelegate = null;
        this.stackbitConfig = options.stackbitConfig;
        this.encodeDelimiter = _.get(options, 'encodeDelimiter');
        this.onContentUpdate = _.get(options, 'onContentUpdate', () => { });
        this.rootDir = options.rootDir;
        this.appDir = options.appDir;
        this.repoDir = options.repoDir;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.project = options.project;
        this.project.dataset = this.project.dataset || 'production';
        this.studioFolder = _.get(this.project, 'studioPath') || 'studio';
        this.studioAbsPath = path.join(this.repoDir, this.studioFolder);
        this.sanityQuery = options.sanityQuery || '*[!(_id in path("_.**"))]';
        if (!this.project) {
            console.warn('sanity project with id and token was not provided');
        }
    }
    debug(message, data) {
        this.logger.debug(`[${this.constructor.name}] ${message}`, data);
    }
    error(message, data) {
        this.logger.error(`[${this.constructor.name}] ${message}`, data);
    }
    getEncodingResult() {
        this.debug('get encoding');
        return { ...this.encodingResult, fieldData: this.overlayDraftDocuments(_.get(this.encodingResult, 'fieldData', null)) };
    }
    getLocalizedFieldData() {
        return this.overlayDraftDocuments(_.get(this.encodingResult, 'fieldData', null));
    }
    overlayDraftDocuments(docs) {
        const canonical = _.pickBy(docs, (val, key) => !key.startsWith('drafts.'));
        const drafts = _.pickBy(docs, (val, key) => key.startsWith('drafts.'));
        _.forEach(drafts, (draft) => {
            canonical[draft.srcObjectId] = draft;
        });
        return canonical;
    }
    getSchemaKey() {
        return 'sanity';
    }
    getModelsForProjectId(projectId) {
        // currently we support only one project in Sanity
        return _.get(this.schema, 'models', null);
    }
    getEnvironmentForProjectId(projectId) {
        // currently we support only one project in Sanity
        return _.get(this.project, 'dataset');
    }
    getPresets() {
        return _.get(this.schema, 'presets');
    }
    getMappedModels() {
        // there is only one project with sanity
        // but in order to make it generic, return object with single project key
        const modelsByName = _.keyBy(this.schema.models, 'name');
        return {
            [this.project.projectId]: modelsByName
        };
    }
    async run({ spawnRunner } = {}) {
        this.userLogger.info('Fetching Sanity schema...');
        await this.fetchSchema({ spawnRunner });
        // await this.fetchUsers(); // todo: fetch users to enrich changelog like in contentful
        await this.fetchDataAndEncode();
        this.startWatchingContentUpdates();
    }
    async restart({ spawnRunner } = {}) {
        const { schemaChanged } = await this.fetchSchema({ spawnRunner });
        await this.fetchDataAndEncode();
        if (schemaChanged) {
            socketService.notifySchemaChange();
        }
    }
    startWatchingContentUpdates() {
        if (!this.project) {
            this.error("can't start listener: env.SANITY not defined");
            return;
        }
        const { projectId, dataset, token } = this.project;
        if (!projectId || !dataset || !token) {
            this.error("can't start listener: incomplete env.SANITY details");
            return;
        }
        if (this.contentChangeSubscription) {
            this.stopWatchingContentUpdates();
        }
        this.debug('startWatchingContentUpdates');
        this.contentChangeSubscription = this.createSanityListener();
        this.contentChangeSubscriptionInterval = setInterval(() => {
            const newListener = this.createSanityListener();
            this.contentChangeSubscription.unsubscribe();
            this.contentChangeSubscription = newListener;
        }, 1000 * 60 * 20);
    }
    createSanityListener() {
        this.debug('createSanityListener');
        const { projectId, dataset, token } = this.project;
        const onContentChangeDebounced = _.debounce(() => this.onContentUpdate(), {
            leading: true,
            trailing: true,
            maxWait: 500
        });
        const client = new SanityClient({
            projectId,
            dataset,
            token,
            useCdn: false
        });
        return client.listen(this.sanityQuery, {}).subscribe({
            next: (event) => {
                this.debug('SanityListener: content changed');
                this.encodeContentUpdateResult(event);
                onContentChangeDebounced();
            },
            error: (error) => {
                this.error('SanityListener: threw error', error);
            },
            complete: () => {
                this.debug('SanityListener: complete received');
            }
        });
    }
    encodeContentUpdateResult(event) {
        const transition = _.get(event, 'transition');
        const documentId = _.get(event, 'documentId');
        const identity = _.get(event, 'identity');
        const result = _.get(event, 'result');
        const resultType = _.get(result, '_type');
        // ignore system events related to system objects
        if (_.startsWith(documentId, '_.') || identity === '<system>' || _.startsWith(resultType, 'system.')) {
            return;
        }
        if (transition === 'disappear') {
            _.unset(this.encodingResult, ['fieldData', documentId]);
        }
        if (result) {
            // todo: fetch transaction history for documentId to know about the creating author, updating author, and true draft status
            //  like in fetchDataAndEncode
            this.encodeListenResult(result);
        }
        const pureDocumentId = documentId.replace(/^drafts\./, '');
        socketService.notifyObjectsChanged({
            changedObjects: [
                {
                    srcObjectId: pureDocumentId,
                    srcType: 'sanity',
                    srcProjectId: this.project.projectId
                }
            ]
        });
    }
    stopWatchingContentUpdates() {
        if (this.contentChangeSubscription) {
            this.debug('stopping content change listener');
            this.contentChangeSubscription.unsubscribe();
            this.contentChangeSubscription = null;
            clearInterval(this.contentChangeSubscriptionInterval);
            this.contentChangeSubscriptionInterval = null;
        }
    }
    async postPull(updatedFiles, { spawnRunner } = {}) {
        this.debug('postPull', { updatedFiles });
        if (!updatedFiles.length) {
            this.debug('no changes');
            return {};
        }
        const updatedSchemaFiles = _.filter(updatedFiles, (filePath) => {
            const filePathRelativeToAppDir = path.relative(this.appDir, filePath);
            return this.isSchemaFile(filePathRelativeToAppDir);
        });
        this.debug(`found ${updatedSchemaFiles.length} updated schema files`, { updatedSchemaFiles });
        const schemaFilesUpdated = updatedSchemaFiles.length > 0;
        if (schemaFilesUpdated) {
            await this.fetchSchema({ spawnRunner });
        }
        return {
            schemaChanged: schemaFilesUpdated
        };
    }
    someSchemaFiles(updatedFiles) {
        return _.some(updatedFiles, (filePath) => {
            const filePathRelativeToAppDir = path.relative(this.appDir, filePath);
            return this.isSchemaFile(filePathRelativeToAppDir);
        });
    }
    isSchemaFile(filePath) {
        return filePath.startsWith(path.join(this.studioFolder, 'schemas/')) || isStackbitYamlFile(filePath);
    }
    async fetchSchema({ spawnRunner } = {}) {
        this.debug('fetch schema', { projectId: this.project.projectId, dataset: this.project.dataset, spawnRunner: !!spawnRunner });
        if (!(await fse.pathExists(this.studioAbsPath))) {
            this.userLogger.error('Error finding Sanity Studio at ' + this.studioAbsPath);
            throw new Error('Error finding Sanity Studio');
        }
        const { schema, errors } = await cmsCore.stackbit.fetchAndConvertSchema({ dirPath: this.stackbitConfig?.dirPath ?? this.repoDir }).catch((err) => {
            this.logger.warn('Failed to load stackbit.yaml, continuing without merging models', err);
            return {};
        });
        _.forEach(errors, (error) => {
            this.userLogger.warn(error.message);
        });
        const sanitySchema = await cmsSanity
            .fetchAndConvertSchema({
            studioPath: this.studioAbsPath,
            repoPath: this.repoDir,
            stackbitModels: _.get(schema, 'models'),
            presets: _.get(schema, 'presets'),
            spawnRunner,
            logger: this.logger
        })
            .catch((error) => {
            this.error('error fetching schema', { error });
            if (_.get(error, 'stack')) {
                this.error('error fetching schema, error.stack: ' + error.stack);
            }
            this.userLogger.error(`Error loading Sanity Studio from '${this.studioFolder}' directory. Please verify that a valid Sanity Studio exists there.`);
            throw error;
        });
        this.debug('successfully fetched schema');
        const prevSchema = this.schema;
        this.schema = {
            ...sanitySchema,
            presets: schema.presets
        };
        const { models, presets } = await handleSchemaAssets({
            models: this.schema.models,
            presets: this.schema.presets,
            rootDir: this.rootDir,
            stackbitYamlDir: this.stackbitConfig?.dirPath ?? this.repoDir,
            logger: this.logger,
            userLogger: this.userLogger,
            staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
            staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath
        });
        this.schema = {
            ...this.schema,
            models,
            presets
        };
        this.encoderDelegate = new cmsSanity.SanityEncoderDelegate({
            projectId: this.project.projectId,
            projectUrl: this.project.projectUrl,
            dataset: this.project.dataset,
            schema: sanitySchema,
            encodedFieldTypes: this.stackbitConfig?.encodedFieldTypes
        });
        let schemaChanged = false;
        if (!_.isUndefined(prevSchema) && !_.isEqual(prevSchema, this.schema)) {
            schemaChanged = true;
            this.debug('schema has been changed');
        }
        return {
            schemaChanged
        };
    }
    async fetchDataAndEncode() {
        if (!this.project) {
            this.error("can't fetch data: Sanity project details not defined");
            return Promise.resolve();
        }
        const { projectId, dataset, token } = this.project;
        if (!projectId || !dataset || !token) {
            this.error("can't fetch data: incomplete Sanity project details");
            return Promise.resolve();
        }
        this.debug('fetchDataAndEncode');
        const client = new SanityClient({
            projectId,
            dataset,
            token,
            useCdn: false
        });
        const data = await client.fetch(this.sanityQuery);
        // TODO: we can use sanity Transactions API to get data about author history of every document,
        //  as well as information about whether it's an object that has never been published before (true draft)
        //  this data needs to be attached to the data entries so that they can be added as metadata in sanity-encoder-delegate->getItemMetadata
        this.debug(`fetched ${data.length} entries from project ${projectId} and dataset ${dataset}, with query ${this.sanityQuery}`);
        this.encodingResult = cmsCore.encodeData({
            data,
            prevEncodingResult: null,
            delegate: this.encoderDelegate,
            encodeDelimiter: this.encodeDelimiter
        });
    }
    encodeListenResult(result) {
        return _.head(this.encodeItems([result]), false);
    }
    encodeItems(items, initial) {
        this.encodingResult = cmsCore.encodeData({
            data: items,
            prevEncodingResult: initial ? null : this.encodingResult,
            delegate: this.encoderDelegate,
            encodeDelimiter: this.encodeDelimiter
        });
        return this.encodingResult.encodedData;
    }
    clearCache() {
        this.encodingResult = null;
    }
};
//# sourceMappingURL=sanity.js.map