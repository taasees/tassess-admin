"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentStoreAdapter = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const sdk_1 = require("@stackbit/sdk");
const cms_core_1 = require("@stackbit/cms-core");
const socket_service_1 = __importDefault(require("../services/socket-service"));
const schema_assets_manager_1 = require("../utils/schema-assets-manager");
const contentful_1 = require("./contentful/contentful");
const sanity_1 = __importDefault(require("./sanity/sanity"));
const git_1 = __importDefault(require("./git/git"));
const presets_service_1 = require("../services/presets-service");
class ContentStoreAdapter {
    constructor(options) {
        this.stackbitConfig = null;
        this.cmsType = options.cmsType;
        this.csiEnabled = options.csiEnabled ?? false;
        this.webhookUrl = options.webhookUrl;
        this.workers = options.workers;
        this.rootDir = options.rootDir;
        this.projectDir = options.projectDir;
        this.appDir = options.appDir;
        this.repoUrl = options.repoUrl;
        this.repoBranch = options.repoBranch;
        this.repoPublishBranch = options.repoPublishBranch;
        this.runEnv = options.runEnv;
        this.runUid = options.runUid;
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.localDev = options.localDev;
        this.skipPush = options.skipPush;
        this.userCommandSpawner = options.userCommandSpawner;
        this.assetIdPrefix = options.assetIdPrefix;
        this.staticAssetsFilePath = options.staticAssetsFilePath;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.defaultContentTypeExtensions = options.defaultContentTypeExtensions;
        this.commitAndPushChanges = options.commitAndPushChanges;
        this.devAppRestartNeeded = options.devAppRestartNeeded;
        this.contentfulAccessToken = options.contentfulAccessToken;
        this.contentfulSpaces = options.contentfulSpaces;
        this.sanityProject = options.sanityProject;
        this.sanityQuery = options.sanityQuery;
    }
    async init({ stackbitConfig }) {
        const runCommand = (0, cms_core_1.getCommandRunner)({
            env: this.runEnv ?? {},
            uid: this.runUid
        });
        this.gitService = new cms_core_1.GitService({
            repoUrl: this.repoUrl ?? '',
            repoDir: this.projectDir,
            repoBranch: this.repoBranch ?? 'preview',
            repoPublishBranch: this.repoPublishBranch ?? 'master',
            worker: this.workers.gitApp,
            runCommand,
            skipPush: this.skipPush,
            logger: this.logger,
            userLogger: this.userLogger
        });
        this.stackbitConfig = await this.extendStackbitConfigWithContentSources(stackbitConfig);
        if (this.stackbitConfig?.contentSources || this.stackbitConfig?.connectors) {
            this.userLogger.info('Using Content Source Interface');
            const stackbitYamlDir = this.stackbitConfig.dirPath;
            this.contentStore = new cms_core_1.ContentStore({
                logger: this.logger,
                userLogger: this.userLogger,
                localDev: this.localDev,
                staticAssetsPublicPath: this.staticAssetsPublicPath,
                webhookUrl: this.webhookUrl,
                runCommand,
                git: this.gitService,
                userCommandSpawner: this.userCommandSpawner,
                onSchemaChangeCallback: () => socket_service_1.default.notifySchemaChange(),
                onContentChangeCallback: (contentChanges) => {
                    socket_service_1.default.notifyObjectsChanged({
                        changedObjects: lodash_1.default.reduce(lodash_1.default.pick(contentChanges, [
                            'createdDocuments',
                            'createdAssets',
                            'updatedDocuments',
                            'updatedAssets',
                            'deletedDocuments',
                            'deletedAssets'
                        ]), (changedObjects, changedItems, key) => {
                            let type;
                            let srcObjectType;
                            switch (key) {
                                case 'createdDocuments':
                                    type = 'added';
                                    srcObjectType = 'document';
                                    break;
                                case 'createdAssets':
                                    type = 'added';
                                    srcObjectType = 'asset';
                                    break;
                                case 'updatedDocuments':
                                    type = 'modified';
                                    srcObjectType = 'document';
                                    break;
                                case 'updatedAssets':
                                    type = 'modified';
                                    srcObjectType = 'asset';
                                    break;
                                case 'deletedDocuments':
                                    type = 'deleted';
                                    srcObjectType = 'document';
                                    break;
                                case 'deletedAssets':
                                    type = 'deleted';
                                    srcObjectType = 'asset';
                                    break;
                            }
                            const resultItems = changedItems.map((item) => ({
                                ...item,
                                type,
                                srcObjectType
                            }));
                            changedObjects.push(...resultItems);
                            return changedObjects;
                        }, []),
                        changedScheduledActions: lodash_1.default.reduce(lodash_1.default.pick(contentChanges, ['createdScheduledActions', 'updatedScheduledActions', 'deletedScheduledActions']), (changedObjects, changedItems, key) => {
                            let type;
                            switch (key) {
                                case 'createdScheduledActions':
                                    type = 'added';
                                    break;
                                case 'updatedScheduledActions':
                                    type = 'modified';
                                    break;
                                case 'deletedScheduledAction':
                                    type = 'deleted';
                                    break;
                            }
                            const resultItems = changedItems.map((item) => ({ ...item, type }));
                            changedObjects.push(...resultItems);
                            return changedObjects;
                        }, [])
                    });
                },
                onActionStateChangeCallback: (actionStateChange) => socket_service_1.default.notifyActionStateChange(actionStateChange),
                handleConfigAssets: async ({ models, presets }) => {
                    return (0, schema_assets_manager_1.handleSchemaAssets)({
                        models,
                        presets,
                        rootDir: this.rootDir,
                        stackbitYamlDir: stackbitYamlDir,
                        logger: this.logger,
                        userLogger: this.userLogger,
                        staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                        staticThemeAssetsFilePath: this.staticThemeAssetsFilePath
                    });
                },
                devAppRestartNeeded: this.devAppRestartNeeded
            });
            await this.contentStore.init({ stackbitConfig: this.stackbitConfig });
        }
        else {
            this.userLogger.info(`Loading from ${this.cmsType || 'git'}...`);
            this.cms = this.createCms();
            await this.cms.run({ spawnRunner: this.userCommandSpawner });
        }
    }
    async destroy() {
        await this.contentStore?.destroy();
    }
    isContentStoreEnabled() {
        return Boolean(this.contentStore);
    }
    getGitService() {
        return this.gitService;
    }
    async onStackbitConfigChange({ stackbitConfig }) {
        if (stackbitConfig?.filePath) {
            this.userLogger.info(`reloading stackbit config from: ${path_1.default.relative(this.rootDir, stackbitConfig.filePath)}`);
        }
        this.stackbitConfig = await this.extendStackbitConfigWithContentSources(stackbitConfig);
        if (this.contentStore) {
            try {
                await this.contentStore.onStackbitConfigChange({ stackbitConfig: this.stackbitConfig });
            }
            catch (error) {
                const errorMessage = 'error loading stackbit config';
                if (error.stack) {
                    this.userLogger.error(`${errorMessage}:\n ${error.stack}`);
                }
                else if (error.message) {
                    this.userLogger.error(`${errorMessage}: ${error.message}`);
                }
                this.userLogger.error(errorMessage, { error });
            }
        }
        else if (this.cms) {
            await this.cms.restart({ spawnRunner: this.userCommandSpawner }).catch(() => { });
        }
        socket_service_1.default.notifySchemaChange();
    }
    async extendStackbitConfigWithContentSources(config) {
        // if there is no config, or config already has contentSources, return it
        if (!config || config?.contentSources || config?.connectors) {
            return config;
        }
        // if CSI enabled, and cmsType is one of the CSI supported content-sources,
        // create content-sources according to the cmsType
        const supportedContentSources = ['git', 'contentful', 'sanity'];
        const forceCSI = (!this.cmsType || supportedContentSources.includes(this.cmsType)) && this.csiEnabled;
        if (!forceCSI) {
            return config;
        }
        // for backward compatibility use ContentfulContentSource when stackbit.yaml has cmsType === 'contentful'
        if (this.cmsType === 'contentful') {
            const contentfulContentSourceModule = await importContentSourceModule('@stackbit/cms-contentful');
            const contentSources = this.contentfulSpaces.map((space) => {
                return new contentfulContentSourceModule.ContentfulContentSource({
                    spaceId: space.spaceId,
                    previewToken: space.previewToken,
                    accessToken: this.contentfulAccessToken
                });
            });
            return {
                ...config,
                contentSources
            };
        }
        // for backward compatibility use SanityContentSource when stackbit.yaml has cmsType === 'sanity'
        if (this.cmsType === 'sanity') {
            if (!this.sanityProject) {
                this.userLogger.error('Cannot create SanityContentSource, missing sanity project data');
                throw new Error('Cannot create SanityContentSource, missing sanity project data');
            }
            const sanityContentSourceModule = await importContentSourceModule('@stackbit/cms-sanity');
            const contentSources = [
                new sanityContentSourceModule.SanityContentSource({
                    token: this.sanityProject.token,
                    projectId: this.sanityProject.projectId,
                    dataset: this.sanityProject.dataset || 'production',
                    studioPath: path_1.default.join(this.appDir, this.sanityProject.studioPath || 'studio'),
                    studioUrl: this.sanityProject.projectUrl,
                    rootPath: this.projectDir
                })
            ];
            return {
                ...config,
                contentSources
            };
        }
        if (!this.cmsType || this.cmsType === 'git') {
            const gitContentSourceModule = await importContentSourceModule('@stackbit/cms-git');
            const result = await (0, sdk_1.loadConfigWithModelsPresetsAndValidate)({
                dirPath: this.projectDir,
                isForcedGitCSI: true
            });
            for (const error of result.errors) {
                this.userLogger.warn('error in stackbit config: ' + error.message);
            }
            const contentSources = [
                new gitContentSourceModule.GitContentSource({
                    rootPath: this.projectDir,
                    contentDirs: [config.pagesDir, config.dataDir].filter(Boolean),
                    assetsConfig: config.assets,
                    models: result.config?.models ?? []
                })
            ];
            return {
                ...config,
                contentSources
            };
        }
        throw new Error(`no default content source for cmsType: ${this.cmsType}`);
        // for backward compatibility use ContentfulContentSource when stackbit.yaml has cmsType === 'git'
        // const gitContentSourceModule = await importContentSourceModule('@stackbit/cms-git');
        // return ...
    }
    createCms() {
        // Remove once sanity and git-cms are implemented as ContentSourceInterface
        if (this.cmsType === 'contentful') {
            return new contentful_1.Contentful({
                accessToken: this.contentfulAccessToken ?? null,
                spaces: this.contentfulSpaces,
                stackbitConfig: this.stackbitConfig,
                encodeDelimiter: '',
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                watchForContentUpdates: true,
                onContentUpdate: () => { },
                logger: this.logger,
                userLogger: this.userLogger
            });
        }
        else if (this.cmsType === 'sanity') {
            return new sanity_1.default({
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                stackbitConfig: this.stackbitConfig,
                sanityQuery: this.sanityQuery,
                encodeDelimiter: '',
                workers: this.workers,
                project: {
                    token: this.sanityProject?.token,
                    projectId: this.sanityProject?.projectId,
                    dataset: this.sanityProject?.dataset,
                    studioPath: this.sanityProject?.studioPath,
                    projectUrl: this.sanityProject?.projectUrl
                },
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                onContentUpdate: () => { },
                logger: this.logger,
                userLogger: this.userLogger
            });
        }
        else {
            return new git_1.default({
                rootDir: this.rootDir,
                repoDir: this.projectDir,
                appDir: this.appDir,
                repoUrl: this.repoUrl,
                repoBranch: this.repoBranch,
                stackbitConfig: this.stackbitConfig,
                workers: this.workers,
                assetIdPrefix: this.assetIdPrefix,
                staticAssetsFilePath: this.staticAssetsFilePath,
                staticAssetsPublicPath: this.staticAssetsPublicPath,
                staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath,
                defaultContentTypeExtensions: this.defaultContentTypeExtensions,
                commitAndPushChanges: this.commitAndPushChanges,
                logger: this.logger,
                userLogger: this.userLogger
            });
        }
    }
    async keepAlive() {
        if (this.contentStore) {
            this.contentStore.keepAlive().catch((error) => {
                this.logger.error('keepAlive error', { error });
            });
        }
        else if (this.cms) {
            lodash_1.default.invoke(this.cms, 'keepAlive');
        }
        else {
            throw new Error('Content source plugin missing required method: keepAlive');
        }
    }
    async handleFileChanges(filePaths) {
        if (!filePaths.length) {
            this.logger.debug('no changes');
            return {
                schemaChanged: false
            };
        }
        let schemaChanged = false;
        if (this.contentStore) {
            const updatedFiles = filePaths.map((filePath) => path_1.default.relative(this.appDir, path_1.default.join(this.projectDir, filePath)));
            // schemaChanged and contentChanged events are handled within content-store
            await this.contentStore.onFilesChange(updatedFiles);
        }
        else if (this.cms) {
            const pullResult = await this.cms
                .postPull(filePaths.map((filePath) => path_1.default.join(this.projectDir, filePath)), {
                spawnRunner: this.userCommandSpawner
            })
                .catch((err) => {
                this.logger.debug('Error in postPull', { err });
                throw err;
            });
            schemaChanged = !!pullResult?.schemaChanged;
        }
        if (schemaChanged) {
            socket_service_1.default.notifySchemaChange();
        }
        return { schemaChanged };
    }
    getLocales() {
        if (this.contentStore) {
            return this.contentStore.getLocales();
        }
        else if (this.cms) {
            return lodash_1.default.result(this.cms, 'getLocales');
        }
        else {
            throw new Error('Content source plugin missing required method: getLocales');
        }
    }
    getPresets({ locale } = {}) {
        if (this.contentStore) {
            return this.contentStore.getPresets({ locale });
        }
        else if (this.cms) {
            return lodash_1.default.result(this.cms, 'getPresets', {});
        }
        else {
            throw new Error('Content source plugin missing required method: getPresets');
        }
    }
    getModelsByContentSourceType({ locale, user } = {}) {
        if (this.contentStore) {
            // contentStore models already localized to default locale
            return this.contentStore.getModels({ user });
        }
        else if (this.cms) {
            const schemaKey = this.cms.getSchemaKey();
            const mappedModels = this.cms.getMappedModels(locale);
            return { [schemaKey]: mappedModels };
        }
        else {
            throw new Error('Content source plugin missing required method: getModelsByContentSourceType');
        }
    }
    getContentSourceEnvironmentForContentSourceTypeAndId({ srcProjectId, srcType }) {
        if (this.contentStore) {
            return this.contentStore.getContentSourceEnvironment({ srcProjectId, srcType });
        }
        else if (this.cms) {
            return this.cms.getEnvironmentForProjectId(srcProjectId);
        }
        else {
            throw new Error('Content source plugin missing required method: getContentSourceEnvironmentForContentSourceTypeAndId');
        }
    }
    getContentSourceTypes() {
        if (this.contentStore) {
            return lodash_1.default.uniq(this.contentStore.getContentSourceMeta().map((source) => source.srcType));
        }
        return [];
    }
    getContentSourceMeta() {
        if (this.contentStore) {
            return this.contentStore.getContentSourceMeta();
        }
        return [];
    }
    async getGlobalActions(data) {
        if (this.contentStore) {
            return this.contentStore.getGlobalActions(data);
        }
        return [];
    }
    async getCustomActions(data) {
        if (this.contentStore) {
            return this.contentStore.getCustomActions(data);
        }
        return [];
    }
    async runCustomAction(data) {
        if (this.contentStore) {
            return this.contentStore.runCustomAction(data);
        }
    }
    getAssetSources() {
        if (!this.contentStore) {
            return [];
        }
        return this.contentStore.getAssetSources();
    }
    async hasAccess(data) {
        if (this.contentStore) {
            return this.contentStore.hasAccess(data ?? {});
        }
        else if (this.localDev) {
            // we shouldn't reach this point because when content store isn't
            // enabled hasAccess would be handled by the API.
            return {
                hasConnection: true,
                hasPermissions: true,
                contentSources: []
            };
        }
        throw new Error('Content source plugin missing required method: hasAccess');
    }
    hasChanges({ documents }) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: hasChanges');
        }
        return this.contentStore.hasChanges({ documents });
    }
    getSiteMapEntries(options) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getSiteMapEntries');
        }
        return this.contentStore.getSiteMapEntries(options);
    }
    getTreeViews({ user }) {
        if (!this.contentStore) {
            throw new Error('not implemented');
        }
        return this.contentStore.getTreeViews({ user });
    }
    getSiteMapEntriesForDocument(options) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getSiteMapEntriesForDocument');
        }
        return this.contentStore.getSiteMapEntriesForDocument(options);
    }
    getDocument({ srcDocumentId, srcProjectId, srcType, user }) {
        if (this.contentStore) {
            return this.contentStore.getDocument({ srcDocumentId, srcProjectId, srcType, user });
        }
        else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = lodash_1.default.get(encodingResult, 'fieldData');
            const document = lodash_1.default.find(fieldData, { srcObjectId: srcDocumentId, srcProjectId: srcProjectId });
            if (!document) {
                return;
            }
            if (document.type !== 'object') {
                return;
            }
            return {
                ...document,
                getPreview: () => ({ previewTitle: document.srcObjectLabel }),
                type: 'document'
            };
        }
    }
    getDocumentsByContext({ context, srcProjectId, srcType }) {
        if (this.contentStore) {
            return this.contentStore.getDocumentsByContext({ context, srcProjectId, srcType });
        }
        return [];
    }
    getDocuments({ locale, user }) {
        if (this.contentStore) {
            return this.contentStore.getDocuments({ locale, user });
        }
        else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = lodash_1.default.get(encodingResult, 'fieldData');
            return lodash_1.default.values(fieldData)
                .filter((object) => object.type === 'object')
                .map(({ type, ...rest }) => ({
                type: 'document',
                getPreview: () => ({ previewTitle: rest.srcObjectLabel }),
                ...rest
            }));
        }
        else {
            throw new Error('Content source plugin missing required method: getDocuments');
        }
    }
    getReferenceMap() {
        if (this.contentStore) {
            return this.contentStore.getReferenceMap();
        }
        else if (this.cms) {
            const allContent = [...this.getDocuments({}), ...this.getAssets({})];
            return cms_core_1.referencesUtils.getReferenceMap(allContent);
        }
        else {
            throw new Error('Reference maps are not supported');
        }
    }
    getAssets({ locale, user }) {
        if (this.contentStore) {
            return this.contentStore.getAssets({ locale, user });
        }
        else if (this.cms) {
            const encodingResult = this.cms.getEncodingResult();
            const fieldData = lodash_1.default.get(encodingResult, 'fieldData');
            return lodash_1.default.values(fieldData)
                .filter((object) => object.type === 'image' || object.type === 'file')
                .map(({ type, fields, ...rest }) => ({
                type: 'asset',
                ...rest,
                fields: {
                    title: fields.title,
                    file: {
                        type: 'assetFile',
                        url: fields.url
                    }
                }
            }));
        }
        else {
            throw new Error('Content source plugin missing required method: getAssets');
        }
    }
    getAssetFilePath(url) {
        const assets = this.getAssets({});
        const matchingAsset = assets.find((asset) => {
            if (asset.fields.file.localized) {
                return Object.values(asset.fields.file.locales).find((locale) => {
                    return locale.url === url;
                });
            }
            return asset.fields.file.url === url;
        });
        if (matchingAsset) {
            if (matchingAsset.fields.file.localized) {
                for (const locale in matchingAsset.fields.file.locales) {
                    return matchingAsset.fields.file.locales[locale]?.fileName;
                }
                return undefined;
            }
            return matchingAsset.fields.file.fileName;
        }
    }
    getLocalizedApiObjects({ locale, objectIds, user }) {
        if (this.contentStore) {
            return this.contentStore.getLocalizedApiObjects({ locale, objectIds, user });
        }
        else if (this.cms) {
            let fieldData = this.cms.getLocalizedFieldData(locale);
            if (!fieldData) {
                return [];
            }
            if (objectIds) {
                fieldData = lodash_1.default.pick(fieldData, objectIds);
            }
            return Object.values(fieldData);
        }
        else {
            throw new Error('Content source plugin missing required method: getLocalizedApiObjects');
        }
    }
    async createPreset({ dir, presetParams, preset, user }) {
        if (this.contentStore?.usesContentSourcePresets()) {
            await this.contentStore.createPreset({ preset, thumbnailAsset: presetParams.thumbnail, user });
            return {
                files: [],
                preset
            };
        }
        else {
            const result = await (0, presets_service_1.savePreset)(dir, presetParams, preset, this.logger);
            const changeLog = result.files.map((filePath) => ({
                filePath: path_1.default.join(dir, filePath),
                description: 'added preset: ' + preset.label
            }));
            if (user) {
                await this.commitAndPushChanges?.(changeLog, user);
            }
            return result;
        }
    }
    async deletePreset({ dir, presetId, user }) {
        if (this.contentStore?.usesContentSourcePresets()) {
            await this.contentStore.deletePreset({ presetId, user });
            return {
                changes: [],
                filesRemoved: []
            };
        }
        else {
            const filesRemoved = await (0, presets_service_1.deletePreset)(dir, presetId, this.logger);
            const changeLog = filesRemoved.map((filePath) => ({
                filePath: path_1.default.join(dir, filePath),
                description: 'removed preset'
            }));
            if (user) {
                await this.commitAndPushChanges?.(changeLog, user);
            }
            return {
                changes: changeLog,
                filesRemoved: filesRemoved
            };
        }
    }
    async createDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: createDocument');
        }
        return this.contentStore.createDocument(data);
    }
    async createAndLinkDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: createAndLinkDocument');
        }
        return this.contentStore.createAndLinkDocument(data);
    }
    async uploadAndLinkAsset(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: uploadAndLinkAsset');
        }
        return this.contentStore.uploadAndLinkAsset(data);
    }
    async duplicateDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: duplicateDocument');
        }
        return this.contentStore.duplicateDocument(data);
    }
    async updateDocument(data) {
        if (!this.contentStore?.updateDocument) {
            throw new Error('Content source plugin missing required method: updateDocument');
        }
        return this.contentStore.updateDocument(data);
    }
    async deleteDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: deleteDocument');
        }
        return this.contentStore.deleteDocument(data);
    }
    async archiveDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: archiveDocument');
        }
        return this.contentStore.archiveDocument(data);
    }
    async unarchiveDocument(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: unarchiveDocument');
        }
        return this.contentStore.unarchiveDocument(data);
    }
    async getScheduledActions() {
        if (!this.contentStore?.getScheduledActions) {
            throw new Error('Content source plugin missing required method: getScheduledActions');
        }
        const scheduledActions = this.contentStore.getScheduledActions();
        return { scheduledActions };
    }
    async createScheduledAction(data) {
        if (!this.contentStore?.createScheduledAction) {
            throw new Error('Content source plugin missing required method: createScheduledAction');
        }
        return this.contentStore.createScheduledAction(data);
    }
    async cancelScheduledAction(data) {
        if (!this.contentStore?.cancelScheduledAction) {
            throw new Error('Content source plugin missing required method: cancelScheduledAction');
        }
        return this.contentStore.cancelScheduledAction(data);
    }
    async updateScheduledAction(data) {
        if (!this.contentStore?.updateScheduledAction) {
            throw new Error('Content source plugin missing required method: updateScheduledAction');
        }
        return this.contentStore.updateScheduledAction(data);
    }
    async searchDocuments(data) {
        if (this.contentStore) {
            return this.contentStore.searchDocuments(data);
        }
        if (this.cms) {
            const { locale, user } = data;
            const documents = this.getDocuments({ locale, user });
            const schema = this.getModelsByContentSourceType({ locale, user }) ?? {};
            return cms_core_1.searchUtils.searchDocuments({
                ...data,
                documents,
                schema
            });
        }
        throw new Error('Content source plugin missing required method: searchDocuments');
    }
    async getDocumentVersions(data) {
        if (!this.contentStore?.getDocumentVersions) {
            throw new Error('Content source plugin missing required method: getDocumentVersions');
        }
        return this.contentStore.getDocumentVersions(data);
    }
    async getDocumentForVersion(data) {
        if (!this.contentStore?.getDocumentForVersion) {
            throw new Error('Content source plugin missing required method: getDocumentForVersion');
        }
        return this.contentStore.getDocumentForVersion(data);
    }
    async validateDocuments(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: validateDocuments');
        }
        return this.contentStore.validateDocuments(data);
    }
    async publishDocuments(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: publishDocuments');
        }
        return this.contentStore.publishDocuments(data);
    }
    async unpublishDocuments(data) {
        if (!this.contentStore?.unpublishDocuments) {
            throw new Error('Content source plugin missing required method: unpublishDocuments');
        }
        return this.contentStore.unpublishDocuments(data);
    }
    async getApiAssets(data = {}) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getApiAssets');
        }
        return this.contentStore.getApiAssets(data);
    }
    async getApiDocuments(data = {}) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getApiDocuments');
        }
        return this.contentStore.getApiDocuments(data);
    }
    getCSIDocuments(data = {}) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: getCsiDocuments');
        }
        return this.contentStore.getCSIDocuments(data);
    }
    getStagedChanges(data) {
        if (!this.contentStore?.getStagedChanges) {
            throw new Error('Content source plugin missing required method: getStagedChanges');
        }
        return this.contentStore.getStagedChanges(data);
    }
    async uploadAssets({ srcType, srcProjectId, assets, locale, user }) {
        if (this.contentStore) {
            return this.contentStore.uploadAssets({
                srcProjectId,
                srcType,
                assets,
                locale,
                user
            });
        }
        else if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.uploadAssets(assets, user);
        }
        else {
            throw new Error('Content source plugin missing required method: uploadAssets');
        }
    }
    onWebhook(data) {
        if (!this.contentStore) {
            throw new Error('Content source plugin missing required method: onWebhook');
        }
        return this.contentStore.onWebhook(data);
    }
    getObject_deprecated({ objectId, projectId }) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.getObject(objectId, projectId);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async listAssets_deprecated(filterParams) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.listAssets(filterParams);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async getAssets_deprecated(data = {}) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            const pageId = data.pageId || 1;
            const result = (await this.cms.listAssets(data));
            return {
                data: result.assets,
                meta: {
                    nextPage: pageId < result.meta.totalPages ? pageId + 1 : null
                }
            };
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async uploadAsset_deprecated({ url, fileName, user }) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.uploadAsset({ url, fileName, user, data: null });
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async createObject_deprecated(data) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.createObject(data);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async duplicateObject_deprecated(data) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.duplicateObject(data);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async updateObject_deprecated(data) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.updateObject(data.changedFields, data.user);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async updateObject_api_deprecated(objectId, projectId, object, user) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.updateObject_api(objectId, projectId, object, user);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
    async deleteObject_deprecated(data) {
        // This method is specific to git-cms and called from API for git-cms only
        // Remove once git-cms is implemented as ContentSourceInterface
        if (this.cms && this.cms instanceof git_1.default) {
            return this.cms.deleteObject(data.srcObjectId, data.user);
        }
        else {
            throw new Error('This method should never be called when using content source plugin');
        }
    }
}
exports.ContentStoreAdapter = ContentStoreAdapter;
async function importContentSourceModule(packageName) {
    let modulePath;
    try {
        modulePath = require.resolve(packageName);
    }
    catch (error) {
        throw new Error(`can not find ${packageName} package, please add it as a devDependency by running "npm i ${packageName} --save-dev"`);
    }
    let module;
    try {
        module = await import(modulePath);
    }
    catch (error) {
        throw new Error(`could not load ${packageName} module, error: ${error.message}`);
    }
    return module;
}
//# sourceMappingURL=content-store-adapter.js.map