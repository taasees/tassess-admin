"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contentful = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const sdk_1 = require("@stackbit/sdk");
const utils_1 = require("@stackbit/utils");
const cms_core_1 = require("@stackbit/cms-core");
const cms_contentful_1 = require("@stackbit/cms-contentful");
const contentful_api_client_1 = require("@stackbit/cms-contentful/dist/contentful-api-client");
const socket_service_1 = __importDefault(require("../../services/socket-service"));
const { handleSchemaAssets } = require('../../utils/schema-assets-manager');
const STACKBIT_URL_PATH_FIELD = 'stackbit_url_path';
class Contentful {
    constructor(options) {
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.encodingResult = null;
        this.schemasBySpaceId = null;
        this.localesBySpaceId = null;
        this.usersBySpaceId = null;
        this.defaultLocalesBySpaceId = null;
        this.appDir = options.appDir;
        this.stackbitConfig = options.stackbitConfig;
        this.encodeDelimiter = options.encodeDelimiter;
        this.watchForContentUpdates = options.watchForContentUpdates ?? false;
        this.onContentUpdate = options.onContentUpdate ?? lodash_1.default.noop;
        this.spaces = options.spaces;
        this.accessToken = options.accessToken;
        this.rootDir = options.rootDir;
        this.repoDir = options.repoDir;
        this.staticThemeAssetsPublicPath = options.staticThemeAssetsPublicPath;
        this.staticThemeAssetsFilePath = options.staticThemeAssetsFilePath;
        this.contentPollers = null;
    }
    async run() {
        this.logger.debug('run');
        if (!this.accessToken) {
            this.userLogger.error('Contentful "Personal access token" or "OAuth token" was not provided. Please verify your Contentful configuration.');
            return;
        }
        if (lodash_1.default.isEmpty(this.spaces)) {
            this.userLogger.error('No Contentful spaces were configured. Please verify your Contentful configuration.');
            return;
        }
        await this.fetchSchema();
        await this.fetchUsers();
        await this.fetchDataAndEncode();
        this.startWatchingContentUpdates();
    }
    async restart() {
        this.logger.debug('restart');
        const { schemaChanged } = await this.fetchSchema();
        await this.fetchDataAndEncode();
        if (schemaChanged) {
            socket_service_1.default.notifySchemaChange();
        }
    }
    startWatchingContentUpdates() {
        this.logger.debug('startWatchingContentUpdates');
        this.contentPollers = this.createSyncPollers();
    }
    createSyncPollers() {
        const accessToken = this.accessToken;
        if (lodash_1.default.isEmpty(this.spaces) || !accessToken) {
            return null;
        }
        this.logger.debug('createSyncPollers');
        return this.spaces
            .filter((space) => space.previewToken)
            .map((space) => {
            this.logger.debug('create SyncPoller for space', { spaceId: space.spaceId });
            return new cms_contentful_1.SyncPoller({
                spaceId: space.spaceId,
                environment: space.environment ?? 'master',
                accessToken: space.previewToken,
                managementToken: accessToken,
                notificationCallback: (syncResult) => {
                    this.encodeSyncResult(syncResult, space.spaceId);
                    this.onContentUpdate();
                },
                logger: this.logger
            });
        });
    }
    encodeSyncResult(syncResult, spaceId) {
        // remove deleted entries and assets from fieldData
        // generally, the "sync" method of the preview API never notifies of deleted objects, therefore we rely on
        // the deleteObject method to notify the user that restart is needed. Then, once user restarts the SSG, it
        // will re-fetch the data effectively removing deleted objects
        // https://www.notion.so/stackbit/Contentful-Sync-API-preview-issue-6b4816ebceef4ab181cdf1603058d324
        this.logger.debug(`received sync data, entries: ${syncResult.entries.length}, assets: ${syncResult.assets.length}, deletedEntries: ${syncResult.deletedEntries.length}, deletedAssets: ${syncResult.deletedAssets.length}`);
        const fieldData = this.encodingResult?.fieldData;
        if (fieldData) {
            syncResult.deletedEntries.forEach((deletedEntry) => {
                delete fieldData[deletedEntry.sys.id];
            });
            syncResult.deletedAssets.forEach((deletedAsset) => {
                delete fieldData[deletedAsset.sys.id];
            });
        }
        // re-encode updated/new entries and assets
        const delegate = this.getEncoderDelegateForSpaceId(spaceId);
        this.encodingResult = (0, cms_core_1.encodeData)({
            data: [...syncResult.entries, ...syncResult.assets],
            prevEncodingResult: this.encodingResult,
            delegate: delegate,
            encodeDelimiter: this.encodeDelimiter
        });
        if (syncResult.entries.length) {
            socket_service_1.default.notifyObjectsChanged({
                changedObjects: syncResult.entries.map((entry) => ({
                    srcObjectId: entry.sys.id,
                    srcType: 'contentful',
                    srcProjectId: entry.sys.space.sys.id
                }))
            });
        }
    }
    getEncoderDelegateForSpaceId(spaceId) {
        const schema = lodash_1.default.get(this.schemasBySpaceId, spaceId);
        const defaultLocale = this.getDefaultLocaleForSpaceId(spaceId);
        const users = this.getUsersForSpaceId(spaceId);
        if (!schema) {
            return null;
        }
        return new cms_contentful_1.ContentfulEncoderDelegate({
            schema,
            noEncodeFields: lodash_1.default.union(this.stackbitConfig?.noEncodeFields, [STACKBIT_URL_PATH_FIELD]),
            omitFields: this.stackbitConfig?.omitFields,
            encodedFieldTypes: this.stackbitConfig?.encodedFieldTypes,
            defaultLocale: defaultLocale || undefined,
            users
        });
    }
    getEncodingResult() {
        this.logger.debug('get encoding');
        return this.encodingResult;
    }
    getLocales() {
        return lodash_1.default.reduce(this.localesBySpaceId, (res, locales, srcProjectId) => {
            return res.concat({
                srcType: this.getSchemaKey(),
                srcProjectId,
                locales: locales.map((locale) => locale.code),
                defaultLocale: this.defaultLocalesBySpaceId?.[srcProjectId]
            });
        }, []);
    }
    getLocalizedFieldFromPageEntry(pageModel, pageEntry, fieldName, locale) {
        let fieldValue = lodash_1.default.get(pageEntry, ['fields', fieldName, 'value']);
        if (!fieldValue && locale) {
            fieldValue = lodash_1.default.get(pageEntry, ['fields', fieldName, 'locales', locale, 'value']);
        }
        return fieldValue;
    }
    getPresets() {
        return lodash_1.default.reduce(this.schemasBySpaceId, (presets, spaceSchema) => {
            return Object.assign(presets, spaceSchema.presets);
        }, {});
    }
    getSchemaKey() {
        return 'contentful';
    }
    getMappedModels(locale) {
        return lodash_1.default.mapValues(this.schemasBySpaceId, (spaceSchema, spaceId) => {
            const defaultLocale = this.defaultLocalesBySpaceId?.[spaceId];
            const models = [...(0, cms_contentful_1.localizeModels)(spaceSchema.models, defaultLocale, locale), cms_core_1.IMAGE_MODEL];
            return lodash_1.default.keyBy(models, 'name');
        });
    }
    getModelsForProjectId(projectId) {
        return [...(this.schemasBySpaceId?.[projectId]?.models ?? []), cms_core_1.IMAGE_MODEL];
    }
    getEnvironmentForProjectId(projectId) {
        const space = lodash_1.default.find(this.spaces, { spaceId: projectId });
        return space?.environment ?? 'master';
    }
    getLocalizedFieldData(locale) {
        const fieldData = this.encodingResult?.fieldData;
        if (!fieldData) {
            return null;
        }
        return (0, cms_contentful_1.localizeFieldData)(fieldData, locale, this.defaultLocalesBySpaceId);
    }
    getDefaultLocaleForSpaceId(spaceId) {
        return this.defaultLocalesBySpaceId?.[spaceId] ?? null;
    }
    getUsersForSpaceId(spaceId) {
        return this.usersBySpaceId?.[spaceId] ?? [];
    }
    async fetchSchema() {
        const accessToken = this.accessToken;
        if (lodash_1.default.isEmpty(this.spaces) || !accessToken) {
            this.userLogger.error('Error fetching Contentful schema. Please verify your Contentful configuration.');
            return { schemaChanged: false };
        }
        this.logger.info('Fetching Contentful schema...');
        const prevSchemasBySpaceId = this.schemasBySpaceId;
        try {
            this.logger.debug('fetch schemas for spaces', { spaceIds: lodash_1.default.map(this.spaces, 'spaceId') });
            this.schemasBySpaceId = await (0, utils_1.reducePromise)(this.spaces, async (schemasBySpaceIds, space) => {
                // The default @stackbit/cms-contentful is for backward compatibility, All future sites and themes
                // that use contentful must have @stackbit/cms-contentful inside their package.json
                const defaultContentfulCMSModel = require.resolve('@stackbit/cms-contentful');
                const { config, errors } = await (0, sdk_1.loadConfigWithModelsPresetsAndValidate)({
                    dirPath: this.stackbitConfig?.dirPath ?? this.repoDir,
                    modelsSource: {
                        type: 'contentful',
                        module: defaultContentfulCMSModel,
                        accessToken: accessToken,
                        spaceId: space.spaceId,
                        environment: space.environment ?? 'master'
                    }
                });
                lodash_1.default.forEach(errors, (error) => {
                    this.userLogger.warn(error.message);
                });
                if (config) {
                    const { models, presets } = await handleSchemaAssets({
                        models: config.models,
                        presets: config.presets,
                        rootDir: this.rootDir,
                        stackbitYamlDir: this.stackbitConfig?.dirPath ?? this.repoDir,
                        logger: this.logger,
                        userLogger: this.userLogger,
                        staticThemeAssetsFilePath: this.staticThemeAssetsFilePath,
                        staticThemeAssetsPublicPath: this.staticThemeAssetsPublicPath
                    });
                    schemasBySpaceIds[space.spaceId] = {
                        ...config,
                        models,
                        presets
                    };
                }
                return schemasBySpaceIds;
            }, {});
            this.logger.debug('successfully fetched all schemas');
        }
        catch (error) {
            this.logger.debug('error fetching schemas', { error });
            this.userLogger.error('Error fetching Contentful schema. Please verify your Contentful configuration.');
        }
        try {
            await this.fetchLocales();
        }
        catch (error) {
            this.logger.debug('error fetching locales', { error });
            this.userLogger.error('Error fetching Contentful schema locales. Please verify your Contentful configuration.');
        }
        let schemaChanged = false;
        if (!lodash_1.default.isUndefined(prevSchemasBySpaceId) && !lodash_1.default.isEqual(prevSchemasBySpaceId, this.schemasBySpaceId)) {
            schemaChanged = true;
            this.logger.debug('schema has been changed');
        }
        return {
            schemaChanged
        };
    }
    async fetchLocales() {
        const accessToken = this.accessToken;
        if (lodash_1.default.isEmpty(this.spaces) || !accessToken) {
            return Promise.resolve();
        }
        this.logger.debug('fetch locales for spaces');
        this.localesBySpaceId = await (0, utils_1.reducePromise)(this.spaces, async (localesBySpaceIds, space) => {
            const client = (0, contentful_api_client_1.createPlainApiClient)({
                accessToken,
                spaceId: space.spaceId,
                environment: space.environment ?? 'master'
            });
            let locales;
            try {
                locales = await (0, contentful_api_client_1.fetchAllLocales)(client);
            }
            catch (error) {
                // The fetchAllLocales method uses Contentful's API client that handles errors and retries automatically.
                // Consider adding retry mechanism to fetching everything again ONLY if we have identified cases were such retries would really help.
                this.userLogger.error(`Failed fetching locales from Contentful, error: ${error.message}`);
                return localesBySpaceIds;
            }
            // put the default locale first (for backward compatibility)
            const defaultLocaleIndex = locales.findIndex((locale) => locale.default);
            if (defaultLocaleIndex > -1) {
                const defaultLocale = locales[defaultLocaleIndex];
                locales.splice(defaultLocaleIndex, 1);
                locales.unshift(defaultLocale);
            }
            localesBySpaceIds[space.spaceId] = locales;
            return localesBySpaceIds;
        }, {});
        this.defaultLocalesBySpaceId = lodash_1.default.reduce(this.localesBySpaceId, (defaultLocalesBySpaceId, locales, spaceId) => {
            const defaultLocale = locales.find((locale) => locale.default);
            if (!defaultLocale) {
                return defaultLocalesBySpaceId;
            }
            defaultLocalesBySpaceId[spaceId] = defaultLocale.code;
            return defaultLocalesBySpaceId;
        }, {});
        this.logger.debug('successfully fetched all locales');
    }
    async fetchDataAndEncode() {
        const accessToken = this.accessToken;
        if (lodash_1.default.isEmpty(this.spaces) || !accessToken) {
            return;
        }
        this.logger.debug('fetchDataAndEncode');
        this.encodingResult = await (0, utils_1.reducePromise)(this.spaces, async (encodingResult, space) => {
            const environment = space.environment ?? 'master';
            const client = (0, contentful_api_client_1.createPlainApiClient)({
                accessToken,
                spaceId: space.spaceId,
                environment: environment
            });
            let entries;
            let assets;
            try {
                entries = await (0, contentful_api_client_1.fetchAllEntries)(client);
                assets = await (0, contentful_api_client_1.fetchAllAssets)(client);
            }
            catch (error) {
                // Stackbit won't be able to work properly even if one of the entries or the assets was not fetched.
                // All fetch methods use Contentful's API client that handles errors and retries automatically.
                // Consider adding retry mechanism to fetching everything again ONLY if we have identified cases were such retries would really help.
                this.userLogger.error(`Failed fetching data from Contentful, error: ${error.message}`);
                return null;
            }
            this.logger.debug(`fetched ${entries.length} entries and ${assets.length} assets from space ${space.spaceId} and environment ${environment}`);
            const delegate = this.getEncoderDelegateForSpaceId(space.spaceId);
            return (0, cms_core_1.encodeData)({
                data: [...entries, ...assets],
                prevEncodingResult: encodingResult,
                delegate: delegate,
                encodeDelimiter: this.encodeDelimiter
            });
        }, null);
    }
    async fetchUsers() {
        const accessToken = this.accessToken;
        if (lodash_1.default.isEmpty(this.spaces) || !accessToken) {
            return Promise.resolve();
        }
        this.logger.debug('fetch users for spaces');
        this.usersBySpaceId = await (0, utils_1.reducePromise)(this.spaces, async (usersBySpaceIds, space) => {
            const client = (0, contentful_api_client_1.createPlainApiClient)({
                accessToken,
                spaceId: space.spaceId,
                environment: space.environment ?? 'master'
            });
            let users;
            try {
                users = await (0, contentful_api_client_1.fetchAllUsers)(client);
            }
            catch (error) {
                this.userLogger.error(`Failed fetching users from Contentful, error: ${error.message}`);
                return usersBySpaceIds;
            }
            usersBySpaceIds[space.spaceId] = users;
            return usersBySpaceIds;
        }, {});
        this.logger.debug('successfully fetched all users');
    }
    async postPull(updatedFiles) {
        this.logger.debug('postPull');
        const { updatedCodeFiles = [], updatedSchemaFiles = [] } = lodash_1.default.groupBy(updatedFiles, (filePath) => {
            const filePathRelativeToAppDir = path_1.default.relative(this.appDir, filePath);
            return (0, sdk_1.isStackbitYamlFile)(filePathRelativeToAppDir) ? 'updatedSchemaFiles' : 'updatedCodeFiles';
        });
        this.logger.debug(`found ${updatedSchemaFiles.length} updated code files`, { updatedSchemaFiles });
        const schemaFilesUpdated = updatedSchemaFiles.length > 0;
        if (schemaFilesUpdated) {
            await this.fetchSchema();
        }
        return {
            schemaChanged: schemaFilesUpdated,
            updatedCodeFiles
        };
    }
    keepAlive() {
        lodash_1.default.forEach(this.contentPollers, (contentPoller) => {
            contentPoller.resetSleepTimer();
        });
    }
}
exports.Contentful = Contentful;
//# sourceMappingURL=contentful.js.map