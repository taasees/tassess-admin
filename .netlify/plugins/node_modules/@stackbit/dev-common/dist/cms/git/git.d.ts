export = Git;
declare class Git {
    constructor(options: any);
    logger: any;
    userLogger: any;
    originalSchema: any;
    schema: any;
    data: any[] | null;
    encoderDelegate: cmsGit.EncoderDelegate | null;
    encodingResult: any;
    schemaLoadingErrors: Error[] | null;
    contentLoadingErrors: any[] | null;
    ssgType: any;
    appDir: any;
    rootDir: any;
    repoDir: any;
    repoBranch: any;
    repoPublishBranch: any;
    projectId: any;
    projectUrl: string | null;
    stackbitConfig: any;
    contentDirs: any;
    encodeDelimiter: any;
    beforeContentUpdate: any;
    onContentUpdate: any;
    commitAndPushChanges: any;
    assetIdPrefix: any;
    staticAssetsFilePath: any;
    staticAssetsPublicPath: any;
    staticThemeAssetsFilePath: any;
    staticThemeAssetsPublicPath: any;
    defaultContentTypeExtensions: any;
    gitWorker: any;
    debug(message: any, data: any): void;
    error(message: any, data: any): void;
    run(): Promise<void>;
    restart(): Promise<void>;
    getEncodingResult(): any;
    getSchemaKey(): string;
    getEnvironmentForProjectId(projectId: any): any;
    getModelsForProjectId(projectId: any): any;
    getMappedModels(): {
        [x: number]: _.Dictionary<any>;
    };
    getPresets(): any;
    getCmsContentHandler(): typeof cmsGit;
    fetchSchema(): Promise<void>;
    assetsManager: GitBasedAssetsManager | null | undefined;
    fetchSchemaAndReport(): Promise<void>;
    fetchDataAndUpdate(): Promise<void>;
    loadData(): Promise<any[]>;
    writeData(data: any, dir: any): Promise<boolean>;
    deleteFile(path: any): Promise<void>;
    encodeData(data: any, initial?: boolean): any;
    prepareObjectValues(object: any): any;
    createObject({ modelName, fields, pageModel, object, filePath, user }: {
        modelName: any;
        fields: any;
        pageModel: any;
        object: any;
        filePath: any;
        user: any;
    }): Promise<any>;
    duplicateObject({ pageId, srcProjectId, fields, pageModel }: {
        pageId: any;
        srcProjectId: any;
        fields: any;
        pageModel: any;
    }): Promise<any>;
    deleteObject(objectId: any, user: any): Promise<any>;
    getUpdateMessage(object: any, newObject: any): string;
    encodeWriteAndCommitObject(object: any, changeLog: any, user: any, writeAdditionalData: any): any;
    encodeDeleteAndCommitObject(deletedFiles: any, changeLog: any, user: any, writeAdditionalData: any): any;
    /**
     * This method is called after pulling appDir.
     *
     * If updatedFiles include code files that are not schema neither content files, copy them to IM
     * If updatedFiles include schema files, re-fetch the schema
     * If updatedFiles include content files, reload all data, encode, and save it to IM
     *
     * @param {Array<string>} updatedFiles Array of changed file paths relative to appDir
     */
    postPull(updatedFiles: Array<string>): Promise<{
        schemaChanged?: undefined;
        updatedCodeFiles?: undefined;
    } | {
        schemaChanged: boolean;
        updatedCodeFiles: never[] | [string, ...string[]];
    }>;
    /**
     * Interface method. Called after site was pulled.
     * Override and return true if the filePath is responsible for site schema.
     * Returning true will re-fetch the schema.
     *
     * @param {string} filePath File path relative to appDir
     * @return {boolean}
     */
    isSchemaFile(filePath: string): boolean;
    isAssetFile(filePath: any): boolean;
    addMetadata(object: any, model: any, filePath: any, existingObject: any): Object | any[];
    updateAssetLinks(object: any): any;
    getLocalizedFieldData(): any;
    getObject(objectId: any, projectId: any): any;
    getObjectIndex(objectId: any, projectId: any): number;
    getModelByModelName(modelName: any): any;
    listAssets(filter: any): Promise<{
        assets: {
            objectId: string;
            fileName: string;
            url: any;
            size: any;
            createdAt: any;
        }[];
        meta: {
            totalPages: number;
        };
    }>;
    uploadAsset({ url, fileName, data, user }: {
        url: any;
        fileName: any;
        data: any;
        user: any;
    }): Promise<{
        objectId: string;
        fileName: string;
        url: any;
        size: any;
        createdAt: any;
    }>;
    uploadAssets(assets: any, user: any): Promise<any[]>;
    getPageUrlFromObjectId(objectId: any, pageModel: any, pagesDir: any): string;
    updateSingleObject(object: any, newObject: any, user: any): Promise<any>;
    updateObject(changedFields: any, user: any): Promise<any[]>;
    updateObject_api(objectId: any, projectId: any, object: any, user: any): Promise<any>;
    modifyItem({ object, field, schema }: {
        object: any;
        field: any;
        schema: any;
    }): any;
    modifyList({ object, fieldModel, fieldPath, field, schema }: {
        object: any;
        fieldModel: any;
        fieldPath: any;
        field: any;
        schema: any;
    }): Promise<any> | undefined;
}
import cmsGit_1 = require("@stackbit/cms-git");
import cmsGit = cmsGit_1.default;
import _ = require("lodash");
import { GitBasedAssetsManager } from "./git-based-assets-manager";
//# sourceMappingURL=git.d.ts.map