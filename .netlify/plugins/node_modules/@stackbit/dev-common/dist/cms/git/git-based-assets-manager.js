"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fse = require('fs-extra');
const axios = require('axios');
const fileType = require('file-type');
const path = require('path');
const sanitizeFilename = require('sanitize-filename');
const nameGenerator = require('@stackbit/artisanal-names');
const _ = require('lodash');
const { Readable } = require('stream');
const cmsUtils = require('@stackbit/cms-core/dist/utils');
const { readDirRecursively, processMarkdownImagePaths, randomString } = require('../../utils/code-utils');
// const { getAssetTimestamps } = require('../utils/git-utils');
module.exports.GitBasedAssetsManager = class GitBasedAssetsManager {
    constructor(options) {
        this.rootDir = options.rootDir;
        this.appDir = options.appDir;
        this.writer = options.writer;
        this.assetIdPrefix = options.assetIdPrefix;
        this.staticAssetsFilePath = path.join(this.rootDir, options.staticAssetsFilePath);
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.assetsDir = null;
        this.staticDir = null;
        this.uploadDir = '';
        this.publicPath = '';
        this.referenceType = 'static';
        this.maxImageSize = options.maxImageSize || 20 * 1000 * 1000;
        this.assetExtensions = ['png', 'jpg', 'jpeg', 'gif', 'svg', 'ico', 'webp', 'avif', 'tiff', 'bmp'];
    }
    async copyAssets() {
        const assetsDir = this.getAssetsDir();
        const assetFiles = await this.listAssetFiles(assetsDir);
        await fse.remove(this.staticAssetsFilePath);
        await Promise.all(_.map(assetFiles, async ({ filePath }) => {
            await this.copyAssetToStaticFolder(filePath, assetsDir, this.staticAssetsFilePath);
            // TODO: resize and optimize files inside static/app-assets,
            //  as they are only needed by the studio
        }));
    }
    async copyAssetToStaticFolder(filePath, relativeDir, staticAssetsFilePath) {
        const relFilePath = path.relative(relativeDir, filePath);
        const staticFilePath = path.join(staticAssetsFilePath, relFilePath);
        await fse.copy(filePath, staticFilePath);
    }
    async listAssetFiles(assetsDir) {
        // todo: timestamps logic is very slow. don't use it until a better solution is found
        // const fileTimestamps = await getAssetTimestamps(assetsDir);
        const fileTimestamps = {};
        return readDirRecursively(assetsDir, {
            filter: (filePath, stats) => {
                if (stats.isFile()) {
                    const extension = path.extname(filePath).substring(1);
                    return this.assetExtensions.includes(extension);
                }
                return true;
            }
        }).then((files) => {
            return files.map((file) => {
                file.createdAt = _.has(fileTimestamps, file.filePath) ? fileTimestamps[file.filePath] : file.stats.birthtime;
                return file;
            });
        });
    }
    getAssetsDir() {
        const assetsDir = this.referenceType === 'static' ? this.staticDir : this.assetsDir;
        return path.join(this.appDir, assetsDir);
    }
    getUploadDir() {
        const assetsDir = this.referenceType === 'static' ? this.staticDir : this.assetsDir;
        return path.join(this.appDir, assetsDir, this.uploadDir);
    }
    getPublicUrlPath(filePath) {
        const assetsDir = this.getAssetsDir();
        const relativePath = path.relative(assetsDir, filePath);
        return cmsUtils.convertToPosixFilePath(path.join(this.staticAssetsPublicPath, relativePath));
    }
    getAssetId(filePath) {
        // objectId is asset's file path relative to project root
        const relFilePath = path.relative(this.appDir, filePath);
        return `${this.assetIdPrefix}:${this.referenceType}:${relFilePath}`;
    }
    getAssetFilePath(assetId) {
        const [idPrefix, referenceType, ...relFilePath] = assetId.split(':');
        return _.join(relFilePath, '');
    }
    isPrefixedAssetId(assetId) {
        return _.isString(assetId) && _.startsWith(assetId, this.assetIdPrefix + ':');
    }
    relativeFilePathFromPrefixedAssetId(assetId, filePath) {
        const [, assetReferenceType, ...assetRelFilePathParts] = _.split(assetId, ':');
        const cleanAssetId = _.join(assetRelFilePathParts, '');
        if (assetReferenceType === 'static') {
            const staticDir = _.trim(this.staticDir, '/');
            return path.join(this.publicPath, path.relative(staticDir, cleanAssetId));
        }
        else {
            const fileDir = path.dirname(filePath);
            return path.relative(fileDir, cleanAssetId);
        }
    }
    replaceAssetLinks(value, objectId) {
        if (this.isPrefixedAssetId(value)) {
            return this.relativeFilePathFromPrefixedAssetId(value, objectId);
        }
        return processMarkdownImagePaths(value, (path) => {
            if (this.isPrefixedAssetId(path)) {
                return this.relativeFilePathFromPrefixedAssetId(path, objectId);
            }
            return path;
        });
    }
    async uploadFileTo(url, filePath, data) {
        let readStream;
        if (data) {
            const relevantData = data.split(';base64,');
            const buffer = Buffer.from(relevantData.slice(-1)[0], 'base64');
            readStream = Readable.from(buffer);
        }
        else {
            const response = await axios({
                responseType: 'stream',
                url
            });
            readStream = response.data;
        }
        fse.ensureDir(path.dirname(filePath));
        const writeStream = fse.createWriteStream(filePath);
        readStream.pipe(writeStream);
        await new Promise((resolve, reject) => {
            writeStream.on('error', reject).on('finish', resolve);
        });
        const stats = await fse.stat(filePath);
        return this.normalizeAssetForResponse(filePath, stats);
    }
    async upload(url, filename, data, user) {
        let readStream;
        if (data) {
            const relevantData = data.split(';base64,');
            const buffer = Buffer.from(relevantData.slice(-1)[0], 'base64');
            readStream = Readable.from(buffer);
        }
        else {
            const response = await axios({
                responseType: 'stream',
                url
            });
            const totalLength = response.headers['content-length'];
            if (totalLength > this.maxImageSize) {
                throw new Error(`Image size ${totalLength} exceed max size ${this.maxImageSize}`);
            }
            readStream = await fileType.stream(response.data);
        }
        const fileTypeStream = await fileType.stream(readStream);
        const fileExt = path.extname(filename).slice(1) || fileTypeStream.fileType.ext;
        if (filename) {
            filename = path.basename(filename, `.${fileExt}`);
            filename = sanitizeFilename(filename);
        }
        else {
            filename = nameGenerator.generate();
        }
        const uploadDir = this.getUploadDir();
        const assetsDir = this.getAssetsDir();
        const filePath = await this.getUniqueFilePath(filename, fileExt, uploadDir);
        fse.ensureDir(path.dirname(filePath));
        const writeStream = fse.createWriteStream(filePath);
        fileTypeStream.pipe(writeStream);
        await new Promise((resolve, reject) => {
            writeStream.on('error', reject).on('finish', resolve);
        });
        const stats = await fse.stat(filePath);
        await this.copyAssetToStaticFolder(filePath, assetsDir, this.staticAssetsFilePath);
        return this.normalizeAssetForResponse(filePath, stats);
    }
    normalizeAssetForResponse(filePath, stats) {
        const objectId = this.getAssetId(filePath);
        const url = this.getPublicUrlPath(filePath);
        const fileName = path.basename(filePath);
        return {
            objectId,
            fileName,
            url,
            size: stats.size,
            createdAt: stats.birthtime
        };
    }
    async getUniqueFilePath(baseName, ext, uploadDir, { randStr, retry = 2 } = {}) {
        const fileName = randStr ? `${baseName}-${randStr}.${ext}` : `${baseName}.${ext}`;
        const filePath = path.join(uploadDir, fileName);
        const exists = await fse.pathExists(filePath);
        if (exists) {
            if (retry) {
                return this.getUniqueFilePath(baseName, ext, uploadDir, { randStr: randomString(), retry: retry - 1 });
            }
            else {
                throw new Error(`Filename '${baseName}.${ext} already exists.'`);
            }
        }
        return filePath;
    }
    async list(filter) {
        const searchQuery = sanitizeFilename(_.get(filter, 'searchQuery', '')).toLowerCase();
        const pageSize = _.get(filter, 'pageSize', 20);
        const pageId = _.get(filter, 'pageId', 1);
        const assetsDir = this.getAssetsDir();
        const files = await this.listAssetFiles(assetsDir);
        const filteredFiles = searchQuery ? files.filter((file) => path.basename(file.filePath).toLowerCase().includes(searchQuery)) : files;
        const sortedFiles = _.orderBy(filteredFiles, ['filePath'], ['asc']);
        const skip = ((pageId || 1) - 1) * pageSize;
        const resultFiles = sortedFiles.slice(skip, skip + pageSize).map((file) => this.normalizeAssetForResponse(file.filePath, file.stats));
        return {
            assets: resultFiles,
            meta: {
                totalPages: Math.ceil(filteredFiles.length / pageSize)
            }
        };
    }
};
//# sourceMappingURL=git-based-assets-manager.js.map