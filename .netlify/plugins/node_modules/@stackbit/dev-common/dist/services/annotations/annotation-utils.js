"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require('lodash');
/**
 * This method translates fieldPath (object.sections[0].title) to fieldDataPath (object.fields.sections.items[0].fields.title)
 * It follows references, and returns both the fieldDataPath from the nearest object that has an ID, but also the fieldDataPath from the original passed object
 *
 * FieldDataPathsFromRoot contains fieldPaths to current fieldPathStr from every object in the reference chain.
 * example: Oid1.fields.sections.items.1.fields.features.items.0.fields.featureTitle
 *                                  Oid2.fields.features.items.0.fields.featureTitle
 *                                                          Oid3.fields.featureTitle
 * all three fieldpaths are required to resolve every object in the reference chain
 * @param objectId
 * @param fieldPathStr
 * @param fieldData
 * @returns {{fieldDataPathsFromRoot: string[], fieldDataPath: string}|{}}
 */
function fieldPathToFieldDataPath(objectId, fieldPathStr, getObjectById) {
    const fieldPath = _.toPath(fieldPathStr);
    let nextField = getObjectById(objectId);
    let fieldDataPath = [objectId];
    const fieldDataPathFromRoot = [objectId];
    const fieldDataPathsFromRootIndexes = [{ index: 0, objectId: objectId }];
    while (fieldPath.length) {
        const nextPath = fieldPath.shift();
        if (!nextField) {
            return {};
        }
        if (nextField.type === 'object') {
            fieldDataPath.push('fields', nextPath);
            fieldDataPathFromRoot.push('fields', nextPath);
            nextField = _.get(nextField, ['fields', nextPath]);
        }
        else if (nextField.type === 'list') {
            fieldDataPath.push('items', parseInt(nextPath, 10));
            fieldDataPathFromRoot.push('items', parseInt(nextPath, 10));
            nextField = _.get(nextField, ['items', nextPath]);
        }
        else if (nextField.type === 'unresolved_reference' || nextField.type === 'cross-reference') {
            // found reference, change objectId to new object and reset fieldDataPath
            // TODO: for cross-references update the fieldData to have more nesting levels by srcType and srcProjectId
            //  and use refSrcType and refProjectId to correctly find document
            const nextObjectId = nextField.refId;
            fieldDataPath = [nextObjectId, 'fields', nextPath];
            fieldDataPathsFromRootIndexes.push({ index: fieldDataPathFromRoot.length - 1, objectId: nextField.refId });
            fieldDataPathFromRoot.push('fields', nextPath);
            nextField = _.get(getObjectById(nextObjectId), ['fields', nextPath]);
        }
        else if (nextField.type === 'image') {
            fieldDataPath.push('fields', nextPath);
            fieldDataPathFromRoot.push('fields', nextPath);
            nextField = _.get(nextField, ['fields', nextPath]);
        }
    }
    if (!nextField) {
        return {};
    }
    if (nextField.type === 'unresolved_reference' || nextField.type === 'cross-reference') {
        fieldDataPath = [nextField.refId];
    }
    // replace reference fields by their Ids and add to fieldDataPathsFromRoot
    //  fieldDataPathFromRoot (obj1.fields.ref2.fields.ref3.fields.name)
    //  =>
    //  fieldDataPathsFromRoot [
    //      obj1.fields.ref2.fields.ref3.fields.name,
    //      obj2.fields.ref3.fields.name,
    //      obj3.fields.name
    //  ]
    const fieldDataPathsFromRoot = fieldDataPathsFromRootIndexes.map(({ index, objectId }) => fieldPathToString([objectId, ...fieldDataPathFromRoot.slice(index + 1)]));
    return { fieldDataPath, fieldDataPathStr: fieldPathToString(fieldDataPath), fieldDataPathsFromRoot };
}
/**
 * This converts a fieldPath array to a string, it puts complex strings inside single quotes '', and uses square brackets [] for number keys.
 * @param fieldPath
 * @returns {*}
 */
function fieldPathToString(fieldPath) {
    return _.reduce(fieldPath, (accumulator, fieldName, index) => {
        if (_.isString(fieldName) && /\W/.test(fieldName)) {
            // field name is a string with non alphanumeric character
            accumulator += `['${fieldName}']`;
        }
        else if (_.isNumber(fieldName)) {
            accumulator += `[${fieldName}]`;
        }
        else {
            if (index > 0) {
                accumulator += '.';
            }
            accumulator += fieldName;
        }
        return accumulator;
    }, '');
}
function appendOrArray(object, path, item) {
    _.set(object, path, [..._.get(object, path, []), item]);
}
module.exports = {
    fieldPathToFieldDataPath,
    fieldPathToString,
    appendOrArray
};
//# sourceMappingURL=annotation-utils.js.map