"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeShellValue = exports.randomString = exports.processMarkdownImagePaths = exports.withRetry = exports.delayPromise = exports.obfuscateString = exports.rename = exports.convertToRegularTokens = exports.extractTokensFromString = exports.interpolateUrlPathFromData = exports.getPageUrlPathFromFilePath = exports.interpolatePageUrlFromFilePath = exports.readDirRecursively = exports.deferredPromise = exports.difference = exports.pathDifferences = exports.decodeEnvVar = exports.forEachPromise = exports.findParentArray = exports.findIndexes = exports.forEachField = exports.deepMap = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const moment_1 = __importDefault(require("moment"));
const slugify_1 = __importDefault(require("slugify"));
const lodash_1 = __importDefault(require("lodash"));
const crypto_1 = __importDefault(require("crypto"));
const cms_core_1 = require("@stackbit/cms-core");
const momentFormatRe = /moment_format\(\s*(?:(?<param>.+?)\s*,\s*)?['"](?<format>[^'"]+)['"]\s*\)/;
const momentFormatEscapedRe = /moment_format\\\(\s*(?:(?<param>.+?)\s*,\s*)?['"](?<format>[^'"]+)['"]\s*\\\)/;
const momentDateToken = 'moment_date';
var utils_1 = require("@stackbit/utils");
Object.defineProperty(exports, "deepMap", { enumerable: true, get: function () { return utils_1.deepMap; } });
function forEachField(object, iteratee, options) {
    const context = lodash_1.default.get(options, 'context');
    const includeKeyPath = lodash_1.default.get(options, 'includeKeyPath', true);
    function _walkDeep(value, keyPath) {
        iteratee.call(context, value, keyPath);
        if (value.type === 'object') {
            lodash_1.default.forEach(value.fields, (val, key) => {
                return _walkDeep(val, includeKeyPath ? lodash_1.default.concat(keyPath, ['fields', key]) : null);
            });
        }
        else if (value.type === 'list') {
            lodash_1.default.forEach(value.items, (val, key) => {
                return _walkDeep(val, includeKeyPath ? lodash_1.default.concat(keyPath, ['items', key]) : null);
            });
        }
    }
    return _walkDeep(object, [object.srcObjectId]);
}
exports.forEachField = forEachField;
function findIndexes(array, cb, findFirst) {
    const indexes = [];
    lodash_1.default.forEach(array, (el, ix) => {
        if (cb(el)) {
            indexes.push(ix);
            if (findFirst) {
                return false;
            }
        }
    });
    return indexes;
}
exports.findIndexes = findIndexes;
function findParentArray(obj, keyPath, targetKeyPath = []) {
    if (keyPath.length === 0) {
        return;
    }
    const value = lodash_1.default.get(obj, keyPath.join('.'));
    if (lodash_1.default.isUndefined(value)) {
        return;
    }
    if (Array.isArray(value)) {
        return { arr: value, targetKeyPath, keyPath };
    }
    targetKeyPath.unshift(lodash_1.default.last(keyPath));
    return findParentArray(obj, keyPath.slice(0, -1), targetKeyPath);
}
exports.findParentArray = findParentArray;
/**
 * Iterates over array items and invokes callback function for each of them.
 * The callback must return a promise and is called with three parameters: array item,
 * item index, array itself. Callbacks are invoked serially, such that callback for the
 * following item will not be called until the promise returned from the previous callback
 * is not fulfilled.
 *
 * @param {array} array
 * @param {function} callback
 * @param {object} [thisArg]
 * @return {Promise<any>}
 */
function forEachPromise(array, callback, thisArg) {
    return new Promise((resolve, reject) => {
        const results = [];
        function next(index) {
            if (index < array.length) {
                callback
                    .call(thisArg, array[index], index, array)
                    .then((result) => {
                    results[index] = result;
                    next(index + 1);
                })
                    .catch((error) => {
                    reject(error);
                });
            }
            else {
                resolve(results);
            }
        }
        next(0);
    });
}
exports.forEachPromise = forEachPromise;
function decodeEnvVar(dataString) {
    const data = JSON.parse(dataString);
    return lodash_1.default.mapValues(data, (val) => (lodash_1.default.isObject(val) ? JSON.stringify(val) : val));
}
exports.decodeEnvVar = decodeEnvVar;
function pathDifferences(a, b) {
    function diff(a, b, result, path = '') {
        if (lodash_1.default.isEqual(a, b)) {
            return;
        }
        if (typeof a !== typeof b) {
            result.push(path);
        }
        else if (lodash_1.default.isArray(a)) {
            if (a.length !== b.length) {
                result.push(path);
            }
            (a.length < b.length ? a : b).forEach((val, i) => {
                if (!lodash_1.default.isEqual(a[i], b[i]) && a.find((item) => lodash_1.default.isEqual(item, b[i])) && b.find((item) => lodash_1.default.isEqual(item, a[i]))) {
                    // handle reordering
                    if (!result.includes(path)) {
                        result.push(path);
                    }
                }
                else {
                    diff(a[i], b[i], result, `${path}.${i}`);
                }
            });
        }
        else if (lodash_1.default.isObjectLike(a) && lodash_1.default.isObjectLike(b)) {
            const keys = Object.keys(a);
            const changedKeys = lodash_1.default.xor(keys, Object.keys(b));
            changedKeys.forEach((key) => {
                result.push(lodash_1.default.isEmpty(path) ? key : `${path}.${key}`);
            });
            keys.forEach((key) => {
                if (changedKeys.includes(key)) {
                    return;
                }
                diff(a[key], b[key], result, lodash_1.default.isEmpty(path) ? key : `${path}.${key}`);
            });
        }
        else {
            result.push(path);
        }
    }
    const result = [];
    diff(a, b, result);
    return result;
}
exports.pathDifferences = pathDifferences;
/**
 * Get array of difference properties between passed a and b objects
 * @param {Object} a
 * @param {Object} b
 * @returns {Array<String>} changed properties
 */
function difference(a, b) {
    const aKeys = Object.keys(a);
    const changedKeys = lodash_1.default.xor(aKeys, Object.keys(b));
    if (changedKeys.length) {
        return changedKeys;
    }
    return lodash_1.default.reduce(aKeys, (res, aKey) => {
        if (!lodash_1.default.isEqual(a[aKey], b[aKey])) {
            res.push(aKey);
        }
        return res;
    }, []);
}
exports.difference = difference;
function deferredPromise() {
    let _resolve;
    let _reject;
    const promise = new Promise((resolve, reject) => {
        _resolve = resolve;
        _reject = reject;
    });
    // The executor function is called before the Promise constructor returns:
    // https://262.ecma-international.org/6.0/#sec-promise-executor
    // so it is safe to use Non-null Assertion Operator "!"
    return {
        promise: promise,
        resolve: _resolve,
        reject: _reject
    };
}
exports.deferredPromise = deferredPromise;
async function readDirRecursively(dir, options = {}) {
    const dirExists = await fs_extra_1.default.pathExists(dir);
    if (!dirExists) {
        return [];
    }
    const rootDir = lodash_1.default.get(options, 'rootDir', dir);
    const files = await fs_extra_1.default.readdir(dir);
    const promises = lodash_1.default.map(files, async (file) => {
        const absFilePath = path_1.default.join(dir, file);
        const stats = await fs_extra_1.default.stat(absFilePath);
        const filePath = options.relativeFilePaths ? path_1.default.relative(rootDir, absFilePath) : absFilePath;
        if (options.filter && !options.filter(filePath, stats)) {
            return null;
        }
        if (stats.isDirectory()) {
            return readDirRecursively(absFilePath, Object.assign({ rootDir }, options));
        }
        else if (stats.isFile()) {
            return { filePath, stats };
        }
        else {
            return null;
        }
    });
    const recFiles = await Promise.all(promises);
    return lodash_1.default.chain(recFiles).compact().flatten().value();
}
exports.readDirRecursively = readDirRecursively;
/**
 * Interpolates page url from file path.
 *
 * This function is useful for git-based CMS projects where page URL depends on
 * the physical file path of the page.
 *
 * @param {string} pageFilePath The file path of the page relative to project root
 * @param {Object} pageModel The computed pageModel of the page
 * @param {Object} pageData The fields of the page object
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The url of the page
 */
function interpolatePageUrlFromFilePath({ pageFilePath, pageModel, pageData, pagesDir, logger }) {
    const urlPath = pageModel.urlPath;
    // if page's model does not have a 'urlPath' infer the url by getting the relative path between pagesDir and pagePath
    if (!urlPath) {
        return getPageUrlPathFromFilePath(pageFilePath, pagesDir);
    }
    // if page's model defines a 'urlPath', extract tokens and their values from pageModel's filePath
    // and page's physical file path, and interpolate the URL by applying extracted tokens to page pageModel.urlPath.
    // Example 1:
    // In the simple case, the 'urlPath' is '{slug}', and 'filePath' is not defined, the extracted slug would be the file name:
    // urlPath: /posts/{slug}
    // filePath: src/pages/posts/{slug}.md
    // page file: src/pages/posts/hello.md
    // tokens: {slug: 'hello'}
    // interpolated urlPath: /posts/hello
    // Example 2:
    // In more advanced case, the 'filePath' could be different than `urlPath` (e.g.: Jekyll posts),
    // additionally, the date in the filePath can be formatted differently than in the urlPath.
    // In this case, tokens are extracted from filepath and used to interpolate page url.
    // urlPath: /posts/{moment_format(date, "YYYY")}/{slug}
    // filePath: _posts/{moment_format(date, "YYYY-MM-DD")}-{slug}.md
    // actual file: _posts/2020-11-04-hello.md
    // tokens: { slug: 'hello', date: new Date('2020-11-04') }
    // interpolated urlPath: /posts/2020/hello
    let data = pageData;
    if (typeof pageModel.filePath === 'string') {
        const filePathPattern = convertToRegularTokens(cms_core_1.utils.convertToPosixFilePath(pageModel.filePath));
        const tokens = extractTokensAndValuesFromFilePath(pageFilePath, filePathPattern);
        data = lodash_1.default.assign(tokens, pageData);
    }
    try {
        return interpolateUrlPathFromData(urlPath, data);
    }
    catch (error) {
        logger?.error(error.message +
            `This may be due to the token missing from the data stored in the "${pageFilePath}" file, ` +
            'or the token could not be extracted from the file path using the ' +
            `"${typeof pageModel.filePath === 'function' ? 'Function' : pageModel.filePath}". ` +
            'provided in the model.filePath. To resolve this issue, use the "siteMap" function ' +
            'to specify the URL paths of pages, or provide a tokenized string for "model.filePath" ' +
            'to allow Stackbit to extract tokens from existing files and use them to interpolate the "model.urlPath"');
        return getPageUrlPathFromFilePath(pageFilePath, pagesDir);
    }
}
exports.interpolatePageUrlFromFilePath = interpolatePageUrlFromFilePath;
/**
 * Computes page url from page's file path.
 * Use this method only when page model urlPath is not defined.
 *
 * @example
 * getPageUrlPathFromFilePath('src/pages/blog/my-blog-post.md', 'src/pages') => blog/my-blog-post
 * getPageUrlPathFromFilePath('content/about.md', 'content') => about
 * getPageUrlPathFromFilePath('projects/index.md', '') => projects
 *
 * @param {string} filePath The file path of the page relative to project root
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The inferred url of the page
 */
function getPageUrlPathFromFilePath(filePath, pagesDir) {
    const relativePath = path_1.default.relative(pagesDir, filePath);
    const pathObject = path_1.default.parse(relativePath);
    const urlPath = path_1.default.join(pathObject.dir, pathObject.name);
    return trimUrlPathIndex(urlPath);
}
exports.getPageUrlPathFromFilePath = getPageUrlPathFromFilePath;
/**
 * Extract tokens and their values from filePath based on the filePathPattern.
 *
 * @example
 * extractTokensAndValuesFromFilePath(
 *   '_posts/2020-09-20-hello.md',
 *   '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md'
 * ) => { moment_date: '2020-09-20', slug: 'hello' }
 *
 * @param {string} filePath
 * @param {string} filePathPattern
 * @return {Object} Object with extracted tokens and their values
 */
function extractTokensAndValuesFromFilePath(filePath, filePathPattern) {
    // filePath: '_posts/2020-11-04-hello.md'
    // filePathPattern: '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md'
    const usedTokens = {};
    const regExpStr = filePathPattern
        // escape characters that may conflict with regular expression
        .replace(/[\\.*+\-?^$|()[\]]/g, '\\$&')
        // replace tokens with named capturing group: (?<token>x)
        .replace(/{([^}]+)}(\/?)/g, (match, tokenName, slashAfter, offset) => {
        const momentFormatMatch = tokenName.match(momentFormatEscapedRe);
        if (momentFormatMatch) {
            // for now use naive approach, assume moment's basic format tokens D, DD, M, MM, YY, YYYY, H, HH, m, mm (everything else will fail)
            const dateRe = momentFormatMatch.groups.format.replace(/[MYDHm]+/g, '\\d+');
            const dateToken = momentFormatMatch.groups.param || momentDateToken;
            return `(?<${dateToken}>${dateRe})${slashAfter}`;
        }
        // if token was used, assume it has the same value
        // _posts/{slug}/{moment_format("YYYY-MM-DD")}-{slug}.md
        // _posts/welcome-to-jekyll/2020-08-29-welcome-to-jekyll.md
        if (lodash_1.default.has(usedTokens, tokenName)) {
            return `(?:.+?)${slashAfter}`;
        }
        usedTokens[tokenName] = true;
        // if token is left and right bounded by slashes or the beginning
        // of the string: /pages/{slug}/index.md, then generate regular
        // expression that puts the whole token with the following slash
        // as an optional match: /\/pages\/(?:(?<slug>.+?)/)?\/index.md/
        // Such that the following file path will match '/pages/index.md'
        // this regular expression and produce a match with 'undefined' slug
        // named capturing group which will be converted to an empty string.
        const tokenLeftBounded = offset === 0 || filePathPattern[offset - 1] === '/';
        const tokenRightBounded = slashAfter === '/';
        if (tokenLeftBounded && tokenRightBounded) {
            return `(?:(?<${tokenName}>.+?)/)?`;
        }
        return `(?<${tokenName}>.+?)${slashAfter}`;
    });
    // regExpStr = '_posts/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md'
    const regExp = new RegExp(regExpStr);
    // regExp = /_posts\/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md/
    const match = regExp.exec(filePath);
    // match.groups = {slug: 'hello', moment_date: <DateString>}
    return lodash_1.default.mapValues(match?.groups, (value) => (typeof value === 'undefined' ? '' : value));
}
/**
 * Interpolates url path pattern from data.
 * If token does not exist in data returns original token.
 * When 'moment_format' function does not specify the 'date' parameter, the data should include 'moment_date' field.
 * This is useful when interpolating urls with date tokens based on the dates extracted from physical files.
 *
 * @example
 * interpolateUrlPathFromData('posts/{slug}', { slug: 'hello' })
 * => 'posts/hello'
 *
 * interpolateUrlPathFromData('posts/{moment_format(date, "YYYY-MM-DD")}-{slug}', {
 *   slug: 'hello',
 *   date: new Date('2020-10-10')
 * })
 * => 'posts/2020-10-10-hello'
 *
 * @param urlPath
 * @param data
 * @return {*}
 */
function interpolateUrlPathFromData(urlPath, data) {
    let interpolatedUrlPath = urlPath.replace(/{([^}]+)}/g, (match, tokenName) => {
        const momentFormatMatch = tokenName.match(momentFormatRe);
        if (momentFormatMatch) {
            const date = lodash_1.default.get(data, momentFormatMatch.groups.param || momentDateToken);
            if (!date) {
                throw new Error(`Could not interpolate token "${tokenName}" in model.urlPath: "${urlPath}".`);
            }
            return (0, moment_1.default)(date).format(momentFormatMatch.groups.format);
        }
        const value = lodash_1.default.get(data, tokenName);
        if (lodash_1.default.isNil(value)) {
            throw new Error(`Could not interpolate token "${tokenName}" in model.urlPath: "${urlPath}".`);
        }
        return value;
    });
    interpolatedUrlPath = interpolatedUrlPath
        .replace(/\/+/g, '/')
        .split('/')
        .map((part) => (0, slugify_1.default)(part, { lower: true }))
        .join('/');
    return trimUrlPathIndex(interpolatedUrlPath);
}
exports.interpolateUrlPathFromData = interpolateUrlPathFromData;
function trimUrlPathIndex(urlPath) {
    const urlParts = lodash_1.default.split(urlPath, '/');
    if (['index', '_index'].includes(lodash_1.default.last(urlParts))) {
        urlParts.pop();
    }
    return urlParts.join('/');
}
function extractTokensFromString(input) {
    const tokens = input.match(/(?<={)[^}]+(?=})/g) || [];
    return lodash_1.default.chain(tokens)
        .map((token) => {
        const momentFormatMatch = token.match(momentFormatRe);
        if (momentFormatMatch) {
            return momentFormatMatch.groups.param || null;
        }
        return token;
    })
        .compact()
        .value();
}
exports.extractTokensFromString = extractTokensFromString;
function convertToRegularTokens(input) {
    return input.replace(/%([^%]+)%/g, (match, tokenName) => `{${tokenName}}`);
}
exports.convertToRegularTokens = convertToRegularTokens;
function rename(object, oldPath, newPath) {
    if (lodash_1.default.has(object, oldPath)) {
        lodash_1.default.set(object, newPath, lodash_1.default.get(object, oldPath));
        oldPath = lodash_1.default.toPath(oldPath);
        if (oldPath.length > 1) {
            object = lodash_1.default.get(object, lodash_1.default.initial(oldPath));
        }
        delete object[lodash_1.default.last(oldPath)];
    }
}
exports.rename = rename;
function obfuscateString(str, { showFirst = 3, showLast = 3 } = {}) {
    if (lodash_1.default.isString(str)) {
        if (str.length > (showFirst + showLast) * 3) {
            str = str.slice(0, showFirst) + '...' + str.slice(str.length - showLast);
        }
        else if (str.length > showFirst * 3) {
            str = str.slice(0, showFirst) + '...';
        }
        else {
            str = '***';
        }
    }
    return str;
}
exports.obfuscateString = obfuscateString;
function delayPromise(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
}
exports.delayPromise = delayPromise;
function withRetry(f, logger, maxRetry = 2, retryDelay = 0, retryCount = 0) {
    return f().catch((err) => {
        if (retryCount > maxRetry) {
            if (logger) {
                logger.error('[retry] reached max retry. failing...', { retryCount, maxRetry, err });
            }
            throw err;
        }
        if (logger) {
            logger.warn('[retry] retrying operation', { retryCount, maxRetry, err });
        }
        return delayPromise(retryDelay).then(() => withRetry(f, logger, maxRetry, retryDelay, retryCount + 1));
    });
}
exports.withRetry = withRetry;
/**
 * Finds an images in the markdown, calls handler with the image path as an argument and replaces
 * the image path within markdown with the returned value of the handler
 *
 * @param {string} markdown
 * @param {Function} handler
 * @returns {string}
 */
function processMarkdownImagePaths(markdown, handler) {
    const re = /(!\[[^\]]*])\(([^)\s]+?)(\s+"[^"]*")?\)/g;
    let reResult;
    let result = '';
    let lastIndex = 0;
    while ((reResult = re.exec(markdown)) !== null) {
        const altText = reResult[1];
        const path = handler(reResult[2]);
        const title = reResult[3] || '';
        result += markdown.substring(lastIndex, reResult.index);
        result += `${altText}(${path}${title})`;
        lastIndex = re.lastIndex;
    }
    result += markdown.substring(lastIndex);
    return result;
}
exports.processMarkdownImagePaths = processMarkdownImagePaths;
function randomString() {
    return crypto_1.default.randomBytes(4).toString('hex');
}
exports.randomString = randomString;
// taken from https://github.com/xxorax/node-shell-escape
function escapeShellValue(value) {
    if (!value || !/[^A-Za-z0-9_/:=-]/.test(value)) {
        return value;
    }
    return ("'" +
        value.replace(/'/g, "'\\''") +
        "'"
            .replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
            .replace(/\\'''/g, "\\'"));
}
exports.escapeShellValue = escapeShellValue;
//# sourceMappingURL=code-utils.js.map