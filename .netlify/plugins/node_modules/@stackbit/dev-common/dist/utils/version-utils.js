"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndLogContentSourceVersions = exports.checkAndLogNewerVersions = exports.getLocalStackbitPackageVersions = exports.getNewerVersionsForStackbitPackages = exports.getVersionsForStackbitPackages = void 0;
const lodash_1 = __importDefault(require("lodash"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const semver_1 = __importDefault(require("semver"));
const types_1 = require("@stackbit/types");
const containerPackages = ['@stackbit/dev-common', '@stackbit/cms-core'];
async function getVersionsForStackbitPackages(logger) {
    try {
        // we don't want to wait longer than 2 secs. for the versions to load
        const result = await axios_1.default.get('https://versions.stackbit.com/all.json', { timeout: 2000 });
        return result.data;
    }
    catch (err) {
        logger?.warn('Failed to load versions for Stackbit packages', { err });
        return {};
    }
}
exports.getVersionsForStackbitPackages = getVersionsForStackbitPackages;
async function getNewerVersionsForStackbitPackages(packageVersions, logger) {
    const result = {};
    const allVersions = await exports.getVersionsForStackbitPackages(logger);
    for (const [packageName, currentVersion] of Object.entries(packageVersions)) {
        let versions = allVersions[packageName];
        if (!versions) {
            continue;
        }
        const prereleaseVersion = semver_1.default.prerelease(currentVersion);
        if (prereleaseVersion) {
            // only consider prerelease version in the same prerelease tag
            versions = versions.filter((version) => !semver_1.default.prerelease(version) || semver_1.default.prerelease(version)[0] === prereleaseVersion[0]);
        }
        else {
            // only consider stable versions if current version isn't prerelease
            versions = versions.filter((version) => !semver_1.default.prerelease(version));
        }
        const newerVersions = lodash_1.default.uniq([
            semver_1.default.maxSatisfying(versions, `^${currentVersion}`, { includePrerelease: !!prereleaseVersion }),
            semver_1.default.maxSatisfying(versions, `>${currentVersion}`, { includePrerelease: !!prereleaseVersion }),
            semver_1.default.maxSatisfying(versions, `>${currentVersion}`) // largest available version
        ]
            .filter(Boolean)
            .filter((version) => version !== currentVersion));
        if (newerVersions.length) {
            result[packageName] = newerVersions;
        }
    }
    return result;
}
exports.getNewerVersionsForStackbitPackages = getNewerVersionsForStackbitPackages;
async function getLocalStackbitPackageVersions(dir) {
    const nodeModulesDir = path_1.default.join(dir, 'node_modules');
    if (!(await fs_extra_1.default.pathExists(nodeModulesDir))) {
        return {};
    }
    const packageJsonPath = path_1.default.join(dir, 'package.json');
    if (!(await fs_extra_1.default.pathExists(packageJsonPath))) {
        return {};
    }
    const packageJson = await fs_extra_1.default.readJson(packageJsonPath);
    const packageNames = lodash_1.default.uniq(Object.keys({ ...packageJson.dependencies, ...packageJson.devDependencies })).filter((packageName) => packageName.startsWith('@stackbit'));
    const result = {};
    for (const packageName of packageNames) {
        const packageJsonPath = path_1.default.join(nodeModulesDir, packageName, 'package.json');
        if (!(await fs_extra_1.default.pathExists(packageJsonPath))) {
            continue;
        }
        const packageJson = await fs_extra_1.default.readJson(packageJsonPath);
        if (packageJson.name && packageJson.version) {
            result[packageJson.name] = packageJson.version;
        }
    }
    return result;
}
exports.getLocalStackbitPackageVersions = getLocalStackbitPackageVersions;
async function checkAndLogNewerVersions({ dir, knownVersions, logger }) {
    const localVersions = await exports.getLocalStackbitPackageVersions(dir);
    const currentVersions = { ...knownVersions, ...localVersions };
    const newerVersions = await exports.getNewerVersionsForStackbitPackages(currentVersions, logger);
    const packagesWithNewerVersions = Object.keys(lodash_1.default.omit(newerVersions, containerPackages));
    if (packagesWithNewerVersions.length) {
        logger.info('ℹ️  Newer version(s) available for:');
    }
    for (let i = 0; i < packagesWithNewerVersions.length; i++) {
        const packageName = packagesWithNewerVersions[i];
        const versions = newerVersions[packageName];
        if (versions && versions.length > 0) {
            const connector = i === packagesWithNewerVersions.length - 1 ? '└──' : '├──';
            logger.info(`${connector} ${chalk_1.default.cyan(packageName)}: ${chalk_1.default.yellow(currentVersions[packageName])} → ${chalk_1.default.green(versions.join(', '))}`);
        }
    }
    const containerPackagesWithNewVersions = lodash_1.default.intersection(Object.keys(newerVersions), Object.keys(knownVersions), containerPackages);
    if (!lodash_1.default.isEmpty(containerPackagesWithNewVersions)) {
        // only display this message when running on container
        logger.info(`ℹ️  There is a new container version available${containerPackagesWithNewVersions.includes('stackbit/container') ? `: ${newerVersions['stackbit/container']}` : ''}.`);
    }
}
exports.checkAndLogNewerVersions = checkAndLogNewerVersions;
async function checkAndLogContentSourceVersions({ contentSources, isLocalDev, logger }) {
    const runningInterfaceVersion = await (0, types_1.getInterfaceVersion)();
    // log content sources and their versions
    const messageParts = [];
    let contentSourceMaxInterfaceVersion = null;
    for (const contentSource of contentSources) {
        const versions = await (lodash_1.default.invoke(contentSource, 'getVersion') || Promise.resolve());
        let part = `${contentSource.getContentSourceType()} (project: ${contentSource.getProjectId()}`;
        if (versions && versions.contentSourceVersion) {
            part += `, version: ${versions.contentSourceVersion}`;
        }
        part += ')';
        messageParts.push(part);
        if (versions &&
            versions.interfaceVersion &&
            (!contentSourceMaxInterfaceVersion || semver_1.default.gt(versions.interfaceVersion, contentSourceMaxInterfaceVersion))) {
            contentSourceMaxInterfaceVersion = versions.interfaceVersion;
        }
    }
    if (messageParts.length) {
        logger.info(`Content sources found: ${messageParts.join(', ')}`);
    }
    // check if content source interface versions are compatible with the running interface version
    if (contentSourceMaxInterfaceVersion &&
        semver_1.default.gt(contentSourceMaxInterfaceVersion, runningInterfaceVersion) &&
        ['major', 'premajor', 'minor', 'preminor'].includes(semver_1.default.diff(runningInterfaceVersion, contentSourceMaxInterfaceVersion) ?? '')) {
        const containingRuntime = isLocalDev ? 'Stackbit CLI' : 'Stackbit Container';
        logger.error(`Your local package versions are incompatible with this version of the ${containingRuntime}. Upgrade your ${containingRuntime} version or downgrade your local packages.`);
        logger.error(`${containingRuntime} is running interface v${runningInterfaceVersion}, but content sources are using v${contentSourceMaxInterfaceVersion}.`);
    }
}
exports.checkAndLogContentSourceVersions = checkAndLogContentSourceVersions;
//# sourceMappingURL=version-utils.js.map