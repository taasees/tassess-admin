/// <reference types="node" />
import { Stats } from 'fs';
import { KeyPath } from '@stackbit/utils';
import { Logger } from '@stackbit/types';
import { PageModel } from '../types';
export { deepMap, KeyPath } from '@stackbit/utils';
export declare function forEachField(object: any, iteratee: (value: any, keyPath: KeyPath | null) => void, options?: {
    context?: any;
    includeKeyPath?: boolean;
}): void;
export declare function findIndexes(array: any[], cb: (item: any) => boolean, findFirst: boolean): number[];
export declare function findParentArray(obj: any[], keyPath: KeyPath, targetKeyPath?: KeyPath): {
    arr: any[];
    targetKeyPath: KeyPath;
    keyPath: KeyPath;
} | undefined;
/**
 * Iterates over array items and invokes callback function for each of them.
 * The callback must return a promise and is called with three parameters: array item,
 * item index, array itself. Callbacks are invoked serially, such that callback for the
 * following item will not be called until the promise returned from the previous callback
 * is not fulfilled.
 *
 * @param {array} array
 * @param {function} callback
 * @param {object} [thisArg]
 * @return {Promise<any>}
 */
export declare function forEachPromise<T, U>(array: T[], callback: (item: T, index: number, array: T[]) => Promise<U>, thisArg: any): Promise<U[]>;
export declare function decodeEnvVar(dataString: string): Record<string, any>;
export declare function pathDifferences(a: any, b: any): string[];
/**
 * Get array of difference properties between passed a and b objects
 * @param {Object} a
 * @param {Object} b
 * @returns {Array<String>} changed properties
 */
export declare function difference(a: Record<string, any>, b: Record<string, any>): string[];
export interface DeferredPromise {
    resolve: (value: unknown) => void;
    reject: (reason?: any) => void;
    promise: Promise<any>;
}
export declare function deferredPromise(): DeferredPromise;
export declare function readDirRecursively(dir: string, options?: {
    relativeFilePaths?: boolean;
    filter?: (filePath: string, stats: Stats) => boolean;
}): Promise<{
    filePath: string;
    stats: Stats;
}[]>;
/**
 * Interpolates page url from file path.
 *
 * This function is useful for git-based CMS projects where page URL depends on
 * the physical file path of the page.
 *
 * @param {string} pageFilePath The file path of the page relative to project root
 * @param {Object} pageModel The computed pageModel of the page
 * @param {Object} pageData The fields of the page object
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The url of the page
 */
export declare function interpolatePageUrlFromFilePath({ pageFilePath, pageModel, pageData, pagesDir, logger }: {
    pageFilePath: string;
    pageModel: PageModel;
    pageData: any;
    pagesDir: string;
    logger?: Logger;
}): string;
/**
 * Computes page url from page's file path.
 * Use this method only when page model urlPath is not defined.
 *
 * @example
 * getPageUrlPathFromFilePath('src/pages/blog/my-blog-post.md', 'src/pages') => blog/my-blog-post
 * getPageUrlPathFromFilePath('content/about.md', 'content') => about
 * getPageUrlPathFromFilePath('projects/index.md', '') => projects
 *
 * @param {string} filePath The file path of the page relative to project root
 * @param {string} pagesDir The folder in which all page files are located. This is specific to SSG and usually specified as pagesDir in stackbit.yaml
 * @return {string} The inferred url of the page
 */
export declare function getPageUrlPathFromFilePath(filePath: string, pagesDir: string): string;
/**
 * Interpolates url path pattern from data.
 * If token does not exist in data returns original token.
 * When 'moment_format' function does not specify the 'date' parameter, the data should include 'moment_date' field.
 * This is useful when interpolating urls with date tokens based on the dates extracted from physical files.
 *
 * @example
 * interpolateUrlPathFromData('posts/{slug}', { slug: 'hello' })
 * => 'posts/hello'
 *
 * interpolateUrlPathFromData('posts/{moment_format(date, "YYYY-MM-DD")}-{slug}', {
 *   slug: 'hello',
 *   date: new Date('2020-10-10')
 * })
 * => 'posts/2020-10-10-hello'
 *
 * @param urlPath
 * @param data
 * @return {*}
 */
export declare function interpolateUrlPathFromData(urlPath: string, data: any): string;
export declare function extractTokensFromString(input: string): string[];
export declare function convertToRegularTokens(input: string): string;
export declare function rename(object: any, oldPath: string | KeyPath, newPath: any | KeyPath): void;
export declare function obfuscateString(str: string, { showFirst, showLast }?: {
    showFirst?: number;
    showLast?: number;
}): string;
export declare function delayPromise(delay: number): Promise<unknown>;
export declare function withRetry<T>(f: () => Promise<T>, logger: any, maxRetry?: number, retryDelay?: number, retryCount?: number): Promise<T>;
/**
 * Finds an images in the markdown, calls handler with the image path as an argument and replaces
 * the image path within markdown with the returned value of the handler
 *
 * @param {string} markdown
 * @param {Function} handler
 * @returns {string}
 */
export declare function processMarkdownImagePaths(markdown: string, handler: (imagePath: string) => string): string;
export declare function randomString(): string;
export declare function escapeShellValue(value: string): string;
//# sourceMappingURL=code-utils.d.ts.map