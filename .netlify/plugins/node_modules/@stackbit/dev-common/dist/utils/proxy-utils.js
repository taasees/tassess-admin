"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectScript = exports.proxyModifyResponseHandler = exports.createProxyModifyResponseMiddleware = exports.isJs = exports.isHtml = exports.isGzip = void 0;
const url_1 = __importDefault(require("url"));
const zlib_1 = __importDefault(require("zlib"));
const util_1 = __importDefault(require("util"));
const lodash_1 = __importDefault(require("lodash"));
const gzip = util_1.default.promisify(zlib_1.default.gzip);
const gunzip = util_1.default.promisify(zlib_1.default.gunzip);
function isGzip(req) {
    return lodash_1.default.get(req, ['headers', 'content-encoding'], '').includes('gzip');
}
exports.isGzip = isGzip;
function isHtml(req) {
    return lodash_1.default.get(req, ['headers', 'content-type'], '').includes('text/html');
}
exports.isHtml = isHtml;
function isJs(req) {
    return lodash_1.default.get(req, ['headers', 'content-type'], '').includes('application/javascript');
}
exports.isJs = isJs;
function createProxyModifyResponseMiddleware(options) {
    return (proxyRes, req, res) => {
        proxyModifyResponseHandler(proxyRes, req, res, options);
    };
}
exports.createProxyModifyResponseMiddleware = createProxyModifyResponseMiddleware;
function proxyModifyResponseHandler(proxyRes, req, res, options = {}) {
    const logTagName = lodash_1.default.get(options, 'logTagName', 'onProxyRes');
    if (options.logger) {
        proxyRes.on('error', (error) => {
            options.logger.error(`[${logTagName}] error proxying response`, { error: error, url: req.url, method: req.method });
        });
    }
    setRedirectHostRewrite(proxyRes, req);
    const passThrough = lodash_1.default.isFunction(options.shouldModifyBody) && !options.shouldModifyBody(proxyRes, req, res);
    if (passThrough) {
        const headers = proxyRes.headers;
        delete headers['x-frame-options'];
        delete headers['content-security-policy'];
        setHeaders(res, headers);
        if (proxyRes.statusCode) {
            res.status(proxyRes.statusCode);
        }
        proxyRes.on('data', (data) => res.write(data));
        proxyRes.on('end', () => res.end());
        return;
    }
    const _isGzip = isGzip(proxyRes);
    const chunks = [];
    proxyRes.on('data', (data) => {
        chunks.push(data);
    });
    proxyRes.on('end', async () => {
        let body = Buffer.concat(chunks);
        if (_isGzip) {
            try {
                body = await gunzip(body);
            }
            catch (error) {
                options.logger?.error(`[${logTagName}] error while unzipping response`, { error: error, url: req.url, method: req.method });
                setHeaders(res, proxyRes.headers);
                if (proxyRes.statusCode) {
                    res.status(proxyRes.statusCode);
                }
                res.end(body);
                return;
            }
        }
        body = body.toString('utf8');
        if (lodash_1.default.isFunction(options.modifyBody)) {
            body = options.modifyBody(body, proxyRes, req, res);
        }
        if (_isGzip) {
            body = await gzip(body);
        }
        // don't copy content-length because we are changing it when updating html
        setHeaders(res, lodash_1.default.omit(proxyRes.headers, ['content-length']));
        if (proxyRes.statusCode) {
            res.status(proxyRes.statusCode);
        }
        res.end(body);
    });
}
exports.proxyModifyResponseHandler = proxyModifyResponseHandler;
// When `followRedirects` is set to `false`, we need to make sure that browser receives correct redirected host.
// Because when modifying response we are setting `selfHandleResponse` to `true`, we are preventing http-proxy from
// rewriting redirect host (even when using `autoRewrite` is set to `true`).
// Therefore, manually rewrite the redirect host location as it is done in http-proxy module:
// https://github.com/http-party/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L50
const redirectRegex = /^201|30(1|2|7|8)$/;
function setRedirectHostRewrite(proxyRes, req) {
    if (!proxyRes.headers['location'] || !proxyRes.statusCode || !redirectRegex.test(proxyRes.statusCode.toString())) {
        return;
    }
    const u = url_1.default.parse(proxyRes.headers['location']);
    // rewrite host header if redirect location contains one
    if (u.host) {
        u.host = req.headers['host'];
    }
    proxyRes.headers['location'] = u.format();
}
function injectScript(html, url, code) {
    const injectedHtml = url ? `<script type="text/javascript" src="${url}"></script>` : `<script type="text/javascript">${code}</script>`;
    if (html) {
        if (html.includes('</head>')) {
            return html.replace('</head>', `${injectedHtml}</head>`);
        }
        else if (html.includes('<title>')) {
            return html.replace('<title>', `${injectedHtml}<title>`);
        }
        else if (html.includes('</body>')) {
            return html.replace('</body>', `${injectedHtml}</body>`);
        }
        else {
            return html + injectedHtml;
        }
    }
    return html;
}
exports.injectScript = injectScript;
function setHeaders(res, headers) {
    res.set(headers);
    const contentType = headers['content-type'];
    if (contentType && !contentType.includes('charset')) {
        // if original response header doesn't include charset - don't include it here as well
        // for instance, it fixes proxy nextjs 14 which checks for content-type strictly and because express applies charset
        // here, next does hard reload instead of soft
        res.writeHead(200, { 'content-type': contentType });
    }
}
//# sourceMappingURL=proxy-utils.js.map