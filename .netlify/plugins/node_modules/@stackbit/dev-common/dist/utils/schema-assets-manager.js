"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSchemaAssets = void 0;
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const sdk_1 = require("@stackbit/sdk");
async function handleSchemaAssets({ models, presets, rootDir, stackbitYamlDir, logger, userLogger, staticThemeAssetsPublicPath, staticThemeAssetsFilePath }) {
    let imagePathsToCopy = [];
    const joinThumbnailIfNeeded = (obj) => {
        if (obj.thumbnail && !isRemoteUrl(obj.thumbnail)) {
            imagePathsToCopy.push(obj.thumbnail);
            return {
                ...obj,
                thumbnail: path_1.default.join(staticThemeAssetsPublicPath, obj.thumbnail)
            };
        }
        return obj;
    };
    const mappedPresets = lodash_1.default.mapValues(presets, (preset) => {
        return joinThumbnailIfNeeded(preset);
    });
    const mappedModels = lodash_1.default.map(models, (model) => {
        model = joinThumbnailIfNeeded(model);
        model = (0, sdk_1.mapModelFieldsRecursively)(model, (field) => {
            // copy custom controlTypes files and set controlUrl to static URL
            if ('controlType' in field && (field.controlType === 'custom-modal-html' || field.controlType === 'custom-inline-html') && field.controlFilePath) {
                if (typeof field.controlFilePath === 'string' && !isRemoteUrl(field.controlFilePath)) {
                    imagePathsToCopy.push(field.controlFilePath);
                    field = {
                        ...field,
                        controlUrl: path_1.default.join(staticThemeAssetsPublicPath, field.controlFilePath)
                    };
                }
            }
            // copy images of 'thumbnails' controlType and rewrite their path to static URL
            if (field.type === 'object') {
                field = joinThumbnailIfNeeded(field);
            }
            else if (field.type === 'enum' && field.controlType === 'thumbnails') {
                field = {
                    ...field,
                    options: lodash_1.default.map(field.options, (option) => {
                        return joinThumbnailIfNeeded(option);
                    })
                };
            }
            return field;
        });
        return model;
    });
    imagePathsToCopy = lodash_1.default.uniq(imagePathsToCopy);
    if (!lodash_1.default.isEmpty(imagePathsToCopy)) {
        logger.debug(`Copying ${imagePathsToCopy.length} theme assets`);
        try {
            await Promise.all(imagePathsToCopy.map(async (imagePathToCopy) => {
                const imagePath = path_1.default.join(stackbitYamlDir, imagePathToCopy);
                const imageExists = await fs_extra_1.default.pathExists(imagePath);
                if (!imageExists) {
                    userLogger.warn('Missing file: ' + imagePathToCopy);
                    logger.debug('Missing file', {
                        imagePathToCopy,
                        imagePath,
                        imageExists
                    });
                    return;
                }
                const destPath = path_1.default.join(rootDir, staticThemeAssetsFilePath, imagePathToCopy);
                await fs_extra_1.default.ensureDir(path_1.default.dirname(destPath));
                await fs_extra_1.default.copyFile(imagePath, destPath);
            }));
        }
        catch (err) {
            logger.error('Error copying assets', { err, imagePathsToCopy });
        }
    }
    return {
        models: mappedModels,
        presets: mappedPresets
    };
}
exports.handleSchemaAssets = handleSchemaAssets;
function isRemoteUrl(url) {
    return url.match(/^https?:\/\//i);
}
//# sourceMappingURL=schema-assets-manager.js.map