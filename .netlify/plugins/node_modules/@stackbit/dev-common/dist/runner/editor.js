"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const file_utils_1 = require("../utils/file-utils");
const schema_utils_1 = require("../utils/schema-utils");
const code_utils_1 = require("../utils/code-utils");
const annotation_tree_parser_1 = require("../services/annotations/annotation-tree-parser");
const response_errors_1 = require("../services/response-errors");
const presets_service_1 = require("../services/presets-service");
class Editor {
    constructor(options) {
        this.contentStoreAdapter = options.contentStoreAdapter;
        this.stackbitConfig = options.stackbitConfig;
        this.logger = options.logger;
        this.userLogger = options.userLogger;
        this.stackbitUrlPathField = options.stackbitUrlPathField;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.commitAndPushChanges = options.commitAndPushChanges;
    }
    onStackbitConfigChange({ stackbitConfig }) {
        this.stackbitConfig = stackbitConfig;
    }
    buildUrlForPage(pageModel, document, locale, urlPathTemplateParams) {
        const pagesDir = this.stackbitConfig?.pagesDir || '';
        function getLocalizedFieldFromPageEntry(document, fieldName) {
            const docField = document.fields[fieldName];
            if (!docField) {
                return;
            }
            else if ('value' in docField) {
                return lodash_1.default.get(docField, 'value');
            }
            else if ('locales' in docField && locale && locale in docField.locales) {
                return lodash_1.default.get(docField, ['locales', locale, 'value']);
            }
            else {
                return undefined;
            }
        }
        const normalizeUrl = (urlPath) => urlPath.replace(/\/+/g, '/');
        // For projects using Git CMS, the URL needs to be computed from the `srcObjectId` and pageModel.
        if (document.srcType === 'git') {
            const pageObjects = this.contentStoreAdapter.getLocalizedApiObjects({
                objectIds: [document.srcObjectId]
            });
            const pageObject = pageObjects.find((pageObject) => pageObject.srcProjectId === document.srcProjectId && pageObject.srcType === document.srcType);
            if (!pageObject) {
                throw new Error(`Can't get page url, object with given objectId not found: ${document.srcObjectId}`);
            }
            const pageData = {};
            for (const fieldName in document.fields) {
                const fieldValue = getLocalizedFieldFromPageEntry(document, fieldName);
                if (typeof fieldValue !== 'undefined') {
                    pageData[fieldName.replace(/^_filePath_/, '')] = fieldValue;
                }
            }
            return normalizeUrl((0, code_utils_1.interpolatePageUrlFromFilePath)({
                pageFilePath: document.srcObjectId,
                pageModel,
                pageData,
                pagesDir,
                logger: this.userLogger
            }));
        }
        // For projects that use urlPath
        if (pageModel.urlPathTokens) {
            return pageModel.urlPathTokens.reduce((urlPath, fieldName) => {
                if (!urlPath) {
                    return null;
                }
                let fieldValue;
                if (fieldName.startsWith('params.')) {
                    const paramFieldName = fieldName.replace('params.', '');
                    fieldValue = lodash_1.default.get(urlPathTemplateParams, paramFieldName);
                }
                else {
                    fieldValue = getLocalizedFieldFromPageEntry(document, fieldName);
                }
                if (typeof fieldValue === 'undefined') {
                    return null;
                }
                return normalizeUrl(urlPath.replace(`{${fieldName}}`, fieldValue));
            }, pageModel.urlPath);
        }
        // For API-based CMS projects, we have a `slugField` that contains the name of the field
        // used to compute the slug. We can just take it and replace its value directly.
        const slugFieldValue = getLocalizedFieldFromPageEntry(document, pageModel.slugField);
        // For projects not using stackbit-pull but do have 'stackbit_url_path' (nextjs + sourcebit),
        // use the value of 'stackbit_url_path' as page URL
        if (pageModel.slugField === this.stackbitUrlPathField) {
            return slugFieldValue ?? null;
        }
        if (!slugFieldValue) {
            return pageModel.urlPath;
        }
        return normalizeUrl(pageModel.urlPath.replace('{slug}', slugFieldValue));
    }
    async getSchema({ locale, user }) {
        this.logger.debug('getSchema');
        const stackbitVersion = this.stackbitConfig?.stackbitVersion;
        const sidebarButtons = this.stackbitConfig?.sidebarButtons;
        const pageData = lodash_1.default.get(this.stackbitConfig, 'pageData');
        const duplicatableModels = lodash_1.default.get(this.stackbitConfig, 'duplicatableModels');
        const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ locale, user });
        const pageModels = this.getPageModels({ forSchema: true, user });
        const locales = this.contentStoreAdapter.getLocales();
        const isCSIEnabled = this.contentStoreAdapter.isContentStoreEnabled();
        const actions = await this.contentStoreAdapter.getGlobalActions({ locale, user });
        // status vs settings:
        // settings takes values directly from the stackbit.config (e.g. nodeVersion: 16)
        // status contains more dynamic values which might change even without config change or on the fly
        // and show more realistic values (e.g. nodeVersion: 16.20.0 <- real version, while in config it's just major 16)
        const status = (0, utils_1.omitByNil)({
            hasConfig: !!this.stackbitConfig,
            isCSIEnabled,
            contentSourceTypes: isCSIEnabled ? this.contentStoreAdapter.getContentSourceTypes() : undefined,
            contentSourceMeta: isCSIEnabled ? this.contentStoreAdapter.getContentSourceMeta() : undefined,
            nodeVersion: process.version
        });
        const schema = {
            sidebarButtons,
            stackbitVersion,
            pageData,
            schema: modelsByContentSourceType,
            pageModels,
            locales,
            duplicatableModels,
            presets: this.contentStoreAdapter.getPresets({ locale }),
            assetSources: this.contentStoreAdapter.getAssetSources(),
            actions: actions,
            settings: {
                hcrHandled: this.stackbitConfig?.hcrHandled,
                ssgName: this.stackbitConfig?.ssgName,
                ssgVersion: this.stackbitConfig?.ssgVersion,
                nodeVersion: this.stackbitConfig?.nodeVersion,
                viewports: this.stackbitConfig?.viewports
            },
            status
        };
        return (0, utils_1.omitByNil)(schema);
    }
    async getUrl(srcDocumentId, srcProjectId, srcType, locale) {
        if (this.stackbitConfig?.siteMap) {
            const siteMapEntriesForDocument = this.contentStoreAdapter.getSiteMapEntriesForDocument({
                srcType: srcType,
                srcProjectId: srcProjectId,
                srcDocumentId: srcDocumentId,
                locale: locale
            });
            return lodash_1.default.isEmpty(siteMapEntriesForDocument) ? null : siteMapEntriesForDocument[0].urlPath;
        }
        const document = this.contentStoreAdapter.getDocument({
            srcDocumentId: srcDocumentId,
            srcProjectId: srcProjectId,
            srcType: srcType
        });
        if (!document) {
            throw response_errors_1.PageNotFoundError;
        }
        const modelName = document.srcModelName;
        const allPageModels = this.getPageModels();
        const pageModels = lodash_1.default.filter(allPageModels, { modelName: modelName });
        if (pageModels.length === 0) {
            throw response_errors_1.PageNotFoundError;
        }
        // DEPRECATED: This check exists for backwards-compatibility with projects that define multiple page models with
        // the same name (currently only PX). Therefore when we detect that more than one model matches the current
        // pageEntry and we're using a Git-based CMS, then try to find which of the page models is a match and return
        // a URL for that page.
        //
        // TODO: convert legacy pageModels to standard format and allow defining multiple urlPath and filePath per model
        //   as described here: https://www.notion.so/stackbit/Container-Revise-page-urlPath-logic-a6b902cdedb54add98b713de86d0a576
        //
        // Example:
        // pageModels:
        //   - modelName: blog-post
        //     label: Blog Post
        //     url: "/resources/blog/%slug%"
        //     filePath: "src/pages/resources/blog/%slug%.md"
        //   - modelName: blog-post
        //     label: Tech Blog Post
        //     url: "/tech-blog/%slug%"
        //     filePath: "src/pages/tech-blog/%slug%.md"
        //   - modelName: default-form
        //     label: "Whitepaper"
        //     url: "/resources/whitepapers/%slug%"
        //     filePath: "src/pages/resources/whitepapers/%slug%.md"
        //   - modelName: default-form
        //     label: "Report"
        //     url: "/resources/reports/%slug%"
        //     filePath: "src/pages/resources/reports/%slug%.md"
        if (pageModels.length > 1 && document.srcType === 'git') {
            let urlPath;
            lodash_1.default.forEach(pageModels, (pageModel) => {
                if (typeof pageModel.filePath !== 'string') {
                    return false;
                }
                const { slug } = (0, file_utils_1.getNameSlugFromPath)(document.srcObjectId, pageModel.filePath);
                const currentFilePath = pageModel.filePath.replace('{slug}', slug);
                if (currentFilePath === document.srcObjectId) {
                    urlPath = pageModel.urlPath.replace('{slug}', slug);
                    return false;
                }
            });
            return urlPath ?? null;
        }
        const pageModel = pageModels[0];
        return this.buildUrlForPage(pageModel, document, locale, { locale });
    }
    getPageModels(options = {}) {
        this.logger.debug('getPageModels');
        const pagesDir = this.stackbitConfig?.pagesDir || '';
        const documents = this.contentStoreAdapter.getDocuments({});
        // Legacy syntax using the `pageModels` key or the `CONTENT_PAGE_MODELS` environment variable.
        const legacyPageModels = lodash_1.default.get(this.stackbitConfig, 'pageModels') || (process.env.CONTENT_PAGE_MODELS ? JSON.parse(process.env.CONTENT_PAGE_MODELS) : undefined);
        if (Array.isArray(legacyPageModels)) {
            this.logger.debug('project uses legacy pageModels');
            return legacyPageModels.reduce((pageModels, model) => {
                const document = lodash_1.default.find(documents, (document) => document.srcModelName === model.modelName);
                if (!document) {
                    return pageModels;
                }
                const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ user: options.user });
                const schemaModels = lodash_1.default.get(modelsByContentSourceType, [document.srcType, document.srcProjectId]);
                const schemaModel = lodash_1.default.find(schemaModels, (schemaModel) => schemaModel.name === model.modelName);
                model.srcProjectId = document.srcProjectId;
                const urlPath = lodash_1.default.has(model, 'url') ? (0, code_utils_1.convertToRegularTokens)(model.url) : '/{slug}';
                const filePath = lodash_1.default.has(model, 'filePath') ? (0, code_utils_1.convertToRegularTokens)(model.filePath) : null;
                const pageModel = {
                    modelName: model.modelName,
                    srcProjectId: model.srcProjectId,
                    srcEnvironment: document.srcEnvironment,
                    cmsId: document.srcType,
                    label: model.label || schemaModel?.label,
                    url: urlPath,
                    urlPath: urlPath,
                    filePath: filePath ?? lodash_1.default.trimStart(path_1.default.join(pagesDir, urlPath + '.md'), '/'),
                    slugField: model.slugField
                };
                return pageModels.concat(pageModel);
            }, []);
        }
        else {
            this.logger.debug('project uses stackbit config models');
            const modelsByContentSourceType = this.contentStoreAdapter.getModelsByContentSourceType({ user: options.user });
            return lodash_1.default.reduce(modelsByContentSourceType, (pageModels, modelsByContentSourceProjectId, srcType) => {
                return lodash_1.default.reduce(modelsByContentSourceProjectId, (pageModels, modelsByName, srcProjectId) => {
                    return lodash_1.default.reduce(modelsByName, (pageModels, model, modelName) => {
                        if (model.type !== 'page') {
                            return pageModels;
                        }
                        const document = lodash_1.default.find(documents, (document) => document.srcModelName === modelName);
                        if (document && lodash_1.default.get(options, 'forSchema') && (lodash_1.default.has(model, 'file') || lodash_1.default.get(model, 'singleInstance'))) {
                            this.logger.debug(`page model '${modelName}' is singleInstance with existing instance`);
                            return pageModels;
                        }
                        const urlPath = model.urlPath || '/{slug}';
                        let filePath;
                        let slugField;
                        let urlPathTokens;
                        if (!model.filePath || (options.forSchema && typeof model.filePath !== 'string')) {
                            filePath = lodash_1.default.trimStart(path_1.default.join(pagesDir, urlPath + '.md'), '/');
                        }
                        else {
                            filePath = model.filePath;
                        }
                        // In API-based CMS projects generated by Stackbit prior to v2, models have the 'stackbit_url_path'
                        // field which stores the full url of the page. In these projects the urlPath is '/{slug}'.
                        // Therefore we set the slugField to 'stackbit_url_path' which effectively makes the urlPath
                        // to represent full page URL.
                        if (lodash_1.default.find(model.fields, { name: this.stackbitUrlPathField })) {
                            slugField = this.stackbitUrlPathField;
                        }
                        else {
                            // Extract tokens from 'urlPath' and send them to the client.
                            // These tokens will serve as parameters for the user to fill before creating a page.
                            // for 404 pages urlPath could be parsed as number, cast it to string
                            const tokens = (0, code_utils_1.extractTokensFromString)(String(urlPath));
                            // backwards compatibility until we migrate to using urlPathTokens
                            // last token in urlPath is normally what user needs to provide
                            slugField = lodash_1.default.last(tokens);
                            urlPathTokens = tokens;
                        }
                        const pageModel = {
                            modelName: modelName,
                            srcProjectId: srcProjectId,
                            srcEnvironment: this.contentStoreAdapter.getContentSourceEnvironmentForContentSourceTypeAndId({
                                srcType,
                                srcProjectId
                            }),
                            cmsId: srcType,
                            label: model.label,
                            url: urlPath,
                            urlPath: urlPath,
                            filePath: filePath,
                            slugField: slugField,
                            urlPathTokens: urlPathTokens
                        };
                        return pageModels.concat(pageModel);
                    }, pageModels);
                }, pageModels);
            }, []);
        }
    }
    async getSiteMap({ locale, user }) {
        if (this.stackbitConfig?.siteMap) {
            const siteMapEntries = this.contentStoreAdapter.getSiteMapEntries({ locale, user });
            return lodash_1.default.reduce(siteMapEntries, (siteMap, siteMapEntry) => {
                const urlPath = lodash_1.default.trim(siteMapEntry.urlPath, '/');
                const urlPathParts = urlPath.split('/');
                const documentData = 'document' in siteMapEntry
                    ? {
                        srcType: siteMapEntry.document.srcType,
                        srcProjectId: siteMapEntry.document.srcProjectId,
                        srcModelName: siteMapEntry.document.modelName,
                        objectId: siteMapEntry.document.id
                    }
                    : null;
                let siteMapNode = siteMap;
                urlPathParts.forEach((urlPart, index) => {
                    if (index === urlPathParts.length - 1) {
                        siteMapNode[urlPart] = {
                            url: `/${urlPath}`,
                            ...(siteMapEntry.locale ? { locale: siteMapEntry.locale } : {}),
                            title: siteMapEntry.label,
                            stableId: siteMapEntry.stableId,
                            ...(siteMapEntry.isHomePage ? { isHomePage: siteMapEntry.isHomePage } : {}),
                            ...documentData,
                            children: siteMapNode[urlPart]?.children ?? {}
                        };
                    }
                    else if (!siteMapNode[urlPart]) {
                        siteMapNode[urlPart] = {
                            url: ['', ...urlPathParts.slice(0, index + 1)].join('/'),
                            children: {}
                        };
                    }
                    siteMapNode = siteMapNode[urlPart].children;
                });
                return siteMap;
            }, {});
        }
        else {
            return this.getSiteMap_deprecated({ locale });
        }
    }
    async getSiteMap_deprecated({ locale }) {
        const documents = this.contentStoreAdapter.getDocuments({ locale });
        const pageModels = this.getPageModels();
        const locales = this.contentStoreAdapter.getLocales();
        const pageModelsByName = lodash_1.default.keyBy(pageModels, 'modelName');
        const pageDocuments = documents.filter(({ srcModelName }) => pageModelsByName[srcModelName] !== undefined);
        const siteMap = {};
        const extendSiteMapForDocument = (pageDocument, locale) => {
            const pageModel = pageModelsByName[pageDocument.srcModelName];
            const pageUrl = this.buildUrlForPage(pageModel, pageDocument, locale, { locale });
            if (pageUrl === null) {
                return;
            }
            const url = lodash_1.default.trim(pageUrl, '/');
            const urlNodes = url.split('/');
            const leafNode = urlNodes.pop();
            let head = siteMap;
            urlNodes.forEach((node, index) => {
                head[node] = head[node] || {
                    children: {},
                    url: ['', ...urlNodes.slice(0, index), node].join('/')
                };
                head = head[node].children;
            });
            head[leafNode] = {
                children: {},
                environment: pageDocument.srcEnvironment,
                objectId: pageDocument.srcObjectId,
                srcType: pageDocument.srcType,
                srcProjectId: pageDocument.srcProjectId,
                srcModelName: pageDocument.srcModelName,
                ...(pageDocument.locale ? { locale: pageDocument.locale } : {}),
                source: 'schema',
                title: pageDocument.getPreview({ locale }).previewTitle,
                url: '/' + url,
                ...head[leafNode]
            };
        };
        pageDocuments.forEach((pageDocument) => {
            const localesForDocument = locales?.find(({ srcType, srcProjectId }) => pageDocument.srcType === srcType && pageDocument.srcProjectId === srcProjectId);
            if (locale) {
                extendSiteMapForDocument(pageDocument, locale);
            }
            else if (localesForDocument?.locales.length) {
                localesForDocument.locales.forEach((localeCode) => {
                    extendSiteMapForDocument(pageDocument, localeCode);
                });
            }
            else {
                extendSiteMapForDocument(pageDocument, undefined);
            }
        });
        return siteMap;
    }
    populateReferenceLabels(objects, documentMap, locale) {
        for (const object of objects) {
            (0, code_utils_1.forEachField)(object, (field) => {
                if (field && field.type === 'unresolved_reference' && field.refId) {
                    const document = documentMap[field.refId];
                    field.isMissing = !document;
                    if (document) {
                        field.srcObjectLabel = document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle;
                        field.srcModelLabel = document.srcModelLabel;
                    }
                }
                if (field && field.type === 'cross-reference' && field.refId) {
                    const document = documentMap[field.refId];
                    field.isMissing = !document;
                    if (document) {
                        field.refObjectLabel = document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle;
                        field.refModelLabel = document.srcModelLabel;
                        field.refModelName = document.srcModelName;
                    }
                }
            }, { includeKeyPath: false });
        }
    }
    async getObjects({ objectIds, locale, user }) {
        const apiDocuments = this.contentStoreAdapter.getLocalizedApiObjects({ locale, objectIds, user });
        const documentMap = lodash_1.default.keyBy([...this.contentStoreAdapter.getDocuments({ user }), ...this.contentStoreAdapter.getAssets({ user })], 'srcObjectId');
        if (objectIds) {
            this.populateReferenceLabels(apiDocuments, documentMap, locale);
        }
        return { objects: apiDocuments };
    }
    async getObjectsWithAnnotations({ annotationTree = null, clientAnnotationErrors = [], resolveAllReferences = false, locale, reportAllErrors = false, user }) {
        const cachedApiDocuments = {};
        const { objects, pathMap, errors } = (0, annotation_tree_parser_1.lazilyResolveObjectsWithAnnotationTree)(annotationTree, (objectId) => {
            const object = cachedApiDocuments[objectId] ?? this.contentStoreAdapter.getLocalizedApiObjects({ locale, objectIds: [objectId], user })[0];
            if (object) {
                cachedApiDocuments[objectId] = object;
            }
            return object;
        }, { resolveAllReferences });
        const documentMap = lodash_1.default.keyBy([...this.contentStoreAdapter.getDocuments({ user }), ...this.contentStoreAdapter.getAssets({ user })], 'srcObjectId');
        this.populateReferenceLabels(objects, documentMap, locale);
        if (!reportAllErrors) {
            const allErrors = [...errors, ...clientAnnotationErrors];
            const displayErrors = allErrors.slice(0, 5);
            lodash_1.default.forEach(displayErrors, (error) => {
                const errorProps = lodash_1.default.omit(error, ['type', 'message']);
                this.userLogger.error(`${error.message} ${lodash_1.default.map(errorProps, (val, key) => `${key}:'${val && val.toString ? val.toString() : val}'`).join(', ')}`);
            });
            const diffErrors = allErrors.length - displayErrors.length;
            if (diffErrors > 0) {
                this.userLogger.error(`${displayErrors.length} Annotation errors shown (out of ${allErrors.length}). Use \`stackbit dev\` locally to view all.`);
            }
        }
        // TODO: map over objects and return documents here as well
        return { objects, pathMap, errors };
    }
    async getCollections({ locale, user }) {
        const referenceMap = this.contentStoreAdapter.getReferenceMap();
        const content = [
            ...this.contentStoreAdapter.getDocuments({ locale, user }),
            ...this.contentStoreAdapter.getAssets({ locale, user })
        ];
        const mappedModels = this.contentStoreAdapter.getModelsByContentSourceType({ locale, user });
        const getId = (srcType, srcProjectId, modelName) => `${srcType}:${srcProjectId}:${modelName}`;
        const documentGroups = lodash_1.default.groupBy(content, (obj) => getId(obj.srcType, obj.srcProjectId, obj.srcModelName));
        const acceptedModels = (0, schema_utils_1.getFlattenModels)(mappedModels ?? {}).filter(({ model }) => {
            return model.type === 'page' || model.type === 'data' || model.type === 'image';
        });
        const styleObjectModelName = this.stackbitConfig?.styleObjectModelName;
        const objectsByModelName = lodash_1.default.groupBy(content, 'srcModelName');
        const styleObjectId = styleObjectModelName ? lodash_1.default.get(objectsByModelName, [styleObjectModelName, 0, 'srcObjectId'], null) : null;
        const collections = lodash_1.default.map(acceptedModels, ({ model, srcType, srcProjectId }) => {
            const documents = documentGroups[getId(srcType, srcProjectId, model.name)];
            return {
                srcType,
                srcProjectId,
                srcModelName: model.name,
                srcModelLabel: model.label,
                objects: documents?.map((document) => (0, utils_1.omitByNil)({
                    ...lodash_1.default.pick(document, ['srcObjectId', 'createdAt', 'updatedAt', 'updatedBy', 'srcObjectUrl', 'locale', 'status', 'permissions']),
                    srcObjectLabel: document.type === 'asset' ? document.srcObjectLabel : document.getPreview({ locale }).previewTitle,
                    referencedBy: referenceMap[document.srcType]?.[document.srcProjectId]?.[document.srcObjectId],
                    hidden: document.hidden
                })) ?? []
            };
        }).filter(({ srcModelName }) => srcModelName !== styleObjectModelName);
        // Sort by collectionType (page, data, object) and then by collectionName.
        const sortOrder = ['page', 'data', 'object'];
        const sortedByModelName = lodash_1.default.sortBy(collections, 'srcModelName');
        const sortedCollections = lodash_1.default.sortBy(sortedByModelName, (collection) => {
            const collectionType = lodash_1.default.get(mappedModels, [collection.srcType, collection.srcProjectId, collection.srcModelName, 'type']);
            return sortOrder.indexOf(collectionType);
        });
        return {
            collections: sortedCollections,
            styleObjectId
        };
    }
    async createPreset(dir, fieldDataPath, presetParams, dryRun, user) {
        const documents = this.contentStoreAdapter.getDocuments({});
        const assets = this.contentStoreAdapter.getAssets({});
        const documentsById = lodash_1.default.keyBy(documents, 'srcObjectId');
        const assetsById = lodash_1.default.keyBy(assets, 'srcObjectId');
        const contentStoreLocales = this.contentStoreAdapter.getLocales();
        const preset = await (0, presets_service_1.createPreset)({
            documentsById,
            assetsById,
            fieldDataPath,
            presetParams,
            contentStoreLocales,
            staticAssetsPublicPath: this.staticAssetsPublicPath,
            referenceBehavior: {
                behavior: this.stackbitConfig?.presetReferenceBehavior,
                duplicatableModels: this.stackbitConfig?.duplicatableModels,
                nonDuplicatableModels: this.stackbitConfig?.nonDuplicatableModels
            }
        });
        if (dryRun) {
            const presetFileName = (0, presets_service_1.generatePresetFileName)(preset);
            return {
                files: [presetFileName],
                preset
            };
        }
        return this.contentStoreAdapter.createPreset({ dir, presetParams, preset, user });
    }
    async deletePreset(dir, presetId, user) {
        return this.contentStoreAdapter.deletePreset({ dir, presetId, user });
    }
    async searchDocuments(data) {
        const referenceMap = this.contentStoreAdapter.getReferenceMap();
        const result = await this.contentStoreAdapter.searchDocuments(data);
        const items = result.items.map((document) => (0, utils_1.omitByNil)({
            ...lodash_1.default.pick(document, [
                'srcObjectId',
                'createdAt',
                'updatedAt',
                'srcProjectId',
                'srcType',
                'srcModelName',
                'srcModelLabel',
                'srcObjectUrl',
                'status',
                'locale'
            ]),
            srcObjectLabel: document.getPreview({ locale: data.locale }).previewTitle,
            referencedBy: referenceMap[document.srcType]?.[document.srcProjectId]?.[document.srcObjectId]
        }));
        return {
            ...result,
            items
        };
    }
    async getDocumentVersions(data) {
        const { versions } = await this.contentStoreAdapter.getDocumentVersions(data);
        if (versions.length) {
            const documentMap = lodash_1.default.keyBy([...this.contentStoreAdapter.getDocuments({}), ...this.contentStoreAdapter.getAssets({})], 'srcObjectId');
            const objects = versions.map((version) => version.object).filter(utils_1.isTruthy);
            this.populateReferenceLabels(objects, documentMap, data.locale);
        }
        return { versions };
    }
    async getDocumentForVersion(data) {
        const { version } = await this.contentStoreAdapter.getDocumentForVersion(data);
        if (version.object) {
            const documentMap = lodash_1.default.keyBy([...this.contentStoreAdapter.getDocuments({}), ...this.contentStoreAdapter.getAssets({})], 'srcObjectId');
            this.populateReferenceLabels([version.object], documentMap, data.locale);
        }
        return { version };
    }
}
exports.default = Editor;
//# sourceMappingURL=editor.js.map