"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const detect_port_1 = __importDefault(require("detect-port"));
const chalk_1 = __importDefault(require("chalk"));
const open_1 = __importDefault(require("open"));
const server_1 = require("./server");
const user_config_1 = require("./services/user-config");
const logger_1 = __importDefault(require("./services/logger"));
const api_1 = __importDefault(require("./services/api"));
const env_1 = require("./services/env");
const dev_common_1 = require("@stackbit/dev-common");
async function start(options) {
    if (options.cliVersion) {
        logger_1.default.info(`Running Stackbit Dev (CLI v${options.cliVersion})`);
        await (0, dev_common_1.checkAndLogNewerVersions)({
            dir: options.rootDir,
            knownVersions: {
                '@stackbit/cli': options.cliVersion
            },
            logger: logger_1.default
        });
    }
    logger_1.default.info('Site directory: ' + options.rootDir);
    await (0, env_1.loadEnv)(options.rootDir, logger_1.default).catch((err) => {
        logger_1.default.error('Error loading env', { err });
    });
    const serverPort = await (0, detect_port_1.default)(8090);
    const userId = (0, user_config_1.getUserId)();
    // Print the localId to allow developer set STACKBIT_API_KEY and use it to call /_stackbit/getCSIDocuments
    logger_1.default.info('localId: ' + userId);
    const localDetails = {
        i: userId,
        p: serverPort,
        v: require('../package.json').version,
        cms: options.cmsType || 'git'
    };
    options.telemetryTrack?.('Stackbit Dev Start', {
        ...getAnalyticsProperties(localDetails),
        inputDir: options.rootDir
    });
    if (options.contentfulSpaceIds) {
        localDetails.spaceIds = options.contentfulSpaceIds;
    }
    if (options.sanityProjectId) {
        localDetails.projectId = options.sanityProjectId;
    }
    if (options.cloudinaryCloudName && options.cloudinaryApiKey) {
        localDetails.cloudinary = {
            cloudName: options.cloudinaryCloudName,
            apiKey: options.cloudinaryApiKey
        };
    }
    if (options.aprimoTenant) {
        localDetails.aprimo = {
            tenant: options.aprimoTenant
        };
    }
    if (process.env.CSI_ENABLED) {
        logger_1.default.debug('CSI Enabled');
        options.csiEnabled = true;
    }
    if (process.env.CSI_WEBHOOK_URL) {
        options.csiWebhookUrl = process.env.CSI_WEBHOOK_URL;
    }
    try {
        const runner = await (0, server_1.start)({
            serverPort,
            uuid: userId,
            localDetails,
            ...options
        });
        localDetails.csi = runner.isCsiEnabled();
    }
    catch (err) {
        const errorMessage = 'Error starting Stackbit dev server';
        if (err?.stack) {
            logger_1.default.error(`${errorMessage}:\n${err.stack}`);
        }
        else if (err?.message) {
            logger_1.default.error(`${errorMessage}: ${err.message}`);
        }
        else {
            logger_1.default.error(errorMessage, { err });
        }
        options.telemetryTrack?.('Stackbit Dev Start Error', {
            ...getAnalyticsProperties(localDetails),
            err: err?.message,
            inputDir: options.rootDir
        });
        // give telemtry a chance to flush, and then exit
        setTimeout(() => {
            process.exit(1);
        }, 2000);
        return false;
    }
    logger_1.default.debug('Local details', { localDetails });
    const studioUrl = `http://localhost:${serverPort}/_stackbit`;
    try {
        const result = await api_1.default.updateLocalDev(userId, localDetails);
        logger_1.default.debug('update local details result', { result: result?.status });
    }
    catch (err) {
        // failure here is expected if user hasn't pressed the link yet.
        // in that case we defer the update to when the server starts getting accessed.
        logger_1.default.debug('updateLocalDev failed', { err: err.message || err });
    }
    logger_1.default.info(`Server started. Forwarding requests to: ${options.ssgHost}:${options.ssgPort}`);
    logger_1.default.info(`âš¡ Open${options.autoOpen ? 'ing' : ''} ${chalk_1.default.bold(studioUrl)} in your browser`);
    if (options.autoOpen) {
        (0, open_1.default)(studioUrl).catch((err) => {
            logger_1.default.debug('Auto open error', { err });
            logger_1.default.error('Error auto opening');
        });
    }
}
exports.start = start;
function getAnalyticsProperties(localDetails) {
    return {
        user_id: localDetails.i,
        dev_version: localDetails.v,
        port: localDetails.p,
        cms: localDetails.cms
    };
}
//# sourceMappingURL=dev.js.map