"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const body_parser_1 = __importDefault(require("body-parser"));
const logger_1 = __importDefault(require("../services/logger"));
const response_errors_1 = require("@stackbit/dev-common/dist/services/response-errors");
const authMiddleware = (uuid) => {
    return (req, res, next) => {
        try {
            if (!req.headers.authorization) {
                throw 'No token provided';
            }
            const token = req.headers.authorization.split(' ')[1];
            if (token === uuid) {
                next();
            }
            else {
                throw 'Bad token provided';
            }
        }
        catch (err) {
            logger_1.default.error('not authenticated', { error: err, req: req.path });
            res.status(400).send('Not authenticated');
        }
    };
};
function routes(router, runner, uuid, openUrl) {
    router.use((req, res, next) => {
        runner.keepAlive();
        next();
    });
    router.post('/_objects', [body_parser_1.default.json({ limit: '5mb' })], (req, res, next) => {
        const { objectIds, locale } = req.body;
        return runner
            .getObjects({ objectIds, locale })
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error('Error fetching data objects');
            logger_1.default.debug('error getting fieldData from runner', { error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error getting fieldData from runner, error.stack: ' + err.stack);
            }
            res.status(500).send('Error');
            next(err);
        });
    });
    router.post('/_objectsWithAnnotations', [body_parser_1.default.json({ limit: '5mb' })], (req, res, next) => {
        const { annotationTree, clientAnnotationErrors, resolveAllReferences, sourcemaps, locale } = req.body;
        return runner
            .getObjectsWithAnnotations({ annotationTree, clientAnnotationErrors, resolveAllReferences, sourcemaps, locale })
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error('Error fetching data objects with annotations');
            logger_1.default.debug('error getting fieldData with annotations from runner', { error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error getting fieldData with annotations from runner, error.stack: ' + err.stack);
            }
            res.status(500).send('Error');
            next(err);
        });
    });
    router.get('/_collections', (req, res, next) => {
        const { locale } = req.query;
        return runner
            .getCollections({ locale: locale })
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error('Error fetching collections');
            logger_1.default.debug('error getting collections from runner', { error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error getting collections from runner, error.stack: ' + err.stack);
            }
            res.status(500).send('Error');
            next(err);
        });
    });
    router.get('/_sitemap', (req, res, next) => {
        const { locale } = req.query;
        return runner
            .getSiteMap({ locale: locale })
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error('Error fetching sitemap');
            logger_1.default.debug('error getting sitemap from runner', { error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error getting sitemap from runner, error.stack: ' + err.stack);
            }
            res.status(500).send('Error');
            next(err);
        });
    });
    router.get('/_schema', (req, res, next) => {
        const { locale } = req.query;
        return runner
            .getSchema({ locale: locale })
            .then((schema) => res.json(schema))
            .catch((err) => {
            logger_1.default.error('Error fetching schema');
            logger_1.default.debug('error getting schema from runner', { error: err });
            res.status(500).send('Error');
            next(err);
        });
    });
    router.get('/_pageUrl', (req, res, next) => {
        const { srcType, locale } = req.query;
        const srcProjectId = req.query.srcProjectId ?? req.query.spaceId;
        const srcDocumentId = req.query.srcDocumentId ?? req.query.entryId;
        runner
            .getUrl(srcDocumentId, srcProjectId, srcType, locale)
            .then((url) => res.json({ url }))
            .catch((err) => {
            if (err !== response_errors_1.PageNotFoundError) {
                logger_1.default.error('Error querying for page url');
            }
            const log = err === response_errors_1.PageNotFoundError ? logger_1.default.debug : logger_1.default.warn;
            log('error getting page path from runner', { params: req.query, error: err });
            res.json({ message: err.toString() });
            if (err !== response_errors_1.PageNotFoundError) {
                next(err);
            }
        });
    });
    router.get('/_object', (req, res, next) => {
        const { objectId, projectId } = req.query;
        return runner
            .getObject(objectId, projectId)
            .then((response) => {
            res.json(response);
        })
            .catch((err) => {
            logger_1.default.error('Error fetching object');
            logger_1.default.debug('error getting object', { error: err });
            next(err);
        });
    });
    router.get('/_assets', [body_parser_1.default.json({ limit: '500kb' })], (req, res, next) => {
        const filterParams = lodash_1.default.pick(req.body, ['searchQuery', 'pageId', 'pageSize']);
        return runner
            .listAssets(filterParams)
            .then((response) => {
            res.json(response);
        })
            .catch((err) => {
            logger_1.default.error('Error listing assets');
            logger_1.default.debug('error listing assets', { error: err });
            res.status(500).json({ message: err.toString() });
            next(err);
        });
    });
    router.get('/_health', (req, res) => {
        return res.status(200).json({ status: 'ok' });
    });
    router.post('/_action', [authMiddleware(uuid), body_parser_1.default.json({ limit: '50mb' })], (req, res, next) => {
        const { action, data } = req.body;
        return runner
            .makeAction(action, data)
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error('Error performing action: ' + action);
            logger_1.default.debug('error performing action', { action, error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error.stack: ' + err.stack);
            }
            res.status(500).json({ message: err.message || err });
            next(err);
        });
    });
    router.get('/_stackbit', (req, res) => {
        return res.redirect(302, openUrl);
    });
    router.post('/_stackbit/:method', [authMiddleware(uuid), body_parser_1.default.json({ limit: '50mb' })], (req, res, next) => {
        const method = req.params.method;
        if (!runner[method]) {
            const message = `method "/_stackbit/${method}" is not supported`;
            logger_1.default.error(message);
            res.status(400).send({ message });
            next(new Error(message));
            return;
        }
        const data = req.body;
        return runner[method](data)
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error(`error executing ${method} method`, { data, error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error.stack: ' + err.stack);
            }
            res.status(500).send({ message: err.message || err });
            next(err);
        });
    });
    // For stackbit dev only when to develop and debug content-source webhooks
    router.post('/_stackbit/onWebhook/:srcType/:srcProjectId', body_parser_1.default.json({ limit: '50mb' }), (req, res, next) => {
        const data = req.body;
        return runner
            .onWebhook({
            srcType: req.params.srcType,
            srcProjectId: req.params.srcProjectId,
            data: req.body,
            headers: req.headers
        })
            .then((result) => {
            res.json(result);
        })
            .catch((err) => {
            logger_1.default.error(`error executing onWebhook method`, { data, error: err.message || err });
            if (lodash_1.default.has(err, 'stack')) {
                logger_1.default.debug('error.stack: ' + err.stack);
            }
            res.status(500).send({ message: err.message || err });
            next(err);
        });
    });
}
exports.default = routes;
//# sourceMappingURL=routes.js.map