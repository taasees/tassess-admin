"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const http_proxy_middleware_1 = __importDefault(require("http-proxy-middleware"));
const logger_1 = __importDefault(require("../services/logger"));
const consts_1 = __importDefault(require("../consts"));
const proxy_utils_1 = require("@stackbit/dev-common/dist/utils/proxy-utils");
const pages_1 = require("@stackbit/dev-common/dist/utils/pages");
const config_1 = __importDefault(require("../config"));
function proxyMiddleware(router, ssgHost, ssgPort, runner) {
    router.use((req, res, next) => {
        lodash_1.default.unset(req, 'headers.x-forwarded-proto');
        const rawHeaders = lodash_1.default.get(req, 'rawHeaders');
        const headerIndex = lodash_1.default.findIndex(rawHeaders, (headerValue) => headerValue.toLowerCase() === 'x-forwarded-proto');
        if (headerIndex > -1) {
            // remove the header key and value
            rawHeaders.splice(headerIndex, 2);
        }
        next();
    });
    router.use((req, res, next) => {
        res.set('Content-Security-Policy', `frame-ancestors *; `);
        next();
    });
    const proxyTargetUrl = ssgHost.toLowerCase().startsWith('http') ? `${ssgHost}:${ssgPort}` : `http://${ssgHost}:${ssgPort}`;
    const handlerProxyError = (err, req, res) => {
        if (err?.code === 'ECONNREFUSED' && res?.status) {
            (0, pages_1.renderLoadingPage)(req, res, {
                assetsDir: path_1.default.join(__dirname, '../assets'),
                proxyUrl: proxyTargetUrl,
                proxyPath: req?.path || '',
                htmlMessage: '',
                status: 504,
                statusMessage: 'aa'
            });
        }
    };
    // visit https://github.com/chimurai/http-proxy-middleware#context-matching
    // for docs on how path matching works, it is different from express matching
    const directPaths = lodash_1.default.uniq(lodash_1.default.concat(consts_1.default.DEFAULT_DIRECT_PROXY_PATH, runner.getDirectPaths()));
    router.use((0, http_proxy_middleware_1.default)(directPaths, {
        target: proxyTargetUrl,
        changeOrigin: runner.getDirectChangeOrigin(),
        ws: true,
        secure: false,
        logProvider: () => logger_1.default,
        logLevel: config_1.default.logLevel === 'debug' ? 'info' : 'silent',
        router: runner.getDirectRoutes() ?? [],
        onError: (err, req, res) => {
            logger_1.default.debug(`onError in direct proxy, request: ${req.method} ${req.url}, error: ${err.message}`, { error: err });
            handlerProxyError(err, req, res);
        }
    }));
    router.use((0, http_proxy_middleware_1.default)({
        target: proxyTargetUrl,
        changeOrigin: true,
        secure: false,
        logProvider: () => logger_1.default,
        logLevel: config_1.default.logLevel === 'debug' ? 'info' : 'silent',
        onError: (err, req, res) => {
            logger_1.default.debug(`onError in main proxy, request: ${req.method} ${req.url}, error: ${err.message}`, { error: err });
            handlerProxyError(err, req, res);
        },
        selfHandleResponse: true,
        onProxyRes: (0, proxy_utils_1.createProxyModifyResponseMiddleware)({
            logTagName: 'proxy',
            shouldModifyBody: (proxyRes, req) => {
                return req.method === 'GET' && (0, proxy_utils_1.isHtml)(proxyRes);
            },
            modifyBody: (body) => {
                body = (0, proxy_utils_1.injectScript)(body, config_1.default.snippetUrl);
                return body;
            }
        })
    }));
    return router;
}
exports.default = proxyMiddleware;
//# sourceMappingURL=proxy.js.map