"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const dev_common_1 = require("@stackbit/dev-common");
const sdk_1 = require("@stackbit/sdk");
const file_watcher_1 = require("../services/file-watcher");
const logger_1 = __importDefault(require("../services/logger"));
const consts_1 = __importDefault(require("../consts"));
const annotation_errors_1 = require("../services/annotation-errors");
const dev_common_2 = require("@stackbit/dev-common");
class Runner {
    constructor(options) {
        this.rootDir = options.rootDir;
        this.appDir = options.runnableDir ? path_1.default.join(this.rootDir, options.runnableDir) : this.rootDir;
        this.logger = options.logger ?? logger_1.default;
        this.workers = {
            gitApp: new dev_common_1.Worker()
        };
        this.contentStoreAdapter = new dev_common_1.ContentStoreAdapter({
            cmsType: options.cmsType,
            csiEnabled: options.csiEnabled,
            webhookUrl: options.csiWebhookUrl,
            workers: this.workers,
            rootDir: this.rootDir,
            projectDir: this.rootDir,
            appDir: this.appDir,
            logger: this.logger,
            userLogger: this.logger,
            localDev: true,
            contentfulAccessToken: options.contentfulAccessToken,
            contentfulSpaces: lodash_1.default.zip(options.contentfulSpaceIds, options.contentfulPreviewTokens)
                .filter((pair) => !!pair[0] && !!pair[1])
                .map(([spaceId, previewToken]) => ({
                spaceId,
                previewToken
            })),
            sanityProject: {
                projectId: options.sanityProjectId,
                token: options.sanityToken,
                studioPath: options.sanityStudioPath,
                dataset: options.sanityDataset,
                projectUrl: options.sanityStudioUrl
            },
            assetIdPrefix: consts_1.default.ASSET_ID_PREFIX,
            staticAssetsFilePath: consts_1.default.STATIC_ASSETS_FILE_PATH,
            staticAssetsPublicPath: consts_1.default.STATIC_ASSETS_PUBLIC_PATH,
            staticThemeAssetsFilePath: consts_1.default.STATIC_THEME_ASSETS_FILE_PATH,
            staticThemeAssetsPublicPath: consts_1.default.STATIC_THEME_ASSETS_PUBLIC_PATH,
            defaultContentTypeExtensions: consts_1.default.DEFAULT_CONTENT_TYPE_EXTENSIONS
        });
    }
    async install() {
        this.logger.debug('Initializing runner...');
        const { config, errors } = await this.loadStackbitConfig();
        for (const error of errors) {
            if (error instanceof sdk_1.StackbitConfigNotFoundError) {
                // if stackbit config was not found, log the error message,
                // and continue running using the default git-cms behavior
                this.logger.warn(error.message);
                this.logger.warn('loading the project as a Git CMS project with a default configuration');
            }
            else if (error instanceof sdk_1.ConfigLoadError) {
                // if stackbit config was found, but it had a fatal error, exit the process
                // the error will be logged by the catch block of the dev command
                throw error;
            }
            else {
                // stackbit config was loaded with some validation errors, log them and continue running
                this.logger.warn(`error in stackbit config: ` + error.message);
            }
        }
        this.editor = new dev_common_1.Editor({
            contentStoreAdapter: this.contentStoreAdapter,
            stackbitConfig: config,
            logger: this.logger,
            userLogger: this.logger,
            stackbitUrlPathField: consts_1.default.STACKBIT_URL_PATH_FIELD,
            staticAssetsPublicPath: consts_1.default.STATIC_ASSETS_PUBLIC_PATH
        });
        await this.contentStoreAdapter.init({ stackbitConfig: config });
        this.watcher = (0, file_watcher_1.watchDir)(this.rootDir, (filePaths) => {
            this.logger.debug(`File change detected: ${filePaths}`);
            this.handleFileChanges(filePaths);
        });
        this.ssg = lodash_1.default.mergeWith({}, sdk_1.DEFAULT_SSG_OPTIONS, config?.internalStackbitRunnerOptions, (value, srcValue) => {
            if (Array.isArray(srcValue)) {
                return srcValue;
            }
        });
        const connectURL = new URL('http://localhost:8000/__graphql');
        const { port, host } = config?.contentEngine ?? {};
        if (port) {
            connectURL.port = port.toString();
        }
        // We only use this in local dev, because it makes no sense (and is a security risk) to allow host changes in production
        if (host) {
            connectURL.hostname = host;
        }
        this.ssg.directRoutes['/.netlify/connect'] = connectURL.toString();
        this.ssg.directPaths.push('/.netlify/**');
        if (await fs_extra_1.default.pathExists(path_1.default.join(this.appDir, 'sourcebit.js'))) {
            this.ssg.directPaths.push('/socket.io/**');
            this.ssg.directRoutes['/socket.io'] = `http://localhost:${consts_1.default.NEXTJS_SOURCEBIT_LIVE_UPDATE_PORT}`;
        }
        if (config?.ssgName === 'nextjs') {
            this.ssg.directPaths.push('/_next/**', '/nextjs-live-updates/**');
        }
        if (config?.ssgName === 'gatsby') {
            this.ssg.directChangeSocketOrigin = true;
            this.ssg.directPaths.push('/socket.io/**');
        }
    }
    async loadStackbitConfig() {
        const stackbitConfigFilePath = await (0, sdk_1.findStackbitConfigFile)([this.appDir, this.rootDir]);
        if (!stackbitConfigFilePath) {
            return {
                config: null,
                errors: [new sdk_1.StackbitConfigNotFoundError()]
            };
        }
        else {
            this.logger.debug(`Found Stackbit configuration file at: ${stackbitConfigFilePath}`);
            this.stackbitConfigResult = await (0, sdk_1.loadConfig)({
                dirPath: path_1.default.dirname(stackbitConfigFilePath),
                watchCallback: this.onStackbitConfigUpdate.bind(this),
                logger: this.logger
            });
            if (this.stackbitConfigResult?.config?.contentSources) {
                await (0, dev_common_2.checkAndLogContentSourceVersions)({
                    contentSources: this.stackbitConfigResult.config.contentSources,
                    logger: this.logger,
                    isLocalDev: true
                });
            }
            this.logger.debug('loaded stackbit config');
            return {
                config: this.stackbitConfigResult.config,
                errors: this.stackbitConfigResult.errors
            };
        }
    }
    async onStackbitConfigUpdate(result) {
        this.logger.debug('onStackbitConfigUpdate');
        const { config, errors } = result;
        for (const error of errors) {
            this.logger.warn(error.message);
        }
        // if user broke the config file, don't reload anything until the file is fixed
        if (!config) {
            return;
        }
        this.editor.onStackbitConfigChange({ stackbitConfig: config });
        await this.contentStoreAdapter.onStackbitConfigChange({ stackbitConfig: config });
    }
    async handleFileChanges(filePaths) {
        try {
            this.logger.debug('handleFileChanges', { filePaths });
            await this.contentStoreAdapter.handleFileChanges(filePaths);
        }
        catch (err) {
            this.logger.debug('Handle file change error', { err, filePaths });
            this.logger.error('Error handling file changes: ' + filePaths.join(', '));
        }
    }
    getDirectPaths() {
        return this.ssg.directPaths;
    }
    /**
     * Function retuning a map or a function that rewrites direct proxy requests.
     * https://github.com/chimurai/http-proxy-middleware#http-proxy-middleware-options
     * @return {Function|Object}
     */
    getDirectRoutes() {
        return this.ssg.directRoutes;
    }
    getDirectChangeOrigin() {
        return this.ssg.directChangeOrigin;
    }
    getDirectChangeSocketOrigin() {
        return this.ssg.directChangeSocketOrigin;
    }
    async getObjects({ objectIds, locale, user }) {
        return this.editor.getObjects({ objectIds, locale, user });
    }
    async getDocuments({ documentSpecs, user }) {
        return this.contentStoreAdapter.getApiDocuments({ documentSpecs, user });
    }
    async getCSIDocuments(data = {}) {
        return this.contentStoreAdapter.getCSIDocuments(data);
    }
    async getStagedChanges(data) {
        const changes = await this.contentStoreAdapter.getStagedChanges(data);
        return { changes };
    }
    async getObjectsWithAnnotations({ annotationTree = null, clientAnnotationErrors = [], resolveAllReferences, sourcemaps, locale, user }) {
        const result = await this.editor.getObjectsWithAnnotations({
            annotationTree,
            clientAnnotationErrors,
            resolveAllReferences,
            locale,
            user,
            reportAllErrors: true
        });
        const errors = [...(result.errors ?? []), ...clientAnnotationErrors];
        (0, annotation_errors_1.logAnnotationErrors)(errors, this.logger, this.rootDir, sourcemaps);
        return result;
    }
    async getCollections({ locale, user }) {
        return this.editor.getCollections({ locale, user });
    }
    async getSiteMap({ locale, user }) {
        return this.editor.getSiteMap({ locale, user });
    }
    async getTreeViews({ user }) {
        return this.contentStoreAdapter.getTreeViews({ user });
    }
    async getSchema({ locale, user }) {
        return this.editor.getSchema({ locale, user });
    }
    async getUrl(srcDocumentId, srcProjectId, srcType, locale) {
        return this.editor.getUrl(srcDocumentId, srcProjectId, srcType, locale);
    }
    async getObject(objectId, projectId) {
        return this.contentStoreAdapter.getObject_deprecated({ objectId, projectId });
    }
    async listAssets(filterParams) {
        return this.contentStoreAdapter.listAssets_deprecated(filterParams);
    }
    async uploadAsset(url, filename, user) {
        return this.contentStoreAdapter.uploadAsset_deprecated({ url, fileName: filename, user });
    }
    async hasAccess(data) {
        return this.contentStoreAdapter.hasAccess(data);
    }
    async createDocument(data) {
        return this.contentStoreAdapter.createDocument(data);
    }
    async createAndLinkDocument(data) {
        return this.contentStoreAdapter.createAndLinkDocument(data);
    }
    async createAndCrossLinkDocument(data) {
        return this.contentStoreAdapter.createAndLinkDocument(data);
    }
    async uploadAndLinkAsset(data) {
        return this.contentStoreAdapter.uploadAndLinkAsset(data);
    }
    async duplicateDocument(data) {
        return this.contentStoreAdapter.duplicateDocument(data);
    }
    async updateDocument(data) {
        return this.contentStoreAdapter.updateDocument(data);
    }
    async deleteDocument(data) {
        return this.contentStoreAdapter.deleteDocument(data);
    }
    async archiveDocument(data) {
        return this.contentStoreAdapter.archiveDocument(data);
    }
    async unarchiveDocument(data) {
        return this.contentStoreAdapter.unarchiveDocument(data);
    }
    async getScheduledActions() {
        return this.contentStoreAdapter.getScheduledActions();
    }
    async createScheduledAction(data) {
        return this.contentStoreAdapter.createScheduledAction(data);
    }
    async cancelScheduledAction(data) {
        return this.contentStoreAdapter.cancelScheduledAction(data);
    }
    async updateScheduledAction(data) {
        return this.contentStoreAdapter.updateScheduledAction(data);
    }
    async searchDocuments(data) {
        return this.editor.searchDocuments(data);
    }
    async onWebhook(data) {
        return this.contentStoreAdapter.onWebhook(data);
    }
    async validateDocuments(data) {
        return this.contentStoreAdapter.validateDocuments(data);
    }
    async publishDocuments(data) {
        return this.contentStoreAdapter.publishDocuments(data);
    }
    async unpublishDocuments(data) {
        return this.contentStoreAdapter.unpublishDocuments(data);
    }
    async getAssets(data) {
        return this.contentStoreAdapter.getApiAssets(data);
    }
    async uploadAssets(data) {
        return this.contentStoreAdapter.uploadAssets(data);
    }
    async createPreset(data) {
        return this.editor.createPreset(this.appDir, data.fieldDataPath, lodash_1.default.omit(data, ['fieldDataPath', 'user', 'dryRun']), data.dryRun, data.user);
    }
    async deletePreset(data) {
        return this.editor.deletePreset(this.appDir, data.presetId, data.user);
    }
    async getCustomActions(data) {
        return this.contentStoreAdapter.getCustomActions(data);
    }
    async runCustomAction(data) {
        return this.contentStoreAdapter.runCustomAction(data);
    }
    async getDocumentVersions(data) {
        return this.editor.getDocumentVersions(data);
    }
    async getDocumentForVersion(data) {
        return this.editor.getDocumentForVersion(data);
    }
    async makeAction(action, data) {
        switch (action) {
            case 'createPage':
                return this.contentStoreAdapter.createObject_deprecated(data);
            case 'duplicatePage':
                return this.contentStoreAdapter.duplicateObject_deprecated(data);
            case 'updatePage':
                return this.contentStoreAdapter.updateObject_deprecated(data);
            case 'deleteObject':
                return this.contentStoreAdapter.deleteObject_deprecated(data);
            case 'getAssets':
                return this.contentStoreAdapter.getAssets_deprecated(data);
            case 'uploadAssets':
                return this.contentStoreAdapter.uploadAssets(data);
            case 'createPreset':
                return this.editor.createPreset(this.appDir, data.fieldDataPath, lodash_1.default.omit(data, ['fieldDataPath', 'user', 'dryRun']), data.user, data.dryRun);
            case 'deletePreset':
                return this.editor.deletePreset(this.appDir, data.presetId, data.user);
            case 'hasAccess':
                // for old non csi git based projects
                return {
                    hasConnection: true,
                    hasPermissions: true
                };
            default:
                throw new Error('Unsupported Operation: ' + data.action);
        }
    }
    keepAlive() {
        this.contentStoreAdapter.keepAlive();
    }
    isCsiEnabled() {
        return this.contentStoreAdapter.isContentStoreEnabled();
    }
    getAssetFilePath(url) {
        const assetFilePath = this.contentStoreAdapter.getAssetFilePath(url);
        if (assetFilePath) {
            return path_1.default.join(this.rootDir, assetFilePath);
        }
        return assetFilePath;
    }
    async destroy() {
        this.watcher.close();
        await this.stackbitConfigResult?.destroy?.();
        await this.contentStoreAdapter?.destroy();
    }
}
exports.default = Runner;
//# sourceMappingURL=index.js.map