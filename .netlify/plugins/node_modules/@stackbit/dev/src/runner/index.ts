import _ from 'lodash';
import path from 'path';
import fse from 'fs-extra';

import { Editor, ContentStoreAdapter, Worker } from '@stackbit/dev-common';
import {
    findStackbitConfigFile,
    loadConfig,
    LoadConfigResult,
    LoadConfigResultWithReloadDestroy,
    ConfigLoadError,
    StackbitConfigNotFoundError,
    SSGRunOptions,
    DEFAULT_SSG_OPTIONS
} from '@stackbit/sdk';
import type { FSWatcher } from 'chokidar';

import { watchDir } from '../services/file-watcher';
import logger from '../services/logger';
import consts from '../consts';
import { logAnnotationErrors } from '../services/annotation-errors';
import {
    APIMethodInterface,
    APIMethodCreateDocument,
    APIMethodCreatePreset,
    APIMethodDeleteDocument,
    APIMethodDeletePreset,
    APIMethodDuplicateDocument,
    APIMethodGetAssets,
    APIMethodUpdateDocument,
    APIMethodUploadAssets,
    APIMethodValidateDocuments,
    APIMethodPublishDocuments,
    APIMethodCreateAndLinkDocument,
    APIMethodUploadAndLinkAsset,
    APIMethodSearchDocuments,
    APIMethodHasAccess,
    APIMethodOnWebhook,
    APIMethodCreateAndCrossLinkDocument,
    APIMethodCreateScheduledAction,
    APIMethodGetScheduledActions,
    APIMethodCancelScheduledAction,
    APIMethodUpdateScheduledAction,
    APIMethodGetCustomActions,
    APIMethodRunCustomAction,
    APIMethodGetDocumentVersions,
    APIMethodGetDocumentForVersion,
    APIMethodGetCollections,
    APIMethodGetSiteMap,
    APIMethodGetTreeViews,
    APIMethodGetSchema,
    APIMethodGetObjects,
    APIMethodGetObjectsWithAnnotations,
    APIMethodGetDocuments,
    APIMethodGetCSIDocuments,
    APIMethodUnpublishDocuments,
    APIMethodArchiveDocument,
    APIMethodGetStagedChanges,
    APIMethodUnarchiveDocument
} from '../types/api-methods';
import * as StackbitTypes from '@stackbit/types';
import { checkAndLogContentSourceVersions } from '@stackbit/dev-common';

interface RunnerOptions {
    rootDir: string;
    runnableDir?: string;
    cmsType?: string;
    csiEnabled?: boolean;
    csiWebhookUrl?: string;
    contentfulAccessToken?: string;
    contentfulSpaceIds?: [string];
    contentfulPreviewTokens?: [string];
    sanityToken?: string;
    sanityStudioPath?: string;
    sanityDataset?: string;
    sanityProjectId?: string;
    sanityStudioUrl?: string;
    logger?: StackbitTypes.Logger;
}

export default class Runner implements APIMethodInterface {
    private readonly contentStoreAdapter: ContentStoreAdapter;
    private readonly workers: { gitApp: Worker };
    private readonly rootDir: string;
    private readonly appDir: string;
    private readonly logger: StackbitTypes.Logger;
    private stackbitConfigResult!: LoadConfigResultWithReloadDestroy;
    private editor!: Editor;
    private watcher!: FSWatcher;
    private ssg!: SSGRunOptions;

    constructor(options: RunnerOptions) {
        this.rootDir = options.rootDir;
        this.appDir = options.runnableDir ? path.join(this.rootDir, options.runnableDir) : this.rootDir;
        this.logger = options.logger ?? logger;

        this.workers = {
            gitApp: new Worker()
        };

        this.contentStoreAdapter = new ContentStoreAdapter({
            cmsType: options.cmsType!,
            csiEnabled: options.csiEnabled,
            webhookUrl: options.csiWebhookUrl,
            workers: this.workers,
            rootDir: this.rootDir,
            projectDir: this.rootDir,
            appDir: this.appDir,
            logger: this.logger,
            userLogger: this.logger,
            localDev: true,
            contentfulAccessToken: options.contentfulAccessToken,
            contentfulSpaces: _.zip(options.contentfulSpaceIds, options.contentfulPreviewTokens)
                .filter((pair): pair is [string, string] => !!pair[0] && !!pair[1])
                .map(([spaceId, previewToken]) => ({
                    spaceId,
                    previewToken
                })),
            sanityProject: {
                projectId: options.sanityProjectId!,
                token: options.sanityToken!,
                studioPath: options.sanityStudioPath!,
                dataset: options.sanityDataset!,
                projectUrl: options.sanityStudioUrl!
            },
            assetIdPrefix: consts.ASSET_ID_PREFIX,
            staticAssetsFilePath: consts.STATIC_ASSETS_FILE_PATH,
            staticAssetsPublicPath: consts.STATIC_ASSETS_PUBLIC_PATH,
            staticThemeAssetsFilePath: consts.STATIC_THEME_ASSETS_FILE_PATH,
            staticThemeAssetsPublicPath: consts.STATIC_THEME_ASSETS_PUBLIC_PATH,
            defaultContentTypeExtensions: consts.DEFAULT_CONTENT_TYPE_EXTENSIONS
        });
    }

    async install() {
        this.logger.debug('Initializing runner...');

        const { config, errors } = await this.loadStackbitConfig();

        for (const error of errors) {
            if (error instanceof StackbitConfigNotFoundError) {
                // if stackbit config was not found, log the error message,
                // and continue running using the default git-cms behavior
                this.logger.warn(error.message);
                this.logger.warn('loading the project as a Git CMS project with a default configuration');
            } else if (error instanceof ConfigLoadError) {
                // if stackbit config was found, but it had a fatal error, exit the process
                // the error will be logged by the catch block of the dev command
                throw error;
            } else {
                // stackbit config was loaded with some validation errors, log them and continue running
                this.logger.warn(`error in stackbit config: ` + error.message);
            }
        }

        this.editor = new Editor({
            contentStoreAdapter: this.contentStoreAdapter,
            stackbitConfig: config,
            logger: this.logger,
            userLogger: this.logger,
            stackbitUrlPathField: consts.STACKBIT_URL_PATH_FIELD,
            staticAssetsPublicPath: consts.STATIC_ASSETS_PUBLIC_PATH
        });

        await this.contentStoreAdapter.init({ stackbitConfig: config });

        this.watcher = watchDir(this.rootDir, (filePaths) => {
            this.logger.debug(`File change detected: ${filePaths}`);
            this.handleFileChanges(filePaths);
        });

        this.ssg = _.mergeWith({}, DEFAULT_SSG_OPTIONS, config?.internalStackbitRunnerOptions, (value, srcValue) => {
            if (Array.isArray(srcValue)) {
                return srcValue;
            }
        });

        const connectURL = new URL('http://localhost:8000/__graphql');

        const { port, host } = config?.contentEngine ?? {};

        if (port) {
            connectURL.port = port.toString();
        }

        // We only use this in local dev, because it makes no sense (and is a security risk) to allow host changes in production
        if (host) {
            connectURL.hostname = host;
        }

        this.ssg.directRoutes!['/.netlify/connect'] = connectURL.toString();
        this.ssg.directPaths!.push('/.netlify/**');

        if (await fse.pathExists(path.join(this.appDir, 'sourcebit.js'))) {
            this.ssg.directPaths!.push('/socket.io/**');
            this.ssg.directRoutes!['/socket.io'] = `http://localhost:${consts.NEXTJS_SOURCEBIT_LIVE_UPDATE_PORT}`;
        }

        if (config?.ssgName === 'nextjs') {
            this.ssg.directPaths!.push('/_next/**', '/nextjs-live-updates/**');
        }
        if (config?.ssgName === 'gatsby') {
            this.ssg.directChangeSocketOrigin = true;
            this.ssg.directPaths!.push('/socket.io/**');
        }
    }

    async loadStackbitConfig() {
        const stackbitConfigFilePath = await findStackbitConfigFile([this.appDir, this.rootDir]);
        if (!stackbitConfigFilePath) {
            return {
                config: null,
                errors: [new StackbitConfigNotFoundError()]
            };
        } else {
            this.logger.debug(`Found Stackbit configuration file at: ${stackbitConfigFilePath}`);
            this.stackbitConfigResult = await loadConfig({
                dirPath: path.dirname(stackbitConfigFilePath),
                watchCallback: this.onStackbitConfigUpdate.bind(this),
                logger: this.logger
            });
            if (this.stackbitConfigResult?.config?.contentSources) {
                await checkAndLogContentSourceVersions({
                    contentSources: this.stackbitConfigResult.config.contentSources,
                    logger: this.logger,
                    isLocalDev: true
                });
            }
            this.logger.debug('loaded stackbit config');
            return {
                config: this.stackbitConfigResult.config,
                errors: this.stackbitConfigResult.errors
            };
        }
    }

    async onStackbitConfigUpdate(result: LoadConfigResult) {
        this.logger.debug('onStackbitConfigUpdate');
        const { config, errors } = result;
        for (const error of errors) {
            this.logger.warn(error.message);
        }
        // if user broke the config file, don't reload anything until the file is fixed
        if (!config) {
            return;
        }
        this.editor.onStackbitConfigChange({ stackbitConfig: config });
        await this.contentStoreAdapter.onStackbitConfigChange({ stackbitConfig: config });
    }

    async handleFileChanges(filePaths: string[]): Promise<void> {
        try {
            this.logger.debug('handleFileChanges', { filePaths });
            await this.contentStoreAdapter.handleFileChanges(filePaths);
        } catch (err) {
            this.logger.debug('Handle file change error', { err, filePaths });
            this.logger.error('Error handling file changes: ' + filePaths.join(', '));
        }
    }

    getDirectPaths() {
        return this.ssg.directPaths;
    }

    /**
     * Function retuning a map or a function that rewrites direct proxy requests.
     * https://github.com/chimurai/http-proxy-middleware#http-proxy-middleware-options
     * @return {Function|Object}
     */
    getDirectRoutes(): { [hostOrPath: string]: string } {
        return this.ssg.directRoutes!;
    }

    getDirectChangeOrigin() {
        return this.ssg.directChangeOrigin;
    }

    getDirectChangeSocketOrigin() {
        return this.ssg.directChangeSocketOrigin;
    }

    async getObjects({ objectIds, locale, user }: APIMethodGetObjects['data']): Promise<APIMethodGetObjects['result']> {
        return this.editor.getObjects({ objectIds, locale, user });
    }

    async getDocuments({ documentSpecs, user }: APIMethodGetDocuments['data']): Promise<APIMethodGetDocuments['result']> {
        return this.contentStoreAdapter.getApiDocuments({ documentSpecs, user });
    }

    async getCSIDocuments(data: APIMethodGetCSIDocuments['data'] = {}): Promise<APIMethodGetCSIDocuments['result']> {
        return this.contentStoreAdapter.getCSIDocuments(data);
    }

    async getStagedChanges(data: APIMethodGetStagedChanges['data']): Promise<APIMethodGetStagedChanges['result']> {
        const changes = await this.contentStoreAdapter.getStagedChanges(data);
        return { changes };
    }

    async getObjectsWithAnnotations({
        annotationTree = null,
        clientAnnotationErrors = [],
        resolveAllReferences,
        sourcemaps,
        locale,
        user
    }: APIMethodGetObjectsWithAnnotations['data']): Promise<APIMethodGetObjectsWithAnnotations['result']> {
        const result = await this.editor.getObjectsWithAnnotations({
            annotationTree,
            clientAnnotationErrors,
            resolveAllReferences,
            locale,
            user,
            reportAllErrors: true
        });
        const errors = [...(result.errors ?? []), ...clientAnnotationErrors];
        logAnnotationErrors(errors, this.logger, this.rootDir, sourcemaps);
        return result;
    }

    async getCollections({ locale, user }: APIMethodGetCollections['data']): Promise<APIMethodGetCollections['result']> {
        return this.editor.getCollections({ locale, user });
    }

    async getSiteMap({ locale, user }: APIMethodGetSiteMap['data']): Promise<APIMethodGetSiteMap['result']> {
        return this.editor.getSiteMap({ locale, user });
    }

    async getTreeViews({ user }: APIMethodGetTreeViews['data']): Promise<APIMethodGetTreeViews['result']> {
        return this.contentStoreAdapter.getTreeViews({ user });
    }

    async getSchema({ locale, user }: APIMethodGetSchema['data']): Promise<APIMethodGetSchema['result']> {
        return this.editor.getSchema({ locale, user });
    }

    async getUrl(srcDocumentId: string, srcProjectId: string, srcType: string, locale?: string): Promise<string | null> {
        return this.editor.getUrl(srcDocumentId, srcProjectId, srcType, locale);
    }

    async getObject(objectId: string, projectId: string): Promise<any> {
        return this.contentStoreAdapter.getObject_deprecated({ objectId, projectId });
    }

    async listAssets(filterParams: any): Promise<any> {
        return this.contentStoreAdapter.listAssets_deprecated(filterParams);
    }

    async uploadAsset(url: string, filename: string, user: any): Promise<any> {
        return this.contentStoreAdapter.uploadAsset_deprecated({ url, fileName: filename, user });
    }

    async hasAccess(data: APIMethodHasAccess['data']): Promise<APIMethodHasAccess['result']> {
        return this.contentStoreAdapter.hasAccess(data);
    }

    async createDocument(data: APIMethodCreateDocument['data']): Promise<APIMethodCreateDocument['result']> {
        return this.contentStoreAdapter.createDocument(data);
    }

    async createAndLinkDocument(data: APIMethodCreateAndLinkDocument['data']): Promise<APIMethodCreateAndLinkDocument['result']> {
        return this.contentStoreAdapter.createAndLinkDocument(data);
    }

    async createAndCrossLinkDocument(data: APIMethodCreateAndCrossLinkDocument['data']): Promise<APIMethodCreateAndCrossLinkDocument['result']> {
        return this.contentStoreAdapter.createAndLinkDocument(data);
    }

    async uploadAndLinkAsset(data: APIMethodUploadAndLinkAsset['data']): Promise<APIMethodUploadAndLinkAsset['result']> {
        return this.contentStoreAdapter.uploadAndLinkAsset(data);
    }

    async duplicateDocument(data: APIMethodDuplicateDocument['data']): Promise<APIMethodDuplicateDocument['result']> {
        return this.contentStoreAdapter.duplicateDocument(data);
    }

    async updateDocument(data: APIMethodUpdateDocument['data']): Promise<APIMethodUpdateDocument['result']> {
        return this.contentStoreAdapter.updateDocument(data);
    }

    async deleteDocument(data: APIMethodDeleteDocument['data']): Promise<APIMethodDeleteDocument['result']> {
        return this.contentStoreAdapter.deleteDocument(data);
    }

    async archiveDocument(data: APIMethodArchiveDocument['data']): Promise<APIMethodArchiveDocument['result']> {
        return this.contentStoreAdapter.archiveDocument(data);
    }

    async unarchiveDocument(data: APIMethodUnarchiveDocument['data']): Promise<APIMethodUnarchiveDocument['result']> {
        return this.contentStoreAdapter.unarchiveDocument(data);
    }

    async getScheduledActions(): Promise<APIMethodGetScheduledActions['result']> {
        return this.contentStoreAdapter.getScheduledActions();
    }

    async createScheduledAction(data: APIMethodCreateScheduledAction['data']): Promise<APIMethodCreateScheduledAction['result']> {
        return this.contentStoreAdapter.createScheduledAction(data);
    }

    async cancelScheduledAction(data: APIMethodCancelScheduledAction['data']): Promise<APIMethodCancelScheduledAction['result']> {
        return this.contentStoreAdapter.cancelScheduledAction(data);
    }

    async updateScheduledAction(data: APIMethodUpdateScheduledAction['data']): Promise<APIMethodUpdateScheduledAction['result']> {
        return this.contentStoreAdapter.updateScheduledAction(data);
    }

    async searchDocuments(data: APIMethodSearchDocuments['data']): Promise<APIMethodSearchDocuments['result']> {
        return this.editor.searchDocuments(data);
    }

    async onWebhook(data: APIMethodOnWebhook['data']): Promise<APIMethodOnWebhook['result']> {
        return this.contentStoreAdapter.onWebhook(data);
    }

    async validateDocuments(data: APIMethodValidateDocuments['data']): Promise<APIMethodValidateDocuments['result']> {
        return this.contentStoreAdapter.validateDocuments(data);
    }

    async publishDocuments(data: APIMethodPublishDocuments['data']): Promise<APIMethodPublishDocuments['result']> {
        return this.contentStoreAdapter.publishDocuments(data);
    }

    async unpublishDocuments(data: APIMethodUnpublishDocuments['data']): Promise<APIMethodUnpublishDocuments['result']> {
        return this.contentStoreAdapter.unpublishDocuments(data);
    }

    async getAssets(data: APIMethodGetAssets['data']): Promise<APIMethodGetAssets['result']> {
        return this.contentStoreAdapter.getApiAssets(data);
    }

    async uploadAssets(data: APIMethodUploadAssets['data']): Promise<APIMethodUploadAssets['result']> {
        return this.contentStoreAdapter.uploadAssets(data);
    }

    async createPreset(data: APIMethodCreatePreset['data']): Promise<APIMethodCreatePreset['result']> {
        return this.editor.createPreset(this.appDir, data.fieldDataPath, _.omit(data, ['fieldDataPath', 'user', 'dryRun']) as any, data.dryRun, data.user);
    }

    async deletePreset(data: APIMethodDeletePreset['data']): Promise<APIMethodDeletePreset['result']> {
        return this.editor.deletePreset(this.appDir, data.presetId, data.user);
    }

    async getCustomActions(data: APIMethodGetCustomActions['data']): Promise<APIMethodGetCustomActions['result']> {
        return this.contentStoreAdapter.getCustomActions(data);
    }

    async runCustomAction(data: APIMethodRunCustomAction['data']): Promise<APIMethodRunCustomAction['result']> {
        return this.contentStoreAdapter.runCustomAction(data);
    }

    async getDocumentVersions(data: APIMethodGetDocumentVersions['data']): Promise<APIMethodGetDocumentVersions['result']> {
        return this.editor.getDocumentVersions(data);
    }

    async getDocumentForVersion(data: APIMethodGetDocumentForVersion['data']): Promise<APIMethodGetDocumentForVersion['result']> {
        return this.editor.getDocumentForVersion(data);
    }

    async makeAction(action: string, data: any): Promise<any> {
        switch (action) {
            case 'createPage':
                return this.contentStoreAdapter.createObject_deprecated(data);
            case 'duplicatePage':
                return this.contentStoreAdapter.duplicateObject_deprecated(data);
            case 'updatePage':
                return this.contentStoreAdapter.updateObject_deprecated(data);
            case 'deleteObject':
                return this.contentStoreAdapter.deleteObject_deprecated(data);
            case 'getAssets':
                return this.contentStoreAdapter.getAssets_deprecated(data);
            case 'uploadAssets':
                return this.contentStoreAdapter.uploadAssets(data);
            case 'createPreset':
                return this.editor.createPreset(
                    this.appDir,
                    data.fieldDataPath,
                    _.omit(data, ['fieldDataPath', 'user', 'dryRun']) as any,
                    data.user,
                    data.dryRun
                );
            case 'deletePreset':
                return this.editor.deletePreset(this.appDir, data.presetId, data.user);
            case 'hasAccess':
                // for old non csi git based projects
                return {
                    hasConnection: true,
                    hasPermissions: true
                };
            default:
                throw new Error('Unsupported Operation: ' + data.action);
        }
    }

    keepAlive() {
        this.contentStoreAdapter.keepAlive();
    }

    isCsiEnabled() {
        return this.contentStoreAdapter.isContentStoreEnabled();
    }

    getAssetFilePath(url: string) {
        const assetFilePath = this.contentStoreAdapter.getAssetFilePath(url);
        if (assetFilePath) {
            return path.join(this.rootDir, assetFilePath);
        }
        return assetFilePath;
    }

    async destroy() {
        this.watcher.close();
        await this.stackbitConfigResult?.destroy?.();
        await this.contentStoreAdapter?.destroy();
    }
}
