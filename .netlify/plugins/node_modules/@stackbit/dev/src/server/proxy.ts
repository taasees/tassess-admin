import _ from 'lodash';
import path from 'path';
import { Request, Router } from 'express';
import proxy from 'http-proxy-middleware';
import logger from '../services/logger';
import consts from '../consts';
import { createProxyModifyResponseMiddleware, isHtml, injectScript } from '@stackbit/dev-common/dist/utils/proxy-utils';
import { renderLoadingPage } from '@stackbit/dev-common/dist/utils/pages';
import config from '../config';
import Runner from '../runner';

export default function proxyMiddleware(router: Router, ssgHost: string, ssgPort: number, runner: Runner) {
    router.use((req, res, next) => {
        _.unset(req, 'headers.x-forwarded-proto');
        const rawHeaders = _.get(req, 'rawHeaders');
        const headerIndex = _.findIndex(rawHeaders, (headerValue) => headerValue.toLowerCase() === 'x-forwarded-proto');
        if (headerIndex > -1) {
            // remove the header key and value
            rawHeaders.splice(headerIndex, 2);
        }

        next();
    });
    router.use((req, res, next) => {
        res.set('Content-Security-Policy', `frame-ancestors *; `);
        next();
    });

    const proxyTargetUrl = ssgHost.toLowerCase().startsWith('http') ? `${ssgHost}:${ssgPort}` : `http://${ssgHost}:${ssgPort}`;

    const handlerProxyError = (err: any, req: any, res: any) => {
        if (err?.code === 'ECONNREFUSED' && res?.status) {
            renderLoadingPage(req, res, {
                assetsDir: path.join(__dirname, '../assets'),
                proxyUrl: proxyTargetUrl,
                proxyPath: req?.path || '',
                htmlMessage: '',
                status: 504,
                statusMessage: 'aa'
            });
        }
    };

    // visit https://github.com/chimurai/http-proxy-middleware#context-matching
    // for docs on how path matching works, it is different from express matching
    const directPaths = _.uniq(_.concat(consts.DEFAULT_DIRECT_PROXY_PATH, runner.getDirectPaths()));
    router.use(
        proxy(directPaths, {
            target: proxyTargetUrl,
            changeOrigin: runner.getDirectChangeOrigin(),
            ws: true,
            secure: false,
            logProvider: () => logger,
            logLevel: config.logLevel === 'debug' ? 'info' : 'silent',
            router: runner.getDirectRoutes() ?? [],
            onError: (err: any, req: any, res: any) => {
                logger.debug(`onError in direct proxy, request: ${req.method} ${req.url}, error: ${err.message}`, { error: err });
                handlerProxyError(err, req, res);
            }
        })
    );

    router.use(
        proxy({
            target: proxyTargetUrl,
            changeOrigin: true,
            secure: false,
            logProvider: () => logger,
            logLevel: config.logLevel === 'debug' ? 'info' : 'silent',
            onError: (err: any, req: any, res: any) => {
                logger.debug(`onError in main proxy, request: ${req.method} ${req.url}, error: ${err.message}`, { error: err });
                handlerProxyError(err, req, res);
            },
            selfHandleResponse: true,
            onProxyRes: createProxyModifyResponseMiddleware({
                logTagName: 'proxy',
                shouldModifyBody: (proxyRes: Request, req: Request) => {
                    return req.method === 'GET' && isHtml(proxyRes);
                },
                modifyBody: (body: string) => {
                    body = injectScript(body, config.snippetUrl);
                    return body;
                }
            })
        })
    );

    return router;
}
