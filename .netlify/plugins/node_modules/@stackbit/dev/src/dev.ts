import detectPort from 'detect-port';
import chalk from 'chalk';
import open from 'open';

import { start as startServer } from './server';
import { getUserId } from './services/user-config';
import logger from './services/logger';
import apiService from './services/api';
import { loadEnv } from './services/env';
import { checkAndLogNewerVersions } from '@stackbit/dev-common';

interface DevOptions {
    ssgPort: number;
    ssgHost: string;
    rootDir: string;
    runnableDir?: string;
    autoOpen?: boolean;
    cmsType?: string;
    csiEnabled?: boolean;
    csiWebhookUrl?: string;
    contentfulAccessToken?: string;
    contentfulSpaceIds?: [string];
    contentfulPreviewTokens?: [string];
    sanityToken?: string;
    sanityStudioPath?: string;
    sanityDataset?: string;
    sanityProjectId?: string;
    sanityStudioUrl?: string;
    cloudinaryCloudName?: string;
    cloudinaryApiKey?: string;
    aprimoTenant?: string;
    telemetryTrack?: (event: string, data?: any) => void;
    cliVersion?: string;
}

export async function start(options: DevOptions) {
    if (options.cliVersion) {
        logger.info(`Running Stackbit Dev (CLI v${options.cliVersion})`);
        await checkAndLogNewerVersions({
            dir: options.rootDir,
            knownVersions: {
                '@stackbit/cli': options.cliVersion
            },
            logger
        });
    }

    logger.info('Site directory: ' + options.rootDir);

    await loadEnv(options.rootDir, logger).catch((err) => {
        logger.error('Error loading env', { err });
    });

    const serverPort = await detectPort(8090);
    const userId = getUserId();
    // Print the localId to allow developer set STACKBIT_API_KEY and use it to call /_stackbit/getCSIDocuments
    logger.info('localId: ' + userId);

    const localDetails: any = {
        i: userId,
        p: serverPort,
        v: require('../package.json').version,
        cms: options.cmsType || 'git'
    };

    options.telemetryTrack?.('Stackbit Dev Start', {
        ...getAnalyticsProperties(localDetails),
        inputDir: options.rootDir
    });

    if (options.contentfulSpaceIds) {
        localDetails.spaceIds = options.contentfulSpaceIds;
    }
    if (options.sanityProjectId) {
        localDetails.projectId = options.sanityProjectId;
    }
    if (options.cloudinaryCloudName && options.cloudinaryApiKey) {
        localDetails.cloudinary = {
            cloudName: options.cloudinaryCloudName,
            apiKey: options.cloudinaryApiKey
        };
    }
    if (options.aprimoTenant) {
        localDetails.aprimo = {
            tenant: options.aprimoTenant
        };
    }
    if (process.env.CSI_ENABLED) {
        logger.debug('CSI Enabled');
        options.csiEnabled = true;
    }
    if (process.env.CSI_WEBHOOK_URL) {
        options.csiWebhookUrl = process.env.CSI_WEBHOOK_URL;
    }

    try {
        const runner = await startServer({
            serverPort,
            uuid: userId,
            localDetails,
            ...options
        });
        localDetails.csi = runner.isCsiEnabled();
    } catch (err: any) {
        const errorMessage = 'Error starting Stackbit dev server';
        if (err?.stack) {
            logger.error(`${errorMessage}:\n${err.stack}`);
        } else if (err?.message) {
            logger.error(`${errorMessage}: ${err.message}`);
        } else {
            logger.error(errorMessage, { err });
        }

        options.telemetryTrack?.('Stackbit Dev Start Error', {
            ...getAnalyticsProperties(localDetails),
            err: err?.message,
            inputDir: options.rootDir
        });

        // give telemtry a chance to flush, and then exit
        setTimeout(() => {
            process.exit(1);
        }, 2000);

        return false;
    }

    logger.debug('Local details', { localDetails });
    const studioUrl = `http://localhost:${serverPort}/_stackbit`;
    try {
        const result = await apiService.updateLocalDev(userId, localDetails);
        logger.debug('update local details result', { result: result?.status });
    } catch (err: any) {
        // failure here is expected if user hasn't pressed the link yet.
        // in that case we defer the update to when the server starts getting accessed.
        logger.debug('updateLocalDev failed', { err: err.message || err });
    }

    logger.info(`Server started. Forwarding requests to: ${options.ssgHost}:${options.ssgPort}`);
    logger.info(`âš¡ Open${options.autoOpen ? 'ing' : ''} ${chalk.bold(studioUrl)} in your browser`);

    if (options.autoOpen) {
        open(studioUrl).catch((err) => {
            logger.debug('Auto open error', { err });
            logger.error('Error auto opening');
        });
    }
}

function getAnalyticsProperties(localDetails: any) {
    return {
        user_id: localDetails.i,
        dev_version: localDetails.v,
        port: localDetails.p,
        cms: localDetails.cms
    };
}
