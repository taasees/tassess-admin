"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVirtualSlugFieldName = exports.isVirtualSlug = exports.getFieldNameFromVirtualSlug = exports.generateDocumentId = exports.getFilePathFromSlugContext = exports.convertDocument = exports.convertAsset = exports.assetValueToAssetId = exports.replaceAssetIdsWithAssetValues = exports.assetIdToAssetValue = exports.getAssetDir = exports.isPrefixedAssetId = exports.SLUG_FIELD_PREFIX = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const artisanal_names_1 = __importDefault(require("@stackbit/artisanal-names"));
const uuid_1 = require("uuid");
const utils_1 = require("./utils");
const sdk_1 = require("@stackbit/sdk");
const utils_2 = require("@stackbit/utils");
exports.SLUG_FIELD_PREFIX = '_filePath_';
const ASSET_ID_PREFIX = 'stackbit_asset_id';
function isPrefixedAssetId(assetId) {
    return typeof assetId === 'string' && assetId.startsWith(ASSET_ID_PREFIX + ':');
}
exports.isPrefixedAssetId = isPrefixedAssetId;
function getAssetDir(assetsConfig) {
    return assetsConfig.referenceType === 'static' ? assetsConfig.staticDir : assetsConfig.assetsDir;
}
exports.getAssetDir = getAssetDir;
/**
 * @param assetFilePath Asset file path relative to {@link Assets.staticDir} or {@link Assets.assetsDir}.
 * @param referenceType The {@link Assets.referenceType}.
 */
function getAssetId({ assetFilePath, referenceType }) {
    return `${ASSET_ID_PREFIX}:${referenceType}:${assetFilePath}`;
}
/**
 * Computes the field value from the asset ID.
 *
 * For "static" referenceType assets, the reference to the asset is stored
 * relative to the {@link Assets.staticDir} prefixed by {@link Assets.publicPath}.
 * For example, if the assetConfig is:
 * ```js
 * {
 *     referenceType: 'static',
 *     staticDir: 'public',
 *     publicPath: '/assets'
 * }
 * ```
 * and the asset file is located at public/images/example.png, then the stored
 * value will be '/assets/images/example.png'.
 *
 * For "relative" referenceType assets, the reference to the asset is stored
 * relative to the document containing the asset. For example, if the document
 * containing the asset is located at content/pages/page.md, and it references an
 * asset located at content/images/example.png, then the stored field value will
 * be '../images/example.png'.
 *
 * @param assetId The asset ID in ASSET_ID_PREFIX:REFERENCE_TYPE:ASSET_FILE_PATH format.
 *   The ASSET_FILE_PATH is relative to project folder.
 * @param documentDir The directory of the document containing the asset.
 * @param assetsConfig The {@link Assets.referenceType}.
 */
function assetIdToAssetValue(assetId, documentDir, assetsConfig) {
    const [, assetReferenceType, ...assetFilePathParts] = assetId.split(':');
    const assetFilePath = assetFilePathParts.join('');
    if (assetReferenceType === 'static') {
        const staticDir = lodash_1.default.trim(assetsConfig.staticDir, '/');
        return path_1.default.join(assetsConfig.publicPath ?? '', path_1.default.relative(staticDir, assetFilePath));
    }
    else {
        if (!documentDir) {
            // When creating documents, the document file path isn't known.
            // Return the assetId as-is, then iterate over the data again
            // using replaceAssetIdsWithAssetValues replacing assetIds with
            // the actual value.
            return assetId;
        }
        return path_1.default.relative(documentDir, assetFilePath);
    }
}
exports.assetIdToAssetValue = assetIdToAssetValue;
function replaceAssetIdsWithAssetValues(data, documentDir, assetsConfig) {
    if (!assetsConfig || assetsConfig.referenceType !== 'relative') {
        return data;
    }
    return (0, utils_2.deepMap)(data, (value) => {
        if (isPrefixedAssetId(value)) {
            return assetIdToAssetValue(value, documentDir, assetsConfig);
        }
        return value;
    });
}
exports.replaceAssetIdsWithAssetValues = replaceAssetIdsWithAssetValues;
/**
 * Inverse function to assetIdToAssetValue
 *
 * @param value The stored asset value
 * @param documentDir The directory of the document containing the asset.
 * @param assetsConfig The {@link Assets.referenceType}.
 */
function assetValueToAssetId(value, documentDir, assetsConfig) {
    if (assetsConfig.referenceType === 'static') {
        if (value.startsWith(assetsConfig.publicPath)) {
            value = value.substring(assetsConfig.publicPath.length);
            value = lodash_1.default.trim(value, '/');
        }
        return getAssetId({
            assetFilePath: path_1.default.join(assetsConfig.staticDir, value),
            referenceType: assetsConfig.referenceType
        });
    }
    else {
        const assetFilePath = path_1.default.join(documentDir, value);
        return getAssetId({
            assetFilePath: assetFilePath,
            referenceType: assetsConfig.referenceType
        });
    }
}
exports.assetValueToAssetId = assetValueToAssetId;
/**
 * @param assetFilePath Asset file path relative to project directory.
 * @param absAssetFilePath Absolute asset file path.
 * @param assetsConfig The {@link Assets} config.
 */
async function convertAsset({ assetFilePath, absProjectDir, assetsConfig }) {
    const absAssetFilePath = path_1.default.join(absProjectDir, assetFilePath);
    const stats = await fs_extra_1.default.stat(absAssetFilePath);
    const displayName = path_1.default.basename(absAssetFilePath);
    return {
        type: 'asset',
        id: getAssetId({
            assetFilePath: assetFilePath,
            referenceType: assetsConfig.referenceType
        }),
        context: {
            filePath: assetFilePath
        },
        ...(await (0, utils_1.getFileDates)(absAssetFilePath)),
        manageUrl: '',
        status: 'published',
        fields: {
            file: {
                dimensions: {},
                type: 'assetFile',
                url: assetFilePath,
                fileName: displayName,
                size: stats.size
            },
            title: {
                type: 'string',
                value: displayName
            }
        }
    };
}
exports.convertAsset = convertAsset;
async function convertDocument(options) {
    const { filePath, fullFilePath, data, getModelByName, assetsConfig, fileIdKey } = options;
    const { type, ...fields } = data;
    const model = getModelByName(type);
    if (!model) {
        return null;
    }
    const documentFields = convertFields({
        dataFields: fields,
        modelFields: model.fields ?? [],
        getModelByName,
        assetsConfig,
        docFilePath: filePath,
        docFieldPath: [],
        logger: options.logger
    });
    if (((0, sdk_1.isPageModel)(model) || (0, sdk_1.isDataModel)(model)) && model.filePath && typeof model.filePath === 'string') {
        const slugTemplate = getSlugTemplate(model, model.filePath, path_1.default.dirname(filePath));
        const tokensAndValues = (0, utils_1.extractTokensAndValuesFromFilePath)(filePath, slugTemplate);
        for (const [token, value] of Object.entries(tokensAndValues)) {
            // only extract values for virtual slug fields
            if (documentFields[token]) {
                continue;
            }
            documentFields[createVirtualSlugFieldName(token)] = {
                type: 'slug',
                value: value || '/'
            };
        }
    }
    return {
        type: 'document',
        id: fileIdKey ? data[fileIdKey] ?? filePath : filePath,
        modelName: model.name,
        manageUrl: '',
        status: 'published',
        context: {
            filePath
        },
        ...(await (0, utils_1.getFileDates)(fullFilePath)),
        fields: documentFields
    };
}
exports.convertDocument = convertDocument;
function convertFields({ dataFields, modelFields, getModelByName, assetsConfig, docFilePath, docFieldPath, logger }) {
    const result = {};
    for (const [fieldName, fieldValue] of Object.entries(dataFields)) {
        const modelField = (modelFields ?? []).find((modelField) => modelField.name === fieldName);
        if (!modelField || lodash_1.default.isNil(fieldValue)) {
            continue;
        }
        const documentField = convertFieldType({
            fieldValue,
            modelField,
            getModelByName,
            assetsConfig,
            docFilePath,
            docFieldPath: docFieldPath.concat(fieldName),
            logger
        });
        if (documentField) {
            result[fieldName] = documentField;
        }
    }
    return result;
}
function convertFieldType({ fieldValue, modelField, getModelByName, assetsConfig, docFilePath, docFieldPath, logger }) {
    function errorMessage(message) {
        return `Error converting value in file '${docFilePath}' at field path '${docFieldPath.join('.')}' of declared type '${modelField.type}'. ${message}`;
    }
    const localized = !!('localized' in modelField && modelField.localized);
    switch (modelField.type) {
        case 'string':
        case 'url':
        case 'slug':
        case 'text':
        case 'markdown':
        case 'html':
        case 'number':
        case 'boolean':
        case 'date':
        case 'datetime':
        case 'color':
        case 'json':
        case 'richText':
        case 'file':
        case 'enum':
        case 'style': {
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: modelField.type
                },
                specificFieldProps: (value) => ({ value })
            });
        }
        case 'list': {
            const itemsModel = modelField.items ?? { type: 'string' };
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: 'list'
                },
                specificFieldProps: (value, locale) => {
                    if (!Array.isArray(value)) {
                        logger.error(errorMessage(`Value is not an array - ${value}.`));
                        return;
                    }
                    return {
                        items: lodash_1.default.reduce(value, (items, item, index) => {
                            const documentField = convertFieldType({
                                fieldValue: item,
                                modelField: itemsModel,
                                getModelByName,
                                assetsConfig,
                                docFilePath,
                                docFieldPath: docFieldPath.concat(locale ? [locale, index] : [index]),
                                logger
                            });
                            if (!documentField) {
                                logger.error(errorMessage('One of the list items could not be converted, ignoring the while list.'));
                                return items;
                            }
                            return items.concat(documentField);
                        }, [])
                    };
                }
            });
        }
        case 'object': {
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: 'object'
                },
                specificFieldProps: (value, locale) => ({
                    fields: convertFields({
                        dataFields: value,
                        modelFields: modelField.fields,
                        getModelByName,
                        assetsConfig,
                        docFilePath,
                        docFieldPath: locale ? docFieldPath.concat(locale) : docFieldPath,
                        logger
                    })
                })
            });
        }
        case 'model': {
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: 'model'
                },
                specificFieldProps: (value, locale) => {
                    const { type, ...fields } = value;
                    let modelName;
                    if (type) {
                        modelName = type;
                    }
                    else if (modelField.models?.length === 1) {
                        modelName = modelField.models[0];
                    }
                    else {
                        logger.error(errorMessage(`The object doesn't have the 'type' field, and the model name cannot be inferred ` +
                            `from field's allowed models ${(modelField.models ?? []).join('.')}.`));
                        return;
                    }
                    const model = getModelByName(modelName);
                    if (!model) {
                        logger.error(errorMessage(`No model found with name: ${modelName}.`));
                        return;
                    }
                    return {
                        modelName: model.name,
                        fields: convertFields({
                            dataFields: fields,
                            modelFields: model.fields ?? [],
                            getModelByName,
                            assetsConfig,
                            docFilePath,
                            docFieldPath: locale ? docFieldPath.concat(locale) : docFieldPath,
                            logger
                        })
                    };
                }
            });
        }
        case 'cross-reference':
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: 'cross-reference',
                    refType: 'document'
                },
                specificFieldProps: (value) => value
            });
        case 'reference':
            return convertValueToDocumentField({
                fieldValue,
                localized,
                baseFieldProps: {
                    type: 'reference',
                    refType: 'document'
                },
                specificFieldProps: (value) => ({ refId: value })
            });
        case 'image': {
            if (modelField.source) {
                return convertValueToDocumentField({
                    fieldValue,
                    localized,
                    baseFieldProps: {
                        type: 'image',
                        source: modelField.source
                    },
                    specificFieldProps: (value) => ({ sourceData: value })
                });
            }
            if (localized) {
                return {
                    type: 'reference',
                    refType: 'asset',
                    localized: true,
                    locales: lodash_1.default.reduce(fieldValue, (locales, value, locale) => {
                        if (typeof value !== 'string') {
                            logger.error(errorMessage(`Value is not a string.`));
                            return locales;
                        }
                        return {
                            ...locales,
                            [locale]: {
                                locale,
                                refId: assetsConfig ? assetValueToAssetId(value, path_1.default.dirname(docFilePath), assetsConfig) : value
                            }
                        };
                    }, {})
                };
            }
            if (typeof fieldValue !== 'string') {
                logger.error(errorMessage(`Value is not a string.`));
                return;
            }
            const normalizedValue = fieldValue?.toLowerCase();
            if (normalizedValue.startsWith('http:') || normalizedValue.startsWith('https:') || normalizedValue.startsWith('//')) {
                return {
                    type: 'image',
                    fields: {
                        title: {
                            type: 'string',
                            value: fieldValue?.split('/').slice(-1)[0] || fieldValue
                        },
                        url: {
                            type: 'string',
                            value: fieldValue
                        }
                    }
                };
            }
            return {
                type: 'reference',
                refType: 'asset',
                refId: assetsConfig ? assetValueToAssetId(fieldValue, path_1.default.dirname(docFilePath), assetsConfig) : fieldValue
            };
        }
        default: {
            logger.error('Unsupported field type: ' + modelField.type);
            const _exhaustiveCheck = modelField;
            return _exhaustiveCheck;
        }
    }
}
function convertValueToDocumentField({ fieldValue, localized, baseFieldProps, specificFieldProps }) {
    if (localized) {
        return {
            ...baseFieldProps,
            localized: true,
            locales: lodash_1.default.reduce(fieldValue, (locales, value, locale) => {
                const specific = specificFieldProps(value, locale);
                if (typeof specific === 'undefined') {
                    return locales;
                }
                return {
                    ...locales,
                    [locale]: {
                        locale,
                        ...specific
                    }
                };
            }, {})
        };
    }
    const specific = specificFieldProps(fieldValue);
    if (typeof specific === 'undefined') {
        return undefined;
    }
    return {
        ...baseFieldProps,
        ...specific
    };
}
function getSlugTemplate(model, modelFilePath, contentDir) {
    const extension = model.type === 'page' ? '.md' : '.json';
    return modelFilePath || `${contentDir}{slug}${extension}`;
}
async function getFilePathFromSlugContext({ model, context, contentDir, locale, generateFallback }) {
    let filePath = null;
    if (typeof model.filePath === 'function') {
        return model.filePath({
            data: context,
            model: model,
            currentLocale: locale
        });
    }
    else if (model.filePath) {
        const slugTemplate = getSlugTemplate(model, model.filePath, contentDir);
        const fullContext = { ...context };
        const slugTokens = (0, utils_1.extractTokensFromString)(slugTemplate);
        for (const token of slugTokens) {
            if (lodash_1.default.isUndefined(context[token])) {
                if (!generateFallback) {
                    return null;
                }
                fullContext[token] = artisanal_names_1.default.generate();
            }
        }
        filePath = (0, utils_1.interpolatePath)(slugTemplate, fullContext);
        // special handling for index.md
        if (filePath === '.md' || filePath.endsWith('/.md')) {
            filePath = path_1.default.join(path_1.default.dirname(filePath), 'index.md');
        }
    }
    return filePath;
}
exports.getFilePathFromSlugContext = getFilePathFromSlugContext;
function generateDocumentId() {
    return `doc.${(0, uuid_1.v4)().replace(/-/g, '').slice(0, 16)}`;
}
exports.generateDocumentId = generateDocumentId;
function getFieldNameFromVirtualSlug(fieldName) {
    return fieldName.replace(new RegExp(`^${exports.SLUG_FIELD_PREFIX}`), '');
}
exports.getFieldNameFromVirtualSlug = getFieldNameFromVirtualSlug;
function isVirtualSlug(fieldName) {
    return fieldName.startsWith(exports.SLUG_FIELD_PREFIX);
}
exports.isVirtualSlug = isVirtualSlug;
function createVirtualSlugFieldName(fieldName) {
    return `${exports.SLUG_FIELD_PREFIX}${fieldName}`;
}
exports.createVirtualSlugFieldName = createVirtualSlugFieldName;
//# sourceMappingURL=content-converter.js.map