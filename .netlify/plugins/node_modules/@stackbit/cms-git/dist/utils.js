"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFilesFromDirectory = exports.forEachFieldInFields = exports.forEachFieldInDocument = exports.extractTokensAndValuesFromFilePath = exports.processMarkdownImagePaths = exports.saveFromUrl = exports.saveBase64Data = exports.saveFileData = exports.getFileData = exports.getFileDates = exports.interpolatePath = exports.extractTokensFromString = exports.convertToRegularTokens = exports.sanitizeSlug = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const slugify_1 = __importDefault(require("slugify"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const cms_core_1 = require("@stackbit/cms-core");
const stream_1 = require("stream");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("@stackbit/utils");
const sdk_1 = require("@stackbit/sdk");
const MARKDOWN_FILE_EXTENSIONS = ['md', 'mdx', 'markdown'];
function sanitizeSlug(slug) {
    return slug
        .split('/')
        .map((part) => (0, slugify_1.default)(part, { lower: true }))
        .join('/');
}
exports.sanitizeSlug = sanitizeSlug;
function convertToRegularTokens(input) {
    return input.replace(/%([^%]+)%/g, (match, tokenName) => `{${tokenName}}`);
}
exports.convertToRegularTokens = convertToRegularTokens;
function extractTokensFromString(input) {
    return input.match(/(?<={)[^}]+(?=})/g) || [];
}
exports.extractTokensFromString = extractTokensFromString;
/**
 * Interpolates url or file path pattern from data.
 * If token does not exist in data returns original token.
 *
 * @example
 * interpolateFileName('posts/{slug}', { slug: 'hello' })
 * => 'posts/hello'
 * interpolateFileName('_posts/{moment_format("YYYY-MM-DD")}-{slug}.md', { slug: 'hello' })
 * => '_posts/2020-11-16-hello.md'
 *
 * @param {string} pathTemplate
 * @param {Object} data
 * @return {string}
 */
function interpolatePath(pathTemplate, data) {
    const interpolatedPath = convertToRegularTokens(pathTemplate).replace(/{(.*?)}/g, (match, tokenName) => {
        return sanitizeSlug(lodash_1.default.get(data, tokenName, `{${tokenName}}`));
    });
    return path_1.default.normalize(interpolatedPath);
}
exports.interpolatePath = interpolatePath;
async function getFileDates(filePath) {
    let fileStats = null;
    try {
        fileStats = await fs_extra_1.default.stat(filePath);
    }
    catch (err) {
        // pass
    }
    return {
        createdAt: (fileStats?.birthtime ?? fileStats?.mtime ?? new Date()).toISOString(),
        updatedAt: (fileStats?.mtime ?? new Date()).toISOString()
    };
}
exports.getFileDates = getFileDates;
async function getFileData(filePath) {
    const extension = path_1.default.extname(filePath).substring(1);
    let data = await cms_core_1.utils.parseFile(filePath);
    if (MARKDOWN_FILE_EXTENSIONS.includes(extension) && lodash_1.default.has(data, 'frontmatter') && lodash_1.default.has(data, 'markdown')) {
        data = {
            ...data.frontmatter,
            markdown_content: data.markdown
        };
    }
    return data;
}
exports.getFileData = getFileData;
async function saveFileData(filePath, data) {
    let dataToWrite = data;
    const extension = path_1.default.extname(filePath).substring(1);
    if (MARKDOWN_FILE_EXTENSIONS.includes(extension)) {
        const existingData = (await fs_extra_1.default.pathExists(filePath)) ? await cms_core_1.utils.parseFile(filePath) : {};
        dataToWrite = {
            ...existingData,
            markdown: data.markdown_content,
            frontmatter: lodash_1.default.omit(data, ['markdown_content'])
        };
    }
    return cms_core_1.utils.outputDataIfNeeded(filePath, dataToWrite);
}
exports.saveFileData = saveFileData;
async function saveBase64Data(filePath, data) {
    const buffer = Buffer.from(data, 'base64');
    const readStream = stream_1.Readable.from(buffer);
    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));
    const writeStream = fs_extra_1.default.createWriteStream(filePath);
    readStream.pipe(writeStream);
    return new Promise((resolve, reject) => {
        writeStream.on('error', reject).on('finish', resolve);
    });
}
exports.saveBase64Data = saveBase64Data;
async function saveFromUrl(filePath, url) {
    const response = await (0, axios_1.default)({
        responseType: 'stream',
        url
    });
    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));
    const writeStream = fs_extra_1.default.createWriteStream(filePath);
    response.data.pipe(writeStream);
    return new Promise((resolve, reject) => {
        writeStream.on('error', reject).on('finish', resolve);
    });
}
exports.saveFromUrl = saveFromUrl;
function processMarkdownImagePaths(markdown, handler) {
    const re = /(!\[[^\]]*])\(([^)\s]+?)(\s+"[^"]*")?\)/g;
    let reResult;
    let result = '';
    let lastIndex = 0;
    while ((reResult = re.exec(markdown)) !== null) {
        const altText = reResult[1];
        const path = handler(reResult[2]);
        const title = reResult[3] || '';
        result += markdown.substring(lastIndex, reResult.index);
        result += `${altText}(${path}${title})`;
        lastIndex = re.lastIndex;
    }
    result += markdown.substring(lastIndex);
    return result;
}
exports.processMarkdownImagePaths = processMarkdownImagePaths;
function extractTokensAndValuesFromFilePath(filePath, filePathPattern) {
    // filePath: '_posts/2020-11-04-hello.md'
    // filePathPattern: '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md'
    const usedTokens = {};
    const regExpStr = filePathPattern
        // escape characters that may conflict with regular expression
        .replace(/[\\.*+\-?^$|()[\]]/g, '\\$&')
        // replace tokens with named capturing group: (?<token>x)
        .replace(/{([^}]+)}(\/?)/g, (match, tokenName, slashAfter, offset) => {
        // if token was used, assume it has the same value
        // _posts/{slug}/{moment_format("YYYY-MM-DD")}-{slug}.md
        // _posts/welcome-to-jekyll/2020-08-29-welcome-to-jekyll.md
        if (lodash_1.default.has(usedTokens, tokenName)) {
            return `(?:.+?)${slashAfter}`;
        }
        usedTokens[tokenName] = true;
        // if token is left and right bounded by slashes or the beginning
        // of the string: /pages/{slug}/index.md, then generate regular
        // expression that puts the whole token with the following slash
        // as an optional match: /\/pages\/(?:(?<slug>.+?)/)?\/index.md/
        // Such that the following file path will match '/pages/index.md'
        // this regular expression and produce a match with 'undefined' slug
        // named capturing group which will be converted to an empty string.
        const tokenLeftBounded = offset === 0 || filePathPattern[offset - 1] === '/';
        const tokenRightBounded = slashAfter === '/';
        if (tokenLeftBounded && tokenRightBounded) {
            return `(?:(?<${tokenName}>.+?)/)?`;
        }
        return `(?<${tokenName}>.+?)${slashAfter}`;
    });
    // regExpStr = '_posts/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md'
    const regExp = new RegExp(regExpStr);
    // regExp = /_posts\/(?<moment_date>\d+-\d+-\d+)-(?<slug>.+?)\.md/
    const match = regExp.exec(filePath);
    // match.groups = {slug: 'hello', moment_date: <DateString>}
    return lodash_1.default.mapValues(match?.groups, (value) => (typeof value === 'undefined' ? '' : value));
}
exports.extractTokensAndValuesFromFilePath = extractTokensAndValuesFromFilePath;
async function forEachFieldInDocument(document, handler) {
    return forEachFieldInFields(document.fields, [], handler);
}
exports.forEachFieldInDocument = forEachFieldInDocument;
async function forEachFieldInFields(documentFields, fieldPath, handler) {
    for (const [fieldName, field] of Object.entries(documentFields)) {
        await forEachField(field, fieldPath.concat(fieldName), handler);
    }
}
exports.forEachFieldInFields = forEachFieldInFields;
async function forEachField(documentField, fieldPath, handler) {
    switch (documentField.type) {
        case 'string':
        case 'text':
        case 'html':
        case 'slug':
        case 'url':
        case 'color':
        case 'boolean':
        case 'number':
        case 'date':
        case 'datetime':
        case 'enum':
        case 'file':
        case 'json':
        case 'style':
        case 'markdown':
        case 'image':
        case 'reference':
        case 'cross-reference':
        case 'richText': {
            if (documentField.localized) {
                if (lodash_1.default.isEmpty(documentField.locales)) {
                    return;
                }
                for (const locale of Object.values(documentField.locales)) {
                    await handler(locale, fieldPath.concat(locale.locale));
                }
            }
            else {
                await handler(documentField, fieldPath);
            }
            break;
        }
        case 'model':
        case 'object': {
            if (documentField.localized) {
                if (lodash_1.default.isEmpty(documentField.locales)) {
                    return;
                }
                for (const locale of Object.values(documentField.locales)) {
                    await forEachFieldInFields(locale.fields, fieldPath.concat(locale.locale), handler);
                }
            }
            else {
                await forEachFieldInFields(documentField.fields, fieldPath, handler);
            }
            break;
        }
        case 'list': {
            if (documentField.localized) {
                if (lodash_1.default.isEmpty(documentField.locales)) {
                    return;
                }
                for (const locale of Object.values(documentField.locales)) {
                    for (const [index, item] of locale.items.entries()) {
                        await forEachField(item, fieldPath.concat(locale.locale, index), handler);
                    }
                }
            }
            else {
                for (const [index, item] of documentField.items.entries()) {
                    await forEachField(item, fieldPath.concat(index), handler);
                }
            }
            break;
        }
        default: {
            const _exhaustiveCheck = documentField;
            return _exhaustiveCheck;
        }
    }
}
async function readFilesFromDirectory(directoryPath, logger, handler) {
    const filePaths = await (0, utils_1.readDirRecursivelyWithExtensions)(directoryPath, sdk_1.SUPPORTED_FILE_EXTENSIONS);
    for (const filePath of filePaths) {
        const fullFilePath = path_1.default.join(directoryPath, filePath);
        let data;
        try {
            data = await getFileData(fullFilePath);
            await handler(filePath, fullFilePath, data);
        }
        catch (err) {
            logger.warn('Error loading file: ' + filePath, err);
            continue;
        }
    }
}
exports.readFilesFromDirectory = readFilesFromDirectory;
//# sourceMappingURL=utils.js.map