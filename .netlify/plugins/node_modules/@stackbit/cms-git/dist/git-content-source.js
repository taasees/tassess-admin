"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitContentSource = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const git_url_parse_1 = __importDefault(require("git-url-parse"));
const stackbitUtils = __importStar(require("@stackbit/types"));
const fs_content_source_1 = require("./fs-content-source");
const content_converter_1 = require("./content-converter");
const DEFAULT_AUTHOR_EMAIL = 'projects@stackbit.com';
class GitContentSource {
    constructor(options) {
        this.fileSystemContentSource = new fs_content_source_1.FileSystemContentSource(options);
        this.rootPath = options.rootPath;
        this.projectUrl = '';
    }
    async getVersion() {
        return stackbitUtils.getVersion({ packageJsonPath: path_1.default.join(__dirname, '../package.json') });
    }
    async init(options) {
        this.git = options.git;
        this.localDev = options.localDev;
        this.logger = options.logger.createLogger({ label: 'cms-git' });
        this.cache = options.cache;
        let repoUrl = this.git.getRepoUrl();
        const repoBranch = this.git.getRepoBranch();
        if (repoUrl) {
            // remove user/pass from url before passing to gitUrlParse
            repoUrl = repoUrl.replace(/\/\/.*?@/, '//');
            try {
                const gitUrlResult = (0, git_url_parse_1.default)(repoUrl);
                let gitUrlResource = gitUrlResult.resource;
                let gitUrlFullName = gitUrlResult.full_name;
                let path = '';
                if (gitUrlResource === 'github.com') {
                    path = `/blob/${repoBranch}/`;
                }
                else if (gitUrlResource === 'gitlab.com') {
                    path = `/-/blob/${repoBranch}/`;
                }
                else if (gitUrlResource === 'bitbucket.org') {
                    path = `/src/${repoBranch}/`;
                }
                else if (gitUrlResource === 'dev.azure.com') {
                    gitUrlResource = 'dev.azure.com';
                    path = '?path=';
                }
                else if (gitUrlResource === 'ssh.dev.azure.com') {
                    gitUrlResource = 'dev.azure.com';
                    gitUrlFullName = `${gitUrlResult.organization}/${gitUrlResult.owner}/_git/${gitUrlResult.name}`;
                    path = '?path=';
                }
                this.projectUrl = 'https://' + gitUrlResource + '/' + gitUrlFullName + path;
            }
            catch (err) {
                this.logger.warn('Failed to parse repo url', { repoUrl, err });
            }
        }
        this.environment = 'preview';
        if (repoBranch) {
            this.environment = repoBranch;
        }
        this.onGitPull = this.onGitPull.bind(this);
        await this.fileSystemContentSource.init({
            ...options,
            cache: {
                ...options.cache,
                updateContent: async (contentChanges) => {
                    const changesMap = await this.getChangesMap();
                    return options.cache.updateContent({
                        ...contentChanges,
                        documents: (contentChanges.documents ?? []).map((document) => ({
                            ...document,
                            ...changesMap?.[document.context.filePath]
                        })),
                        assets: (contentChanges.assets ?? []).map((asset) => {
                            const filePath = this.getAssetFilePath(asset);
                            return {
                                ...asset,
                                ...(filePath ? changesMap?.[filePath] : {})
                            };
                        })
                    });
                }
            }
        });
    }
    async destroy() {
        await this.fileSystemContentSource.destroy();
    }
    async reset() {
        await this.fileSystemContentSource.reset();
    }
    getCommitAuthor(userContext) {
        return {
            email: userContext?.email ?? DEFAULT_AUTHOR_EMAIL,
            name: userContext?.name ?? 'Stackbit'
        };
    }
    getCommitMessage(updateOperations) {
        const diff = (updateOperation) => {
            let result = 'updated';
            const path = lodash_1.default.filter(updateOperation.fieldPath, (part) => lodash_1.default.isString(part)); // skip array indexes
            const [field = null, parent = null] = lodash_1.default.take(lodash_1.default.reverse(path), 2);
            if (field) {
                if (lodash_1.default.isString(field) && (0, content_converter_1.isVirtualSlug)(field)) {
                    result += ' ' + (0, content_converter_1.getFieldNameFromVirtualSlug)(field);
                }
                else {
                    result += ' ' + field;
                }
            }
            if (parent) {
                result += ' in ' + parent;
            }
            return result;
        };
        if (updateOperations.length > 1) {
            return 'Multiple updates:\n' + lodash_1.default.map(updateOperations, (updateOperation) => '* ' + diff(updateOperation)).join('\n');
        }
        else if (updateOperations.length) {
            return diff(updateOperations[0]);
        }
        return 'updated';
    }
    getContentSourceType() {
        return 'git';
    }
    getProjectId() {
        // user underlying content source's project id because git-service my not be available yet
        return this.fileSystemContentSource.getProjectId();
    }
    getProjectEnvironment() {
        return this.environment;
    }
    getProjectManageUrl() {
        return this.projectUrl;
    }
    onWebhook(data) { }
    async onFilesChange({ updatedFiles }) {
        this.logger.debug('onFilesChange', { updatedFiles });
        const result = await this.fileSystemContentSource.onFilesChange({ updatedFiles });
        if (this.localDev || !result.contentChanges) {
            return result;
        }
        const changesMap = await this.getChangesMap();
        return {
            ...result,
            contentChanges: {
                ...result.contentChanges,
                documents: (result.contentChanges.documents ?? []).map((document) => ({
                    ...document,
                    ...changesMap?.[document.context.filePath]
                })),
                assets: (result.contentChanges.assets ?? []).map((asset) => {
                    const filePath = this.getAssetFilePath(asset);
                    return {
                        ...asset,
                        ...(filePath ? changesMap?.[filePath] : {})
                    };
                })
            }
        };
    }
    async onGitPull({ branch, updatedFiles }) {
        this.logger.debug('onGitPull', { branch, updatedFiles });
        if (branch !== this.git.getRepoPublishBranch()) {
            return;
        }
        const result = await this.fileSystemContentSource.onFilesChange({ updatedFiles });
        if (!result.contentChanges) {
            return;
        }
        const changesMap = await this.getChangesMap();
        await this.cache.updateContent({
            ...result.contentChanges,
            documents: (result.contentChanges.documents ?? []).map((document) => ({
                ...document,
                ...changesMap?.[document.context.filePath]
            })),
            assets: (result.contentChanges.assets ?? []).map((asset) => {
                const filePath = this.getAssetFilePath(asset);
                return {
                    ...asset,
                    ...(filePath ? changesMap?.[filePath] : {})
                };
            })
        });
    }
    startWatchingContentUpdates() {
        this.fileSystemContentSource.startWatchingContentUpdates();
        this.git.addPullListener(this.onGitPull);
    }
    stopWatchingContentUpdates() {
        this.fileSystemContentSource.stopWatchingContentUpdates();
        this.git.removePullListener(this.onGitPull);
    }
    getSchema() {
        return this.fileSystemContentSource.getSchema();
    }
    async getDocuments() {
        const changesMap = await this.getChangesMap();
        const documents = await this.fileSystemContentSource.getDocuments();
        return documents.map((document) => {
            return {
                ...document,
                manageUrl: `${this.projectUrl}${document.context.filePath}`,
                ...changesMap?.[document.context.filePath]
            };
        });
    }
    async getAssets() {
        const changesMap = await this.getChangesMap();
        const assets = await this.fileSystemContentSource.getAssets();
        return assets.map((asset) => {
            const filePath = this.getAssetFilePath(asset);
            return {
                ...asset,
                manageUrl: `${this.projectUrl}${filePath}`,
                ...(filePath ? changesMap?.[filePath] : {})
            };
        });
    }
    getAssetFilePath(asset) {
        const relFilePath = asset.fields.file.localized === true ? asset.fields.file.locales[Object.keys(asset.fields.file.locales)[0] ?? '']?.url : asset.fields.file.url;
        if (!relFilePath) {
            return relFilePath;
        }
        return path_1.default.relative(this.git.getRepoDir(), path_1.default.join(this.rootPath, relFilePath));
    }
    getDocumentFilePath(document) {
        return path_1.default.relative(this.git.getRepoDir(), path_1.default.join(this.rootPath, document.context.filePath));
    }
    async hasAccess(options) {
        // we're assuming that we always have access to the repository
        return {
            hasConnection: true,
            hasPermissions: true
        };
    }
    async createDocument(options) {
        const document = await this.fileSystemContentSource.createDocument(options);
        if (!this.localDev) {
            await this.git.commitAndPush(this.getCommitAuthor(options.userContext), [
                {
                    filePath: this.getDocumentFilePath(document),
                    description: 'added'
                }
            ]);
            const updatedDocument = {
                ...document,
                status: 'added',
                ...this.getGitChange(document, 'added', options.userContext)
            };
            this.cache.updateContent({
                documents: [updatedDocument],
                assets: [],
                deletedDocumentIds: [],
                deletedAssetIds: []
            });
        }
        return { documentId: document.id };
    }
    async updateDocument(options) {
        const { document } = options;
        let updatedDocument = (await this.fileSystemContentSource.updateDocument(options));
        if (!this.localDev) {
            const files = [
                {
                    filePath: this.getDocumentFilePath(updatedDocument),
                    description: this.getCommitMessage(options.operations)
                }
            ];
            const deletedDocumentIds = [];
            if (document.context.filePath !== updatedDocument.context.filePath) {
                files.push({
                    filePath: this.getDocumentFilePath(document),
                    description: `moved to ${updatedDocument.context.filePath}`
                });
                deletedDocumentIds.push(document.id);
            }
            await this.git.commitAndPush(this.getCommitAuthor(options.userContext), files);
            const existingStatus = this.cache.getDocumentById(options.document.id)?.status;
            updatedDocument = {
                ...updatedDocument,
                ...this.getGitChange(updatedDocument, existingStatus === 'added' ? 'added' : 'modified', options.userContext)
            };
            this.cache.updateContent({
                documents: [updatedDocument],
                assets: [],
                deletedDocumentIds,
                deletedAssetIds: []
            });
        }
    }
    async deleteDocument(options) {
        const { document } = options;
        const result = await this.fileSystemContentSource.deleteDocument(options);
        if (!this.localDev) {
            await this.git.commitAndPush(this.getCommitAuthor(options.userContext), [
                {
                    filePath: this.getDocumentFilePath(document),
                    description: 'removed'
                }
            ]);
            this.cache.updateContent({
                documents: [],
                assets: [],
                deletedDocumentIds: [document.id],
                deletedAssetIds: []
            });
        }
        return result;
    }
    async uploadAsset(options) {
        let asset = await this.fileSystemContentSource.uploadAsset(options);
        if (!this.localDev) {
            const filePath = this.getAssetFilePath(asset);
            if (filePath) {
                await this.git.commitAndPush(this.getCommitAuthor(options.userContext), [
                    {
                        filePath,
                        description: 'uploaded asset'
                    }
                ]);
                asset = {
                    ...asset,
                    status: 'added',
                    ...this.getGitChange(asset, 'added', options.userContext)
                };
                this.cache.updateContent({
                    documents: [],
                    assets: [asset],
                    deletedDocumentIds: [],
                    deletedAssetIds: []
                });
            }
            else {
                this.logger.error('Error comitting uploaded asset');
            }
        }
        return asset;
    }
    async validateDocuments(options) {
        return this.fileSystemContentSource.validateDocuments(options);
    }
    async publishDocuments(options) {
        const { documents, assets } = options;
        await this.fileSystemContentSource.publishDocuments(options);
        const changesMap = await this.getChangesMap();
        if (!this.localDev) {
            const filePathsToPublish = [
                ...documents.map((document) => this.getDocumentFilePath(document)),
                ...assets.map((asset) => this.getAssetFilePath(asset) ?? '').filter(Boolean)
            ];
            let hasChanges = true;
            let filePaths;
            if (changesMap) {
                const changedFiles = Object.keys(lodash_1.default.pickBy(changesMap, (change) => change.status !== 'published')).reverse();
                hasChanges = !lodash_1.default.isEmpty(changedFiles);
                // if a file was moved, we need to publish both the old and new file
                for (const changedFile of changedFiles) {
                    // we're adding renamed files as we go through the changed files list in reverse order (most recent first)
                    if (filePathsToPublish.includes(changedFile) && changesMap[changedFile].fromFilePath) {
                        filePathsToPublish.push(changesMap[changedFile].fromFilePath);
                    }
                }
                const isFullSitePublish = lodash_1.default.isEmpty(lodash_1.default.xor(filePathsToPublish, changedFiles));
                // prefer full-site publish mechanism if we're publish all files anyways
                if (!isFullSitePublish) {
                    filePaths = filePathsToPublish;
                }
            }
            if (hasChanges) {
                await this.git.publish(this.getCommitAuthor(options.userContext), filePaths);
            }
            await this.cache.updateContent({
                documents: documents.map((document) => ({
                    ...document,
                    ...this.getGitChange(document, 'published', options.userContext)
                })),
                assets: assets.map((asset) => ({
                    ...asset,
                    ...this.getGitChange(asset, 'published', options.userContext)
                })),
                deletedDocumentIds: [],
                deletedAssetIds: []
            });
        }
    }
    getGitChange(object, status, userContext) {
        return {
            status,
            updatedAt: new Date().toISOString(),
            updatedBy: userContext?.email ? (object.updatedBy ?? []).concat(userContext.email) : object.updatedBy ?? []
        };
    }
    async getChangesMap() {
        const changesMap = {};
        if (this.localDev) {
            return changesMap;
        }
        const entries = await this.git.commitLog();
        const diff = await this.git.diff();
        for (const commitEntry of entries) {
            for (const { status, filePath, fromFilePath } of commitEntry.changes) {
                if (changesMap[filePath]) {
                    if (commitEntry.author !== DEFAULT_AUTHOR_EMAIL && !changesMap[filePath]?.updatedBy.includes(commitEntry.author)) {
                        // TODO RND-2251 - taking only last author as a workaround
                        changesMap[filePath].updatedBy = [commitEntry.author];
                    }
                    changesMap[filePath].updatedAt = commitEntry.timestamp.toISOString();
                    if (diff.includes(filePath)) {
                        const prevStatus = changesMap[filePath].status;
                        if (prevStatus === 'added' && status === 'deleted') {
                            delete changesMap[filePath];
                        }
                        else if (prevStatus !== 'added') {
                            changesMap[filePath].status = status;
                        }
                    }
                }
                else {
                    changesMap[filePath] = {
                        updatedBy: commitEntry.author === DEFAULT_AUTHOR_EMAIL ? [] : [commitEntry.author],
                        updatedAt: commitEntry.timestamp.toISOString(),
                        status: diff.includes(filePath) ? status : 'published',
                        fromFilePath
                    };
                }
            }
        }
        return changesMap;
    }
}
exports.GitContentSource = GitContentSource;
//# sourceMappingURL=git-content-source.js.map