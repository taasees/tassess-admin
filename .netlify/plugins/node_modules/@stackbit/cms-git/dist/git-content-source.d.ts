import type { Asset, ContentSourceInterface, Document, User, InitOptions, Model, UpdateOperation, UpdateOperationField, ValidationError, Version, Schema, ContentChanges } from '@stackbit/types';
import { FileSystemContentSourceOptions } from './fs-content-source';
import { DocumentContext, AssetContext } from './content-converter';
export type GitContentSourceOptions = FileSystemContentSourceOptions;
export declare class GitContentSource implements ContentSourceInterface<unknown, unknown, DocumentContext, AssetContext> {
    private readonly fileSystemContentSource;
    private readonly rootPath;
    private projectUrl;
    private environment;
    private git;
    private cache;
    private localDev;
    private logger;
    constructor(options: GitContentSourceOptions);
    getVersion(): Promise<Version>;
    init(options: InitOptions<unknown, DocumentContext, AssetContext>): Promise<void>;
    destroy(): Promise<void>;
    reset(): Promise<void>;
    private getCommitAuthor;
    private getCommitMessage;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    onWebhook(data: {
        data: unknown;
        headers: Record<string, string>;
    }): void;
    onFilesChange?({ updatedFiles }: {
        updatedFiles: string[];
    }): Promise<{
        invalidateSchema?: boolean;
        contentChanges?: ContentChanges<DocumentContext, AssetContext>;
    }>;
    private onGitPull;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    getSchema(): Promise<Schema>;
    getDocuments(): Promise<Document<DocumentContext>[]>;
    getAssets(): Promise<Asset<AssetContext>[]>;
    getAssetFilePath(asset: Asset): string | undefined;
    getDocumentFilePath(document: Document<DocumentContext>): string;
    hasAccess(options: {
        userContext?: User;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument(options: {
        updateOperationFields: Record<string, UpdateOperationField>;
        model: Model;
        locale?: string | undefined;
        defaultLocaleDocumentId?: string | undefined;
        userContext?: User;
    }): Promise<{
        documentId: string;
    }>;
    updateDocument(options: {
        document: Document<DocumentContext>;
        operations: UpdateOperation[];
        userContext?: User;
    }): Promise<void>;
    deleteDocument(options: {
        document: Document<DocumentContext>;
        userContext?: User;
    }): Promise<void>;
    uploadAsset(options: {
        url?: string | undefined;
        base64?: string | undefined;
        fileName: string;
        mimeType: string;
        locale?: string | undefined;
        userContext?: User;
    }): Promise<Asset<AssetContext>>;
    validateDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        locale?: string | undefined;
        userContext?: User;
    }): Promise<{
        errors: ValidationError[];
    }>;
    publishDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        userContext?: User;
    }): Promise<void>;
    private getGitChange;
    private getChangesMap;
}
//# sourceMappingURL=git-content-source.d.ts.map