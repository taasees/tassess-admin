"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const _ = require('lodash');
const { utils } = require('@stackbit/cms-core');
module.exports = {
    saveContent
};
/**
 * Writes objects from `options.data` into files. Every object in `options.data`
 * must have a `__metadata` object with `srcObjectId` property. The `srcObjectId`
 * is a file path relative to `options.dirPath` specifying where that object
 * should be saved. The `__metadata` object is omitted before object is written.
 *
 * If `srcObjectId` ends with `.md` extension, all object's properties except the
 * `markdown_content` will be saved as frontmatter, while the `markdown_content`
 * property will be  saved as markdown content below the frontmatter.
 *
 * If file to be written already exists and has the exactly same content, the
 * write action will not be performed. This would prevent potential file-watchers
 * from recognizing a change in file where no actual content change occurs. If
 * none of the objects were written, this method returns `false`.
 *
 * @param {Object} options The options object
 * @param {string} dirPath The directory where items will be stored.
 * @param {Array} options.data Array of items, where every item will be written as a separate file to disk.
 * @return {Promise<boolean>} Returns `true` if at least one file was written to disk.
 */
function saveContent({ dirPath, data }) {
    return utils
        .mapPromise(data, (rawItem) => {
        const filePath = _.get(rawItem, '__metadata.srcObjectId');
        const absPath = path.join(dirPath, filePath);
        let item = utils.omitDeep(rawItem, '__metadata');
        const ext = path.extname(filePath);
        if (_.get(rawItem, '__metadata.isList') && _.has(item, 'items')) {
            item = _.get(item, 'items');
        }
        else if (['.md', '.markdown', '.mdx'].includes(ext)) {
            item = {
                frontmatter: _.omit(item, 'markdown_content'),
                markdown: _.get(item, 'markdown_content', '')
            };
        }
        else if (['.js', '.jsx'].includes(ext)) {
            item = prepareRawDataContent(rawItem);
        }
        // only output file if it changed to avoid triggering file watchers
        return utils.outputDataIfNeeded(absPath, item);
    })
        .then((results) => {
        // if at least one file was written, return true
        return _.some(results);
    });
}
function prepareRawDataContent(rawItem) {
    let data = _.get(rawItem, '__metadata.rawData');
    if (_.isNil(data)) {
        return Promise.resolve(false);
    }
    const orderedFields = [].concat(_.get(rawItem, '__metadata.orderedFields', []));
    orderedFields.reverse();
    orderedFields.forEach((fieldPath) => {
        // get value from object
        const encodedFieldPath = fieldPath.join('.');
        let value = _.get(rawItem, fieldPath);
        // encode value if needed
        const format = _.get(rawItem, ['__metadata', 'formats'].concat(encodedFieldPath));
        if (format === 'jsx') {
            value = utils.encodeJsx(value);
        }
        // get range from mapping metadata
        const fieldMappingPath = ['__metadata', 'mappings'].concat(encodedFieldPath);
        const range = _.get(rawItem, fieldMappingPath);
        if (!value || !range) {
            console.warn('empty field', { fieldPath, value, range });
            return;
        }
        // calculate delta from previous val and update ranges
        const oldValue = data.substring(...range);
        const lenDelta = value.length - oldValue.length;
        _.set(rawItem, fieldMappingPath, [range[0], range[1] + lenDelta]);
        data = utils.replaceInRange(data, range, value);
        // if range change update all fields that came prior
        if (lenDelta) {
            orderedFields.slice(0, orderedFields.indexOf(fieldPath)).forEach((prevField) => {
                const prevFieldMappingPath = ['__metadata', 'mappings'].concat(prevField.join('.'));
                const range = _.get(rawItem, prevFieldMappingPath);
                _.set(rawItem, prevFieldMappingPath, [range[0] + lenDelta, range[1] + lenDelta]);
            });
        }
    });
    _.set(rawItem, '__metadata.rawData', data);
    return data;
}
//# sourceMappingURL=content-writer.js.map