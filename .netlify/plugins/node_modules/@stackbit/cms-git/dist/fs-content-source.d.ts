import type { Asset, Assets, User, ContentChanges, ContentSourceInterface, Document, InitOptions, Schema, Model, Locale, UpdateOperation, UpdateOperationField, ValidationError, Version } from '@stackbit/types';
import { DocumentContext, AssetContext } from './content-converter';
export type FileSystemContentSourceOptions = {
    /**
     * The root path of the project. Used to resolve relative paths in the
     * `contentDirs` option.
     */
    rootPath: string;
    /**
     * Array of content directories. Each directory is searched recursively
     * for content files.
     */
    contentDirs: string[];
    /**
     * Array of model objects used at this content source's schema.
     */
    models: Model[];
    /**
     * Array of locale objects to enable field-level localization.
     * One of the objects must be defined as `default: true`.
     */
    locales?: Locale[];
    /**
     * Assets loading and behavior configuration.
     */
    assetsConfig?: Assets;
    /**
     * Are files saved with a unique stable id
     */
    useFileIds?: boolean;
    /**
     * The key used to store the file id in the file data
     */
    fileIdKey?: string;
    /**
     * Set the file id on the file data when the file is loaded
     * This is useful when we want to migrate from using the file path as the id to using a unique stable id
     * Runs only in local dev mode
     */
    setFileIdsOnStart?: boolean;
    /**
     * Run file id migration in dry run mode
     * This is useful when we want to see what files will be affected by the migration
     * Runs only in local dev mode
     */
    setFileIdsOnStartDryRun?: boolean;
    /** @deprecated */
    pagesDir?: string;
    /** @deprecated */
    dataDir?: string;
};
export declare class FileSystemContentSource implements ContentSourceInterface<unknown, unknown, DocumentContext, AssetContext> {
    private rootPath;
    private contentDirs;
    private models;
    private locales;
    private assetsConfig?;
    private fileIdKey?;
    private setFileIdsOnStart?;
    private setFileIdsOnStartDryRun?;
    private localDev;
    private logger;
    private userLogger;
    private cache;
    constructor(options: FileSystemContentSourceOptions);
    getVersion(): Promise<Version>;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    init(options: InitOptions<unknown, DocumentContext, AssetContext>): Promise<void>;
    migrateToFileIds(): Promise<void>;
    destroy(): Promise<void>;
    reset(): Promise<void>;
    onFilesChange?({ updatedFiles }: {
        updatedFiles: string[];
    }): Promise<{
        invalidateSchema?: boolean;
        contentChanges?: ContentChanges<DocumentContext, AssetContext>;
    }>;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    getSchema(): Promise<Schema>;
    getDocuments(): Promise<Document<DocumentContext>[]>;
    getAssets(): Promise<Asset<AssetContext>[]>;
    hasAccess(options: {
        userContext?: User;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument(options: {
        updateOperationFields: Record<string, UpdateOperationField>;
        model: Model;
        locale?: string | undefined;
        defaultLocaleDocumentId?: string | undefined;
        userContext?: User;
    }): Promise<{
        documentId: string;
    } & Document<DocumentContext>>;
    updateDocument(options: {
        document: Document<DocumentContext>;
        operations: UpdateOperation[];
        userContext?: User;
    }): Promise<any>;
    deleteDocument(options: {
        document: Document<DocumentContext>;
        userContext?: User;
    }): Promise<void>;
    uploadAsset(options: {
        url?: string | undefined;
        base64?: string | undefined;
        fileName: string;
        mimeType: string;
        locale?: string | undefined;
        userContext?: User;
    }): Promise<Asset<AssetContext>>;
    validateDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        locale?: string | undefined;
        userContext?: User;
    }): Promise<{
        errors: ValidationError[];
    }>;
    publishDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        userContext?: User;
    }): Promise<void>;
}
//# sourceMappingURL=fs-content-source.d.ts.map