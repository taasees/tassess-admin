"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemContentSource = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const stackbitUtils = __importStar(require("@stackbit/types"));
const content_converter_1 = require("./content-converter");
const utils_1 = require("./utils");
const sdk_1 = require("@stackbit/sdk");
const utils_2 = require("@stackbit/utils");
let didMigrationRun = false;
class FileSystemContentSource {
    constructor(options) {
        this.rootPath = options.rootPath;
        this.contentDirs = options.contentDirs;
        this.models = options.models;
        this.locales = options.locales ?? [];
        this.assetsConfig = options.assetsConfig;
        if (options.useFileIds) {
            this.fileIdKey = options.fileIdKey ?? 'id';
        }
        this.setFileIdsOnStart = options.setFileIdsOnStart;
        this.setFileIdsOnStartDryRun = options.setFileIdsOnStartDryRun;
    }
    async getVersion() {
        return stackbitUtils.getVersion({ packageJsonPath: path_1.default.join(__dirname, '../package.json') });
    }
    getContentSourceType() {
        return 'fs';
    }
    getProjectId() {
        // generate unique id based on content dirs
        return crypto_1.default.createHash('md5').update(this.contentDirs.join('.')).digest('hex').slice(0, 8);
    }
    getProjectEnvironment() {
        return '';
    }
    getProjectManageUrl() {
        return '';
    }
    async init(options) {
        this.logger = options.logger.createLogger({ label: 'cms-fs' });
        this.userLogger = options.userLogger.createLogger({ label: 'cms-fs' });
        this.cache = options.cache;
        this.localDev = options.localDev;
        if (!this.assetsConfig) {
            this.userLogger.warn('No `assetsConfig` option provided, asset handling will be turned off.');
        }
        else {
            if (this.assetsConfig.referenceType === 'static' && !this.assetsConfig.staticDir) {
                this.userLogger.error('assetsConfig.referenceType is set to "static", but no assetsConfig.staticDir was set. Please specify assetsConfig.staticDir.');
            }
            else if (this.assetsConfig.referenceType === 'relative' && !this.assetsConfig.assetsDir) {
                this.userLogger.error('assetsConfig.referenceType is set to "relative", but no assetsConfig.assetsDir was set. Please specify assetsConfig.assetsDir.');
            }
        }
    }
    async migrateToFileIds() {
        if (!this.fileIdKey) {
            this.userLogger.warn('setFileIdsOnStart is set to true but `useFileIds` is set to false. Skipping conversion...');
            return;
        }
        if (!this.localDev) {
            this.userLogger.warn('setFileIdsOnStart is set to true but this is not a local dev environment. Skipping conversion...');
            return;
        }
        this.userLogger.info('Running file id migration', { dryRun: this.setFileIdsOnStartDryRun });
        const filePathToId = {};
        for (const contentDir of this.contentDirs) {
            const contentDirPath = path_1.default.join(this.rootPath, contentDir);
            await (0, utils_1.readFilesFromDirectory)(contentDirPath, this.logger, async (filePath, fullFilePath, data) => {
                if (!data[this.fileIdKey]) {
                    const documentId = (0, content_converter_1.generateDocumentId)();
                    this.userLogger.info(`â†’ Updating file ${filePath} with new id ${documentId}`);
                    data[this.fileIdKey] = documentId;
                    filePathToId[filePath] = documentId;
                    if (!this.setFileIdsOnStartDryRun) {
                        await (0, utils_1.saveFileData)(fullFilePath, data);
                    }
                }
            });
        }
        const documents = await this.getDocuments();
        for (const document of documents) {
            const fullFilePath = path_1.default.join(this.rootPath, document.context.filePath);
            let data;
            await (0, utils_1.forEachFieldInDocument)(document, async (field, fieldPath) => {
                if (field.type === 'reference' && !field.localized && field.refType === 'document' && field.refId && filePathToId[field.refId]) {
                    const newRefId = filePathToId[field.refId];
                    this.userLogger.info(`Updating reference field ${fieldPath} to new id ${newRefId}`);
                    // load the file data if we haven't already
                    if (!this.setFileIdsOnStartDryRun && !data) {
                        try {
                            data = await (0, utils_1.getFileData)(fullFilePath);
                        }
                        catch (err) {
                            this.logger?.warn('Error loading file for conversion: ' + document.context.filePath, err);
                            return;
                        }
                    }
                    if (data) {
                        lodash_1.default.set(data, fieldPath, newRefId);
                    }
                }
            });
            // the existence of data signals that we have changes to save
            if (data) {
                this.userLogger.info(`Updating file ${document.context.filePath} with updated references`);
                await (0, utils_1.saveFileData)(fullFilePath, data);
            }
        }
        if (this.setFileIdsOnStartDryRun) {
            this.userLogger.info('File id migration dry run complete');
        }
        else {
            this.userLogger.info('File id migration complete');
        }
    }
    async destroy() { }
    async reset() { }
    async onFilesChange({ updatedFiles }) {
        const documents = [];
        const deletedDocumentIds = [];
        const contentFiles = updatedFiles.filter((updatedFile) => lodash_1.default.some(this.contentDirs, (contentDir) => updatedFile.startsWith(contentDir)) &&
            sdk_1.SUPPORTED_FILE_EXTENSIONS.includes(path_1.default.extname(updatedFile).substring(1).toLowerCase()));
        let existingDocumentsByFilePath;
        for (const filePath of contentFiles) {
            const fullFilePath = path_1.default.join(this.rootPath, filePath);
            if (!(await fs_extra_1.default.pathExists(fullFilePath))) {
                // calculate existing documents only if needed and only once
                if (!existingDocumentsByFilePath) {
                    const existingDocuments = this.cache.getDocuments().filter((document) => contentFiles.includes(document.context.filePath));
                    existingDocumentsByFilePath = lodash_1.default.keyBy(existingDocuments, (document) => document.context.filePath);
                }
                const existingDocument = existingDocumentsByFilePath[filePath];
                if (existingDocument) {
                    deletedDocumentIds.push(existingDocument.id);
                }
                continue;
            }
            let data;
            try {
                data = await (0, utils_1.getFileData)(fullFilePath);
            }
            catch (err) {
                this.logger?.warn('Error loading file: ' + fullFilePath, err);
                continue;
            }
            const document = await (0, content_converter_1.convertDocument)({
                filePath,
                fullFilePath,
                data,
                getModelByName: this.cache.getModelByName,
                assetsConfig: this.assetsConfig,
                fileIdKey: this.fileIdKey,
                logger: this.userLogger
            });
            if (!document) {
                this.logger?.warn('Error converting file: ' + filePath);
                continue;
            }
            // when file is moved, no need to report it as deleted
            if (deletedDocumentIds.includes(document.id)) {
                deletedDocumentIds.splice(deletedDocumentIds.indexOf(document.id), 1);
            }
            documents.push(document);
        }
        const assets = [];
        const deletedAssetIds = [];
        if (this.assetsConfig) {
            const assetsDir = (0, content_converter_1.getAssetDir)(this.assetsConfig);
            const assetFiles = updatedFiles.filter((updatedFile) => updatedFile.startsWith(assetsDir) && sdk_1.ASSET_FILE_EXTENSIONS.includes(path_1.default.extname(updatedFile).substring(1).toLowerCase()));
            for (const assetFilePath of assetFiles) {
                const absAssetFilePath = path_1.default.join(this.rootPath, assetFilePath);
                if (!(await fs_extra_1.default.pathExists(absAssetFilePath))) {
                    deletedAssetIds.push(assetFilePath);
                    continue;
                }
                const asset = await (0, content_converter_1.convertAsset)({
                    assetFilePath,
                    absProjectDir: this.rootPath,
                    assetsConfig: this.assetsConfig
                });
                assets.push(asset);
            }
        }
        return {
            invalidateSchema: false,
            contentChanges: {
                documents,
                assets,
                deletedDocumentIds,
                deletedAssetIds
            }
        };
    }
    startWatchingContentUpdates() { }
    stopWatchingContentUpdates() { }
    async getSchema() {
        this.userLogger.debug('getSchema');
        const modelGroups = {};
        for (const model of this.models) {
            for (const groupName of model.groups ?? []) {
                if (!modelGroups[groupName]) {
                    modelGroups[groupName] = {};
                }
                const key = model.type === 'object' ? 'objectModels' : 'documentModels';
                if (!modelGroups[groupName][key]) {
                    modelGroups[groupName][key] = [];
                }
                if (!modelGroups[groupName][key].includes(model.name)) {
                    modelGroups[groupName][key].push(model.name);
                }
            }
        }
        const models = this.models.map((model) => {
            let { groups, ...updatedModel } = model;
            // add markdown content field for pages
            if ((0, sdk_1.isPageModel)(updatedModel)) {
                const modelFields = updatedModel.fields ?? [];
                if (!updatedModel.hideContent && !modelFields.find((field) => field.name === 'markdown_content')) {
                    updatedModel.fields = modelFields.concat({
                        type: 'markdown',
                        name: 'markdown_content',
                        label: 'Content',
                        description: 'Page content'
                    });
                }
            }
            // Add "virtual" slug fields for all tokens in model.filePath.
            // For example, if model.filePath === 'posts/{category}/{slug}'
            // then, the tokens 'category' and 'slug' will be added as required
            // fields of type 'slug', if fields with same name do not already
            // exist. The added fields will be prefixed and regarded as "virtual"
            // fields. Virtual fields will not be saved in files but used for
            // computing the file names, and effectively the page URLs reflected
            // by these files.
            if (((0, sdk_1.isPageModel)(updatedModel) || (0, sdk_1.isDataModel)(updatedModel)) && updatedModel.filePath && typeof updatedModel.filePath === 'string') {
                const tokens = (0, utils_1.extractTokensFromString)(updatedModel.filePath);
                const existingFieldsByName = lodash_1.default.keyBy(updatedModel.fields ?? [], (field) => field.name);
                const slugVirtualFields = [];
                for (const token of tokens) {
                    if (existingFieldsByName[token]) {
                        // Make the field that matches the fieldPath token to be
                        // required if it isn't.
                        if (!existingFieldsByName[token]?.required) {
                            existingFieldsByName[token].required = true;
                        }
                        continue;
                    }
                    if (this.fileIdKey) {
                        // stableId === fileIdKey. When fileIdKey is used, the
                        // document.id is set to fileIdKey and is used as sitemap's
                        // stableId. In this case, users can safely change the
                        // virtual slug fields which change the file names. The
                        // Studio will be able to keep track of the renamed files
                        // due to constant sitemap's stableId.
                        slugVirtualFields.push({
                            type: 'slug',
                            name: (0, content_converter_1.createVirtualSlugFieldName)(token),
                            label: lodash_1.default.startCase(token),
                            required: true
                        });
                    }
                    else {
                        // stableId === fileName. When fileIdKey is not used, the
                        // document.id is set to the file name and is used as
                        // sitemap's stableId, which is not actually stable.
                        // In this case, user cannot safely change slug fields
                        // as it will rename the files, and the Studio will not
                        // be able to relate the between the old and new file
                        // names of the same page as the sitemap's stableId will
                        // change. Therefore, we set readOnly to be true.
                        slugVirtualFields.push({
                            type: 'slug',
                            name: (0, content_converter_1.createVirtualSlugFieldName)(token),
                            label: lodash_1.default.startCase(token),
                            required: true,
                            readOnly: true,
                            description: "You can't change the slug. Contact your developer to enable stableId-based files."
                        });
                    }
                }
                if (slugVirtualFields) {
                    updatedModel.fields = [...slugVirtualFields, ...(updatedModel.fields ?? [])];
                }
            }
            (0, sdk_1.assignLabelFieldIfNeeded)(updatedModel);
            updatedModel = (0, sdk_1.mapModelFieldsRecursively)(updatedModel, (field) => {
                return (0, sdk_1.mapListItemsPropsOrSelfSpecificProps)(field, (fieldSpecificProps) => {
                    if ((!(0, sdk_1.isModelField)(fieldSpecificProps) && !(0, sdk_1.isReferenceField)(fieldSpecificProps)) || !fieldSpecificProps.groups) {
                        return fieldSpecificProps;
                    }
                    const { ...cloned } = fieldSpecificProps;
                    const key = (0, sdk_1.isModelField)(fieldSpecificProps) ? 'objectModels' : 'documentModels';
                    for (const groupName of fieldSpecificProps.groups) {
                        const groupModels = modelGroups[groupName]?.[key] ?? [];
                        if (groupModels) {
                            cloned.models = lodash_1.default.uniq((fieldSpecificProps.models ?? []).concat(...groupModels).concat(...cloned.models));
                        }
                    }
                    delete cloned.groups;
                    return cloned;
                });
            });
            return updatedModel;
        });
        return {
            models,
            locales: this.locales,
            context: null
        };
    }
    async getDocuments() {
        // migration should be called at this point of the lifecycle
        if (this.setFileIdsOnStart && !didMigrationRun) {
            // make sure we run migration only once even if content source is reloaded
            didMigrationRun = true;
            await this.migrateToFileIds();
        }
        const documents = [];
        for (const contentDir of this.contentDirs) {
            const contentDirPath = path_1.default.join(this.rootPath, contentDir);
            await (0, utils_1.readFilesFromDirectory)(contentDirPath, this.logger, async (filePath, fullFilePath, data) => {
                const document = await (0, content_converter_1.convertDocument)({
                    filePath: path_1.default.join(contentDir, filePath),
                    fullFilePath,
                    data,
                    getModelByName: this.cache.getModelByName,
                    assetsConfig: this.assetsConfig,
                    fileIdKey: this.fileIdKey,
                    logger: this.userLogger
                });
                if (!document) {
                    this.logger?.warn('Error converting file to document: ' + filePath);
                    return;
                }
                documents.push(document);
            });
        }
        return documents;
    }
    async getAssets() {
        if (!this.assetsConfig) {
            return [];
        }
        const assetsDir = (0, content_converter_1.getAssetDir)(this.assetsConfig);
        const absAssetsDir = path_1.default.join(this.rootPath, assetsDir);
        const assetFilePaths = await (0, utils_2.readDirRecursivelyWithExtensions)(absAssetsDir, sdk_1.ASSET_FILE_EXTENSIONS);
        const assets = [];
        for (const assetFilePath of assetFilePaths) {
            assets.push(await (0, content_converter_1.convertAsset)({
                assetFilePath: path_1.default.join(assetsDir, assetFilePath),
                absProjectDir: this.rootPath,
                assetsConfig: this.assetsConfig
            }));
        }
        return assets;
    }
    async hasAccess(options) {
        return {
            hasConnection: true,
            hasPermissions: true
        };
    }
    async createDocument(options) {
        const { model, locale } = options;
        let data = {
            type: model.name,
            ...(this.fileIdKey ? { [this.fileIdKey]: (0, content_converter_1.generateDocumentId)() } : null)
        };
        const virtualSlugData = {};
        for (const fieldName in options.updateOperationFields) {
            const updateOperationField = options.updateOperationFields[fieldName];
            const modelField = lodash_1.default.find(model.fields, (field) => field.name === fieldName);
            const value = mapUpdateOperationToValue({
                updateOperationField,
                locale,
                getModelByName: this.cache.getModelByName,
                modelField,
                documentDirPath: null,
                assetsConfig: this.assetsConfig
            });
            if (modelField?.type === 'slug' && (0, content_converter_1.isVirtualSlug)(modelField.name)) {
                const token = (0, content_converter_1.getFieldNameFromVirtualSlug)(modelField.name);
                virtualSlugData[token] = value;
            }
            else {
                data[fieldName] = value;
            }
        }
        let filePath;
        if ((0, sdk_1.isPageModel)(model) || (0, sdk_1.isDataModel)(model)) {
            filePath =
                (await (0, content_converter_1.getFilePathFromSlugContext)({
                    model,
                    context: { ...data, ...virtualSlugData },
                    contentDir: this.contentDirs[0] ? `${this.contentDirs[0]}/` : '',
                    locale,
                    generateFallback: true
                })) || '';
            if (!filePath) {
                throw new Error(`Error creating document: failed to generate file path for model '${model.name}'.`);
            }
        }
        else {
            throw new Error(`Error creating document: cannot create document for model '${model.name}' which is not of type 'page' or 'data'.`);
        }
        const fullFilePath = path_1.default.join(this.rootPath, filePath);
        if (await fs_extra_1.default.pathExists(fullFilePath)) {
            throw new Error(`Page already exists at: '${filePath}'.`);
        }
        data = (0, content_converter_1.replaceAssetIdsWithAssetValues)(data, path_1.default.dirname(filePath), this.assetsConfig);
        await (0, utils_1.saveFileData)(fullFilePath, data);
        const document = await (0, content_converter_1.convertDocument)({
            filePath,
            fullFilePath,
            data,
            getModelByName: this.cache.getModelByName,
            assetsConfig: this.assetsConfig,
            fileIdKey: this.fileIdKey,
            logger: this.userLogger
        });
        if (!document) {
            throw new Error('Error converting document');
        }
        return { documentId: filePath, ...document };
    }
    async updateDocument(options) {
        const { document } = options;
        let locale;
        let filePath = document.context.filePath;
        let fullFilePath = path_1.default.join(this.rootPath, filePath);
        const data = await (0, utils_1.getFileData)(fullFilePath);
        const virtualSlugData = {};
        for (const updateOperation of options.operations) {
            applyUpdateOp({
                updateOperation,
                data,
                virtualSlugData: virtualSlugData,
                getModelByName: this.cache.getModelByName,
                documentDirPath: path_1.default.dirname(filePath),
                assetsConfig: this.assetsConfig
            });
            if (updateOperation.locale) {
                locale = updateOperation.locale;
            }
        }
        const model = this.cache.getModelByName(document.modelName);
        if (!model) {
            throw new Error(`Error updating document: model not found: ${document.modelName}.`);
        }
        if (!(0, sdk_1.isPageModel)(model) && !(0, sdk_1.isDataModel)(model)) {
            throw new Error(`Error updating document: cannot update document for model "${model.name}" which is not of type "page" or "data".`);
        }
        const newFilePath = await (0, content_converter_1.getFilePathFromSlugContext)({
            model,
            contentDir: this.contentDirs[0] ? `${this.contentDirs[0]}/` : '',
            context: { ...data, ...virtualSlugData },
            locale
        });
        // check if slug tokens have changed and if so, check if they result in a new file path
        if (newFilePath && newFilePath !== document.context.filePath) {
            if (await fs_extra_1.default.pathExists(path_1.default.join(this.rootPath, newFilePath))) {
                throw new Error(`Page already exists at: '${newFilePath}'.`);
            }
            await fs_extra_1.default.unlink(fullFilePath);
            const containingDir = path_1.default.dirname(fullFilePath);
            if ((await fs_extra_1.default.readdir(containingDir)).length === 0) {
                // delete containing dir if it's empty
                await fs_extra_1.default.remove(containingDir);
            }
            filePath = newFilePath;
        }
        // recalculate path in case it changed
        fullFilePath = path_1.default.join(this.rootPath, filePath);
        await (0, utils_1.saveFileData)(fullFilePath, data);
        return ((await (0, content_converter_1.convertDocument)({
            filePath,
            fullFilePath,
            data,
            getModelByName: this.cache.getModelByName,
            assetsConfig: this.assetsConfig,
            fileIdKey: this.fileIdKey,
            logger: this.userLogger
        })) || document);
    }
    async deleteDocument(options) {
        const { document } = options;
        const filePath = path_1.default.join(this.rootPath, document.context.filePath);
        await fs_extra_1.default.unlink(filePath);
    }
    async uploadAsset(options) {
        if (!this.assetsConfig) {
            throw new Error('Error uploading asset: no asset options defined.');
        }
        const { url, base64, fileName } = options;
        const assetDir = (0, content_converter_1.getAssetDir)(this.assetsConfig);
        const absAssetsDir = path_1.default.join(this.rootPath, assetDir);
        const assetFilePath = path_1.default.join(this.assetsConfig.uploadDir ?? '', fileName);
        const absAssetFilePath = path_1.default.join(absAssetsDir, assetFilePath);
        if (base64) {
            await (0, utils_1.saveBase64Data)(absAssetFilePath, base64);
        }
        else if (url) {
            await (0, utils_1.saveFromUrl)(absAssetFilePath, url);
        }
        else {
            throw new Error('Error uploading asset: no upload data found for asset.');
        }
        return await (0, content_converter_1.convertAsset)({
            assetFilePath: path_1.default.join(assetDir, assetFilePath),
            absProjectDir: this.rootPath,
            assetsConfig: this.assetsConfig
        });
    }
    async validateDocuments(options) {
        return {
            errors: []
        };
    }
    async publishDocuments(options) { }
}
exports.FileSystemContentSource = FileSystemContentSource;
function mapUpdateOperationToValue({ updateOperationField, locale, getModelByName, modelField, documentDirPath, assetsConfig }) {
    switch (updateOperationField.type) {
        case 'object': {
            const result = {};
            lodash_1.default.forEach(updateOperationField.fields, (childUpdateOperationField, fieldName) => {
                const childModelField = lodash_1.default.find(modelField.fields, (field) => field.name === fieldName);
                const value = mapUpdateOperationToValue({
                    updateOperationField: childUpdateOperationField,
                    locale,
                    getModelByName,
                    modelField: childModelField,
                    documentDirPath,
                    assetsConfig
                });
                if (childModelField?.localized && locale) {
                    lodash_1.default.set(result, [fieldName, locale], value);
                }
                else {
                    lodash_1.default.set(result, fieldName, value);
                }
            });
            return result;
        }
        case 'model': {
            const modelName = updateOperationField.modelName;
            const childModel = getModelByName(modelName);
            const result = {
                type: modelName
            };
            lodash_1.default.forEach(updateOperationField.fields, (updateOperationField, fieldName) => {
                const childModelField = lodash_1.default.find(childModel?.fields, (field) => field.name === fieldName);
                const value = mapUpdateOperationToValue({
                    updateOperationField,
                    locale,
                    getModelByName,
                    modelField: childModelField,
                    documentDirPath,
                    assetsConfig
                });
                if (childModelField?.localized && locale) {
                    lodash_1.default.set(result, [fieldName, locale], value);
                }
                else {
                    lodash_1.default.set(result, fieldName, value);
                }
            });
            return result;
        }
        case 'list': {
            const listItemsModel = modelField?.type === 'list' && modelField.items;
            return updateOperationField.items.map((item) => {
                let listItemModelField;
                if (lodash_1.default.isArray(listItemsModel)) {
                    listItemModelField = listItemsModel.find((listItemsModel) => listItemsModel.type === item.type);
                }
                else if (listItemsModel) {
                    listItemModelField = listItemsModel;
                }
                return mapUpdateOperationToValue({
                    updateOperationField: item,
                    locale,
                    getModelByName,
                    modelField: listItemModelField,
                    documentDirPath,
                    assetsConfig
                });
            });
        }
        case 'reference': {
            if (assetsConfig && updateOperationField.refType === 'asset' && (0, content_converter_1.isPrefixedAssetId)(updateOperationField.refId)) {
                return (0, content_converter_1.assetIdToAssetValue)(updateOperationField.refId, documentDirPath, assetsConfig);
            }
            return updateOperationField.refId;
        }
        case 'markdown': {
            return (0, utils_1.processMarkdownImagePaths)(updateOperationField.value, (path) => {
                if (assetsConfig && (0, content_converter_1.isPrefixedAssetId)(path)) {
                    return (0, content_converter_1.assetIdToAssetValue)(path, documentDirPath, assetsConfig);
                }
                return path;
            });
        }
        default:
            return updateOperationField.value;
    }
}
function applyUpdateOp({ updateOperation, data, virtualSlugData, getModelByName, documentDirPath, assetsConfig }) {
    const { modelField, locale } = updateOperation;
    const fieldPath = 'localized' in modelField && modelField.localized && locale ? updateOperation.fieldPath.concat(locale) : updateOperation.fieldPath;
    switch (updateOperation.opType) {
        case 'set': {
            const { field } = updateOperation;
            const value = mapUpdateOperationToValue({
                updateOperationField: field,
                getModelByName,
                modelField,
                documentDirPath,
                assetsConfig
            });
            if ('name' in modelField && (0, content_converter_1.isVirtualSlug)(modelField.name)) {
                const token = (0, content_converter_1.getFieldNameFromVirtualSlug)(modelField.name);
                lodash_1.default.set(virtualSlugData, token, value);
            }
            else {
                lodash_1.default.set(data, fieldPath, value);
            }
            break;
        }
        case 'unset': {
            lodash_1.default.unset(data, fieldPath);
            break;
        }
        case 'insert': {
            const { item, index } = updateOperation;
            const value = mapUpdateOperationToValue({
                updateOperationField: item,
                getModelByName,
                modelField,
                documentDirPath,
                assetsConfig
            });
            const arr = [...lodash_1.default.get(data, fieldPath, [])];
            arr.splice(index ?? 0, 0, value);
            lodash_1.default.set(data, fieldPath, arr);
            break;
        }
        case 'remove': {
            const { index } = updateOperation;
            const arr = [...lodash_1.default.get(data, fieldPath, [])];
            arr.splice(index, 1);
            lodash_1.default.set(data, fieldPath, arr);
            break;
        }
        case 'reorder': {
            const { order } = updateOperation;
            const arr = [...lodash_1.default.get(data, fieldPath, [])];
            const newArr = order.map((newIndex) => arr[newIndex]);
            lodash_1.default.set(data, fieldPath, newArr);
            break;
        }
    }
    return data;
}
//# sourceMappingURL=fs-content-source.js.map