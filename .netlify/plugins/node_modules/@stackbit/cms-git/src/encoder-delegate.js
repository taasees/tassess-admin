const path = require('path');
const _ = require('lodash');

class GitEncoderDelegate {
    constructor(options) {
        this.schema = options.schema;
        this.models = options.schema.models;
        this.modelsByName = _.keyBy(this.models, 'name');
        this.pageLayoutKey = _.get(options, 'schema.pageLayoutKey', 'layout');
        this.castReferenceToModel = /^[^\d]*0\.[12]\./.test(_.get(this.schema, 'stackbitVersion', '0.2.0'));
        this.projectId = _.get(options, 'projectId', null);
        this.projectUrl = _.get(options, 'projectUrl', null);
        this.branch = _.get(options, 'branch', null);
        this.noEncodeFields = _.get(options, 'noEncodeFields', []);
        this.omitFields = _.concat(_.get(options, 'omitFields', []), '__metadata');
        this.encodedFieldTypes = _.get(options, 'encodedFieldTypes', null);
        this.assetsReferenceType = _.get(this.schema, 'assets.referenceType', 'static');
        this.assetsDir = _.get(this.schema, 'assets.assetsDir');
        this.staticDir = _.get(this.schema, 'assets.staticDir', this.assetsDir); // assetsDir as staticDir for backward compatibility
        this.staticAssetsPublicPath = _.get(options, 'staticAssetsPublicPath');
    }

    getModelsByName() {
        return this.modelsByName;
    }

    getEncodedFieldTypes() {
        return this.encodedFieldTypes;
    }

    getNoEncodeFields() {
        return this.noEncodeFields;
    }

    getItemId(item) {
        return _.get(item, '__metadata.srcObjectId');
    }

    getModelForRootItem(rootItem) {
        const modelName = _.get(rootItem, '__metadata.srcModelName');
        const modelsByName = this.getModelsByName();
        return _.get(modelsByName, modelName, null);
    }

    isLinkItem() {
        // the 'reference' type in stackbit.yaml v0.2 is used as a nested objects.
        if (this.castReferenceToModel) {
            return false;
        }
        // from stackbit.yaml v0.3 we support references
        return true;
    }

    getReferenceId(item) {
        // the 'reference' type in stackbit.yaml v0.2 is used as a nested objects.
        if (this.castReferenceToModel) {
            return null;
        }
        // in git-cms, the reference ID is the file path to the referenced file
        // and it is stored in the field as a string
        return item;
    }

    getModelForItemOfReferenceType(item) {
        // for backward compatibility, treat existing "reference" types as "models" type
        const modelName = _.get(item, '__metadata.srcModelName', _.get(item, 'type', null));
        const modelsByName = this.getModelsByName();
        return _.get(modelsByName, modelName, null);
    }

    getModelForItemOfModelsType(item) {
        const modelName = _.get(item, '__metadata.srcModelName', _.get(item, 'type', null));
        const modelsByName = this.getModelsByName();
        return _.get(modelsByName, modelName, null);
    }

    getItemMetadata(item, model, isRoot) {
        const modelName = _.get(model, 'name', null);
        const srcObjectId = _.get(item, '__metadata.srcObjectId', null);
        const undeletable = _.get(item, '__metadata.undeletable');
        const objectUrl = srcObjectId && this.projectUrl ? _.trimEnd(this.projectUrl, '/') + `/${srcObjectId}` : null;

        return _.omitBy(
            _.assign(
                {
                    type: 'object',
                    srcObjectId: srcObjectId,
                    srcObjectUrl: objectUrl,
                    srcObjectLabel: this.getItemLabelFieldValue(item, model),
                    // for items of type "object", models don't have label or name
                    srcModelName: modelName,
                    srcModelLabel: _.get(model, 'label', modelName ? _.startCase(modelName) : null),
                    undeletable
                },
                isRoot
                    ? {
                          srcType: 'git',
                          srcProjectId: this.projectId,
                          srcProjectUrl: this.projectUrl,
                          srcEnvironment: this.branch
                          // TODO: once we fix git-content-loader to load this data, propagate it here to fieldData from item.__metadata.
                          // updatedBy: null,
                          // updatedAt: null,
                          // createdAt: null,
                          // createdBy: null
                      }
                    : null
            ),
            _.isNil
        );
    }

    getItemLabelFieldValue(item, model) {
        const labelField = _.get(model, 'labelField');
        let label = null;
        if (labelField) {
            label = _.get(item, labelField, null);
        }
        if (!label) {
            label = _.get(model, 'label', null);
        }
        if (!label && model.name) {
            label = _.startCase(model.name);
        }
        return label;
    }

    getItemFields(item, model) {
        // get model fields
        const modelFields = _.transform(
            model.fields,
            (accum, fieldModel) => {
                accum[fieldModel.name] = null;
            },
            {}
        );

        // merge model fields with item fields
        const mergedFields = _.assign(modelFields, item);

        const omitFields = this.omitFields.slice();
        if (model.type === 'page') {
            omitFields.push(this.pageLayoutKey);
        }
        // The 'type' field for referenced objects might be omitted from the
        // model fields because it is added automatically when provisioning CMS.
        // Therefore omit it and add it manually to the returned value.
        // Update: The SDK adds the type field to objects when needed
        const fieldModels = _.get(model, 'fields');
        if (_.has(item, 'type') && !_.some(fieldModels, { name: 'type' })) {
            omitFields.push('type');
        }

        const fields = _.omit(mergedFields, omitFields);
        return _.map(fields, (value, key) => {
            return {
                name: key,
                value: value,
                encodedDataPath: key,
                unset: !_.has(item, key)
            };
        });
    }

    encodeField(fieldValue, fieldModel, fieldDataPath) {
        if (!fieldValue) {
            return { fieldData: { isUnset: true } };
        }
        if (_.get(fieldModel, 'type') === 'image') {
            let srcObjectId = null;
            let title = '';

            if (fieldModel.source === 'cloudinary' && typeof fieldValue === 'object') {
                // cloudinary stored as object - as is received from cloudinary api
                title = fieldValue.public_id;
                fieldValue = fieldValue.derived?.[0]?.secure_url ?? fieldValue.secure_url;
                srcObjectId = fieldValue;
            } else {
                title = fieldValue ? path.basename(fieldValue) : '';

                if (this.assetsReferenceType === 'relative' && this.assetsDir) {
                    const rootObjectId = _.head(fieldDataPath);
                    const objectDir = path.dirname(rootObjectId);
                    srcObjectId = path.join(objectDir, fieldValue);
                    fieldValue = path.join('/', this.staticAssetsPublicPath, path.relative(this.assetsDir, srcObjectId));
                } else if (this.assetsReferenceType === 'static' && this.staticDir) {
                    srcObjectId = path.join(this.staticDir, fieldValue);
                }
            }

            return {
                encodedData: fieldValue,
                encodedFieldPath: '.',
                relativeFieldDataPath: ['fields', 'url'],
                fieldData: {
                    srcObjectId: srcObjectId,
                    fields: {
                        title: {
                            type: 'string',
                            value: title
                        },
                        url: {
                            type: 'string',
                            value: fieldValue
                        }
                    }
                }
            };
        }
        return null;
    }
}

module.exports = GitEncoderDelegate;
