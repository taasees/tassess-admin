const path = require('path');
const _ = require('lodash');
const { utils } = require('@stackbit/cms-core');

module.exports = {
    saveContent
};

/**
 * Writes objects from `options.data` into files. Every object in `options.data`
 * must have a `__metadata` object with `srcObjectId` property. The `srcObjectId`
 * is a file path relative to `options.dirPath` specifying where that object
 * should be saved. The `__metadata` object is omitted before object is written.
 *
 * If `srcObjectId` ends with `.md` extension, all object's properties except the
 * `markdown_content` will be saved as frontmatter, while the `markdown_content`
 * property will be  saved as markdown content below the frontmatter.
 *
 * If file to be written already exists and has the exactly same content, the
 * write action will not be performed. This would prevent potential file-watchers
 * from recognizing a change in file where no actual content change occurs. If
 * none of the objects were written, this method returns `false`.
 *
 * @param {Object} options The options object
 * @param {string} dirPath The directory where items will be stored.
 * @param {Array} options.data Array of items, where every item will be written as a separate file to disk.
 * @return {Promise<boolean>} Returns `true` if at least one file was written to disk.
 */
function saveContent({ dirPath, data }) {
    return utils
        .mapPromise(data, (rawItem) => {
            const filePath = _.get(rawItem, '__metadata.srcObjectId');
            const absPath = path.join(dirPath, filePath);
            let item = utils.omitDeep(rawItem, '__metadata');
            const ext = path.extname(filePath);
            if (_.get(rawItem, '__metadata.isList') && _.has(item, 'items')) {
                item = _.get(item, 'items');
            } else if (['.md', '.markdown', '.mdx'].includes(ext)) {
                item = {
                    frontmatter: _.omit(item, 'markdown_content'),
                    markdown: _.get(item, 'markdown_content', '')
                };
            } else if (['.js', '.jsx'].includes(ext)) {
                item = prepareRawDataContent(rawItem);
            }

            // only output file if it changed to avoid triggering file watchers
            return utils.outputDataIfNeeded(absPath, item);
        })
        .then((results) => {
            // if at least one file was written, return true
            return _.some(results);
        });
}

function prepareRawDataContent(rawItem) {
    let data = _.get(rawItem, '__metadata.rawData');
    if (_.isNil(data)) {
        return Promise.resolve(false);
    }
    const orderedFields = [].concat(_.get(rawItem, '__metadata.orderedFields', []));
    orderedFields.reverse();

    orderedFields.forEach((fieldPath) => {
        // get value from object
        const encodedFieldPath = fieldPath.join('.');
        let value = _.get(rawItem, fieldPath);

        // encode value if needed
        const format = _.get(rawItem, ['__metadata', 'formats'].concat(encodedFieldPath));
        if (format === 'jsx') {
            value = utils.encodeJsx(value);
        }

        // get range from mapping metadata
        const fieldMappingPath = ['__metadata', 'mappings'].concat(encodedFieldPath);
        const range = _.get(rawItem, fieldMappingPath);

        if (!value || !range) {
            console.warn('empty field', { fieldPath, value, range });
            return;
        }

        // calculate delta from previous val and update ranges
        const oldValue = data.substring(...range);
        const lenDelta = value.length - oldValue.length;
        _.set(rawItem, fieldMappingPath, [range[0], range[1] + lenDelta]);
        data = utils.replaceInRange(data, range, value);

        // if range change update all fields that came prior
        if (lenDelta) {
            orderedFields.slice(0, orderedFields.indexOf(fieldPath)).forEach((prevField) => {
                const prevFieldMappingPath = ['__metadata', 'mappings'].concat(prevField.join('.'));
                const range = _.get(rawItem, prevFieldMappingPath);
                _.set(rawItem, prevFieldMappingPath, [range[0] + lenDelta, range[1] + lenDelta]);
            });
        }
    });
    _.set(rawItem, '__metadata.rawData', data);
    return data;
}
