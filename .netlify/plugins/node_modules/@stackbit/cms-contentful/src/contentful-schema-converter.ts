import _ from 'lodash';
import { omitByNil } from '@stackbit/utils';
import { Field, FieldCrossReferenceModel, Model } from '@stackbit/types';
import { FieldType } from 'contentful-management';
import { ContentFields, ContentTypeProps, Control, EditorInterfaceProps } from 'contentful-management';

import {
    CONTENTFUL_NODE_TYPES_MAP,
    CONTENTFUL_MARKS_TYPES_MAP,
    CONTENTFUL_CLOUDINARY_APP,
    CONTENTFUL_BYNDER_APP,
    CONTENTFUL_APRIMO_APP
} from './contentful-consts';

type ExtendedFieldType = FieldType | ResourceLink | ResourceLinkArray;

interface ResourceLink {
    type: 'ResourceLink';
    allowedResources: AllowedResource[];
}

interface ResourceLinkArray {
    type: 'Array';
    items: {
        type: 'ResourceLink';
    };
    allowedResources: AllowedResource[];
}

interface AllowedResource {
    type: 'Contentful:Entry';
    source: string; // "crn:contentful:::content:spaces/{space_id}"
    contentTypes: string[]; // ["button", "badge"]
}

export interface ConvertSchemaOptions {
    contentTypes: ContentTypeProps[];
    editorInterfaces: EditorInterfaceProps[];
    defaultLocaleCode: string;
    cloudinaryImagesAsList: boolean;
    bynderImagesAsList: boolean;
}

export function convertSchema({ contentTypes, editorInterfaces, defaultLocaleCode, cloudinaryImagesAsList, bynderImagesAsList }: ConvertSchemaOptions): {
    models: Model[];
} {
    const editorInterfaceByContentTypeId = _.chain(editorInterfaces)
        .filter({
            sys: {
                type: 'EditorInterface',
                contentType: {
                    sys: {
                        type: 'Link',
                        linkType: 'ContentType'
                    }
                }
            }
        })
        .keyBy('sys.contentType.sys.id')
        .value();

    const models = _.map(contentTypes, (contentType) =>
        mapModel({
            contentType,
            editorInterfaceByContentTypeId,
            defaultLocaleCode,
            cloudinaryImagesAsList,
            bynderImagesAsList
        })
    );
    return {
        models
    };
}

interface MapModelOptions {
    contentType: ContentTypeProps;
    editorInterfaceByContentTypeId: Record<string, EditorInterfaceProps>;
    defaultLocaleCode: string;
    cloudinaryImagesAsList: boolean;
    bynderImagesAsList: boolean;
}

function mapModel(options: MapModelOptions): Model {
    const contentType = options.contentType;
    const contentTypeId = contentType.sys.id;
    const mappedFields = mapFields(options);

    return Object.assign(
        {
            type: 'data' as const,
            name: contentTypeId
        },
        omitByNil({
            label: contentType.name ?? _.startCase(contentTypeId),
            description: contentType.description ?? null,
            labelField: resolveLabelFieldForModel(contentType, 'displayField', mappedFields),
            fields: mappedFields
        })
    );
}

interface MapFieldsOptions {
    contentType: ContentTypeProps;
    editorInterfaceByContentTypeId: Record<string, EditorInterfaceProps>;
    defaultLocaleCode: string;
    cloudinaryImagesAsList: boolean;
    bynderImagesAsList: boolean;
}

function mapFields({ contentType, editorInterfaceByContentTypeId, defaultLocaleCode, cloudinaryImagesAsList, bynderImagesAsList }: MapFieldsOptions) {
    const contentTypeId = contentType.sys.id;
    const fields = contentType.fields;
    const editorInterfaceControls = editorInterfaceByContentTypeId[contentTypeId]?.controls;
    const editorInterfaceControlsByFieldId = _.keyBy(editorInterfaceControls, 'fieldId');

    return _.map(fields, (field) =>
        mapField({
            field,
            editorInterfaceControlsByFieldId,
            defaultLocaleCode,
            cloudinaryImagesAsList,
            bynderImagesAsList
        })
    );
}

interface MapFieldOptions {
    field: ContentFields;
    editorInterfaceControlsByFieldId: Record<string, Control>;
    defaultLocaleCode: string;
    cloudinaryImagesAsList: boolean;
    bynderImagesAsList: boolean;
}

function mapField({ field, editorInterfaceControlsByFieldId, defaultLocaleCode, cloudinaryImagesAsList, bynderImagesAsList }: MapFieldOptions): Field {
    const fieldId = field.id;
    const editorInterfaceControl = editorInterfaceControlsByFieldId[fieldId];
    const isRequired = field.required;
    const isReadonly = _.get(editorInterfaceControl, 'settings.readOnly');
    const isHidden = field.disabled ?? isReadonly;
    const localized = field.localized;
    const defaultValue = getDefaultValue(field, defaultLocaleCode, editorInterfaceControl);
    const defaultAsConst = isRequired && isReadonly && !_.isUndefined(defaultValue);
    const extra = convertField({ field, editorInterfaceControl, cloudinaryImagesAsList, bynderImagesAsList });

    return _.assign(
        {
            type: null,
            name: fieldId
        },
        omitByNil({
            label: field.name ?? _.startCase(fieldId),
            description: _.get(editorInterfaceControl, 'settings.helpText'),
            required: isRequired,
            default: defaultAsConst ? undefined : defaultValue,
            const: defaultAsConst ? defaultValue : undefined,
            readOnly: isReadonly,
            hidden: isHidden,
            localized: localized
        }),
        extra
    );
}

function getDefaultValue(field: ContentFields, defaultLocaleCode: string, editorInterfaceControl?: Control) {
    // Contentful defaultValue is an object with locale keys and default values per locale
    const defaultValue = field.defaultValue;
    if (typeof defaultValue !== 'undefined') {
        return _.isPlainObject(defaultValue) && defaultLocaleCode in defaultValue ? defaultValue[defaultLocaleCode] : undefined;
    }
    const widgetId = editorInterfaceControl?.widgetId;
    if (widgetId === 'default-boolean-value') {
        return _.get(editorInterfaceControl, 'settings.defaultValue');
    } else if (widgetId === 'default-field-value') {
        return _.get(editorInterfaceControl, 'settings.defaultValue');
    } else {
        return undefined;
    }
}

interface ConvertFieldOptions {
    field: ContentFields;
    editorInterfaceControl?: Control;
    cloudinaryImagesAsList: boolean;
    bynderImagesAsList: boolean;
}

function convertField({ field, editorInterfaceControl, cloudinaryImagesAsList, bynderImagesAsList }: ConvertFieldOptions) {
    const typedField = field as ContentFields & ExtendedFieldType;
    const type = typedField.type;
    // return fieldConverterMap[typedField.type](typedField, editorInterfaceControl, cloudinaryImagesAsList);
    switch (typedField.type) {
        case 'Symbol':
            return fieldConverterMap.Symbol(typedField, editorInterfaceControl);
        case 'Text':
            return fieldConverterMap.Text(typedField, editorInterfaceControl);
        case 'Integer':
            return fieldConverterMap.Integer(typedField, editorInterfaceControl);
        case 'Number':
            return fieldConverterMap.Number(typedField, editorInterfaceControl);
        case 'Date':
            return fieldConverterMap.Date(typedField, editorInterfaceControl);
        case 'Location':
            return fieldConverterMap.Location(typedField, editorInterfaceControl);
        case 'Boolean':
            return fieldConverterMap.Boolean(typedField, editorInterfaceControl);
        case 'Link':
            return fieldConverterMap.Link(typedField, editorInterfaceControl);
        case 'ResourceLink':
            return fieldConverterMap.ResourceLink(typedField, editorInterfaceControl);
        case 'Array':
            return fieldConverterMap.Array(typedField, editorInterfaceControl);
        case 'Object':
            return fieldConverterMap.Object(typedField, editorInterfaceControl, cloudinaryImagesAsList, bynderImagesAsList);
        case 'RichText':
            return fieldConverterMap.RichText(typedField, editorInterfaceControl);
        default:
            throw new Error(`field type '${type}' not supported, fieldId: ${field.id}`);
    }
}

type FieldConverterMap = {
    [P in ExtendedFieldType as P['type']]: (
        field: ContentFields & P,
        editorInterfaceControl?: Control,
        cloudinaryImagesAsList?: boolean,
        bynderImagesAsList?: boolean
    ) => Omit<Field, 'name'>;
};

const fieldConverterMap: FieldConverterMap = {
    Symbol: function (field, editorInterfaceControl) {
        const options = getOptions(field);
        if (options) {
            return { type: 'enum', ...options };
        } else {
            const widgetId = _.get(editorInterfaceControl, 'widgetId');
            if (widgetId === 'slugEditor') {
                return { type: 'slug' };
            } else if (widgetId === 'urlEditor') {
                return { type: 'url' };
            } else {
                return { type: 'string' };
            }
        }
    },
    Text: function (field, editorInterfaceControl) {
        const widgetId = _.get(editorInterfaceControl, 'widgetId');
        if (widgetId === 'singleLine') {
            return { type: 'string' };
        } else if (widgetId === 'multipleLine') {
            // can also be {type: 'html'} but we have no way of knowing that
            return { type: 'text' };
        } else if (widgetId === 'markdown') {
            return { type: 'markdown' };
        } else if (widgetId === 'dropdown' || widgetId === 'radio') {
            return {
                type: 'enum',
                ...getOptions(field)
            };
        } else {
            return { type: 'text' };
        }
    },
    Integer: function (field, editorInterfaceControl) {
        const widgetId = _.get(editorInterfaceControl, 'widgetId');
        if (widgetId === 'dropdown' || widgetId === 'radio') {
            return {
                type: 'enum',
                ...getOptions(field)
            };
        } else {
            return {
                type: 'number',
                subtype: 'int',
                ...getMinMax(field)
            };
        }
    },
    Number: function (field, editorInterfaceControl) {
        const widgetId = _.get(editorInterfaceControl, 'widgetId');
        if (widgetId === 'dropdown' || widgetId === 'radio') {
            return {
                type: 'enum',
                ...getOptions(field)
            };
        } else {
            return {
                type: 'number',
                subtype: 'float',
                ...getMinMax(field)
            };
        }
    },
    Date: function (field, editorInterfaceControl) {
        const format = _.get(editorInterfaceControl, 'settings.format');
        const type = format === 'dateonly' ? 'date' : 'datetime';
        return { type: type };
    },
    Location: function () {
        return { type: 'json' };
    },
    Boolean: function () {
        return { type: 'boolean' };
    },
    Link: function (field) {
        const linkType = field.linkType;
        if (linkType === 'Asset') {
            return { type: 'image' };
        } else if (linkType === 'Entry') {
            const validations = field.validations ?? [];
            const linkContentTypeValidation = _.find(validations, 'linkContentType');
            const linkContentTypes = linkContentTypeValidation?.linkContentType ?? [];
            return {
                type: 'reference',
                models: linkContentTypes
            };
        } else {
            throw new Error(`not supported linkType: ${linkType}`);
        }
    },
    ResourceLink: function (field) {
        return {
            type: 'cross-reference',
            models: field.allowedResources.reduce((models: FieldCrossReferenceModel[], allowedResource) => {
                const match = allowedResource.source.match(/crn:contentful:::content:spaces\/(.+)$/);
                if (!match) {
                    return models;
                }
                const spaceId = match[1]!;
                return models.concat(
                    allowedResource.contentTypes.reduce((models: FieldCrossReferenceModel[], contentType) => {
                        return models.concat({
                            modelName: contentType,
                            srcType: 'contentful',
                            srcProjectId: spaceId
                        });
                    }, [])
                );
            }, [])
        };
    },
    Array: function (field, editorInterfaceControl) {
        const widgetId = _.get(editorInterfaceControl, 'widgetId');
        const items = getListItems(field);
        if (widgetId === 'checkbox' && items.type === 'enum') {
            return {
                type: 'list',
                controlType: 'checkbox',
                items
            };
        }
        return {
            type: 'list',
            items
        };
    },
    Object: function (field, editorInterfaceControl, cloudinaryImagesAsList, bynderImagesAsList) {
        const widgetId = _.get(editorInterfaceControl, 'widgetId');
        if (widgetId === CONTENTFUL_CLOUDINARY_APP) {
            if (cloudinaryImagesAsList) {
                return {
                    type: 'list',
                    items: {
                        type: 'image',
                        source: 'cloudinary'
                    }
                };
            }
            return {
                type: 'image',
                source: 'cloudinary'
            };
        } else if (widgetId === CONTENTFUL_BYNDER_APP) {
            if (bynderImagesAsList) {
                return {
                    type: 'list',
                    items: {
                        type: 'image',
                        source: 'bynder'
                    }
                };
            }
            return {
                type: 'image',
                source: 'bynder'
            };
        } else if (widgetId === CONTENTFUL_APRIMO_APP) {
            return {
                type: 'list',
                items: {
                    type: 'image',
                    source: 'aprimo'
                }
            };
        }
        return { type: 'json' };
    },
    RichText: function (field) {
        const validations = _.get(field, 'validations');
        const nodeTypesValidation = _.find(validations, 'enabledNodeTypes');
        const marksValidation = _.find(validations, 'enabledMarks');
        return {
            type: 'richText',
            options: {
                nodes: (nodeTypesValidation?.enabledNodeTypes ?? []).map((node) => _.get(CONTENTFUL_NODE_TYPES_MAP, node, 'unsupported')),
                marks: (marksValidation?.enabledMarks ?? []).map((mark) => _.get(CONTENTFUL_MARKS_TYPES_MAP, mark, 'unsupported'))
            }
        };
    }
};

function getMinMax(field: ContentFields) {
    const validations = field.validations;
    const rangeValidation = _.find(validations, 'range');
    return rangeValidation
        ? {
              min: rangeValidation.range!.min,
              max: rangeValidation.range!.max
          }
        : null;
}

function getOptions(field: ContentFields) {
    const validations = field.validations;
    const inValidation = _.find(validations, 'in');
    return inValidation ? { options: inValidation.in! } : null;
}

function getListItems(field: ContentFields & Extract<ExtendedFieldType, { type: 'Array' }>) {
    const items = field.items;
    const itemType = items.type;
    if (items.type === 'Symbol') {
        return fieldConverterMap.Symbol(items as ContentFields & Extract<ExtendedFieldType, { type: 'Symbol' }>);
    } else if (items.type === 'Link') {
        return fieldConverterMap.Link(items as ContentFields & Extract<ExtendedFieldType, { type: 'Link' }>);
    } else if (items.type === 'ResourceLink') {
        return fieldConverterMap.ResourceLink({
            ...items,
            allowedResources: (field as ResourceLinkArray).allowedResources
        } as ContentFields & Extract<ExtendedFieldType, { type: 'ResourceLink' }>);
    } else {
        throw new Error(`not supported list items.type: ${itemType}, fieldId: ${field.id}`);
    }
}

function resolveLabelFieldForModel(contentType: ContentTypeProps, modelLabelFieldPath: string, fields: Field[]) {
    let labelField = contentType.displayField ?? null;
    if (labelField) {
        return labelField;
    }
    // see if there is a field named 'title'
    let titleField = _.find(fields, (field: Field) => field.name === 'title' && ['string', 'text'].includes(field.type));
    if (!titleField) {
        // see if there is a field named 'label'
        titleField = _.find(fields, (field: Field) => field.name === 'label' && ['string', 'text'].includes(field.type));
    }
    if (!titleField) {
        // get the first 'string' field
        titleField = _.find(fields, { type: 'string' });
    }
    if (titleField) {
        labelField = _.get(titleField, 'name');
    }
    return labelField;
}
