import { dirname, join, resolve } from "node:path";
import fs from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { ZodError } from "zod";
import { NetlifyIntegrationClient } from "../api/index.js";
import { envVarFromSlug } from "../utils.js";
import { NetlifyConnector, } from "./connect/sdk.js";
import { defaultOnDisableHandler, defaultOnDisconnectHandler, defaultOnEnableHandler, } from "./api/handlers.js";
import { INTEGRATION_API_URL_PROD, INTEGRATION_API_URL_STAGING, } from "../constants/urls.js";
export class NetlifyIntegration {
    _buildHooks;
    _wrappers;
    _handlers;
    _netlifyConnectPlugin;
    _buildConfigurationSchema;
    _buildContextSchema;
    _siteConfigSchema;
    _teamConfigSchema;
    _edgeFunctionsSettings;
    _functionsSettings;
    _slug = "";
    _buildHooksOptions;
    constructor({ buildConfigSchema, buildContextSchema, siteConfigSchema, teamConfigSchema, } = {}) {
        this._buildHooks = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
            onPreDev: null,
            onDev: null,
        };
        this._buildHooksOptions = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
            onPreDev: null,
            onDev: null,
        };
        this._buildConfigurationSchema = buildConfigSchema;
        this._buildContextSchema = buildContextSchema;
        this._siteConfigSchema = siteConfigSchema;
        this._teamConfigSchema = teamConfigSchema;
        this._handlers = {
            "on-enable": defaultOnEnableHandler,
            "on-disable": defaultOnDisableHandler,
            "on-disconnect": defaultOnDisconnectHandler,
        };
        this._wrappers = {};
    }
    get buildSlug() {
        return envVarFromSlug(this._slug);
    }
    /**
     * Used to add a build event handlers to the integration.
     */
    addBuildEventHandler(type, func, options) {
        if (options) {
            this._buildHooksOptions[type] = options;
        }
        this._buildHooks[type] = async (context) => {
            const buildToken = process.env[`${this.buildSlug}_BUILD_TOKEN`];
            const { netlifyConfig, constants } = context;
            const buildConfig = this.getBuildConfig({ netlifyConfig });
            let buildContext = undefined;
            if (buildToken) {
                const siteId = process.env.SITE_ID;
                const integrationResponse = await fetch(`https://api.netlifysdk.com/site/${siteId}/integrations/safe`);
                let url = `https://netlify-integration-${this._slug}.netlify.app`;
                if (integrationResponse.ok) {
                    const integrations = (await integrationResponse.json());
                    const integration = integrations.find((integration) => integration.slug === this._slug);
                    if (integration) {
                        url = integration.version;
                    }
                }
                const buildContextResponse = await fetch(`${url}/.netlify/functions/handler/build-context`, {
                    method: "POST",
                    headers: {
                        ["netlify-token"]: buildToken,
                    },
                    body: JSON.stringify({
                        site_id: process.env.SITE_ID,
                        token: buildToken,
                    }),
                });
                if (!buildContextResponse.ok) {
                    console.warn("Failed to fetch build context, skipping");
                    return;
                }
                try {
                    buildContext = (await buildContextResponse.json());
                }
                catch {
                    /* empty */
                }
            }
            const shouldInjectFunctions = type === "onPreBuild" || type === "onPreDev";
            if (this._functionsSettings?.prefix &&
                this._functionsSettings?.path &&
                shouldInjectFunctions) {
                const injectFunctions = this.injectFunctions(constants);
                await injectFunctions();
            }
            if (this._edgeFunctionsSettings?.prefix &&
                this._edgeFunctionsSettings?.path &&
                shouldInjectFunctions) {
                const injectEdgeFunctions = this.injectEdgeFunctions(constants);
                await injectEdgeFunctions();
            }
            return func({
                ...context,
                buildConfig,
                buildContext,
            });
        };
    }
    /**
     * Used to add a build context to the integration that can be used in a build hook.
     */
    addBuildEventContext(handler) {
        this._handlers["build-context"] = async (event, { client }) => {
            if (event.httpMethod !== "POST") {
                return {
                    statusCode: 405,
                };
            }
            const body = JSON.parse(event.body || "{}");
            const { site_id } = body;
            const { team_id, token } = await client.exchangeBuildToken(site_id);
            const isStaging = event.rawUrl?.includes(`.netlifystg.app`) ||
                event.path?.includes(`.netlifystg.app`);
            const jigsawUrl = isStaging
                ? INTEGRATION_API_URL_STAGING
                : INTEGRATION_API_URL_PROD;
            const newClient = new NetlifyIntegrationClient(token, this._slug, { jigsawUrl });
            const { config } = await newClient.getSiteIntegration(site_id);
            const buildContextContext = {
                site_id,
                site_config: config,
                client: newClient,
            };
            if (team_id) {
                const { config } = await newClient.getTeamIntegration(team_id);
                buildContextContext.team_id = team_id;
                buildContextContext.team_config = config;
            }
            const buildContext = await handler(buildContextContext);
            return {
                statusCode: 200,
                body: JSON.stringify(buildContext),
            };
        };
    }
    /**
     * Used to add an API Handler to the integration.
     */
    addApiHandler(name, handler) {
        this._handlers[name] = handler;
    }
    /**
     * Used to add a Wrapper to the integration.
     */
    addWrapper(name, handler) {
        this._wrappers[name] = handler;
    }
    /**
     * The handler to use for the onEnable endpoint.
     */
    onEnable(handler) {
        this._handlers["on-enable"] = async (event, context) => {
            const res = await defaultOnEnableHandler(event, context);
            if (res.statusCode !== 200) {
                return res;
            }
            const { siteId, teamId } = JSON.parse(event.body ?? "{}");
            return handler(event, { ...context, siteId, teamId });
        };
    }
    /**
     * The handler to use for the onDisable endpoint.
     */
    onDisable(handler) {
        this._handlers["on-disable"] = async (event, context) => {
            const { siteId, teamId } = event.queryStringParameters || {};
            if (!siteId && !teamId) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing siteId or teamId" }),
                };
            }
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200 &&
                integrationHandlerRes.statusCode !== 204) {
                return integrationHandlerRes;
            }
            return await defaultOnDisableHandler(event, context);
        };
    }
    /**
     * The handler to use for the onDisconnect endpoint.
     */
    onDisconnect(handler) {
        this._handlers["on-disconnect"] = async (event, context) => {
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200) {
                return integrationHandlerRes;
            }
            return {
                statusCode: 200,
                body: "Disconnected",
            };
        };
    }
    addWebhookHandler(name, handler) {
        const webhookName = name ? `webhook-${name}` : "webhook";
        this._handlers[webhookName] = handler;
    }
    /**
     * Used to inject edge functions into the user's site
     */
    injectEdgeFunctions(constants) {
        return async () => {
            const { INTERNAL_EDGE_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_EDGE_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_EDGE_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The ef directory will be in the site's base directory if defined, or in the repository root.
            const outDir = join(INTERNAL_EDGE_FUNCTIONS_SRC); //.netlify/edge-functions
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            const __filename = fileURLToPath(import.meta.url);
            const __dirname = dirname(__filename);
            // Find the edge functions we've copied over into the integration's build folder
            const sourcePath = join(__dirname, "edge-functions");
            try {
                const edgeFunctions = await fs.readdir(sourcePath, {
                    withFileTypes: true,
                });
                const copyPromises = edgeFunctions.map((item) => {
                    return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), {
                        recursive: true,
                    });
                });
                await Promise.all(copyPromises);
                console.log("Successfully injected edge functions");
            }
            catch (error) {
                console.error("Error copying files:", error);
            }
        };
    }
    /**
     * Used to inject functions into the user's site.
     */
    injectFunctions(constants) {
        return async () => {
            const { INTERNAL_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The ef directory will be in the site's base directory if defined, or in the repository root.
            const outDir = join(INTERNAL_FUNCTIONS_SRC); //.netlify/functions-internal
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            const __filename = fileURLToPath(import.meta.url);
            const __dirname = dirname(__filename);
            // Find the edge functions we've copied over into the integration's build folder
            const sourcePath = join(__dirname, "functions");
            try {
                const functions = await fs.readdir(sourcePath, { withFileTypes: true });
                const copyPromises = functions.map((item) => {
                    return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), {
                        recursive: true,
                    });
                });
                await Promise.all(copyPromises);
                console.log("Successfully injected functions");
            }
            catch (error) {
                console.error("Error copying files:", error);
            }
        };
    }
    /**
     * Used to add internal edge functions to the integration.
     *
     * @beta This feature is currently in beta testing. The API may change in future releases.
     */
    addEdgeFunctions(path, edgeFunctionsOptions) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        const prefix = edgeFunctionsOptions.prefix;
        if (!prefix) {
            throw new Error("You must provide a prefix on the edgeFunctionsSettings when initializing the integration.");
        }
        this._edgeFunctionsSettings = { prefix, path };
        this.addFallbackBuildEventHandlers();
    }
    /**
     * Used to add internal functions to the integration.
     *
     * @beta This feature is currently in beta testing. The API may change in future releases.
     */
    addFunctions(path, functionsOptions) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        const prefix = functionsOptions.prefix;
        if (!prefix) {
            throw new Error("You must provide a prefix on the functionsSettings when initializing the integration.");
        }
        this._functionsSettings = { prefix, path };
        this.addFallbackBuildEventHandlers();
    }
    addFallbackBuildEventHandlers() {
        if (!this._buildHooks.onPreBuild) {
            this.addBuildEventHandler("onPreBuild", () => {
                return;
            });
        }
        if (!this._buildHooks.onPreDev) {
            this.addBuildEventHandler("onPreDev", () => {
                return;
            });
        }
    }
    get buildHooks() {
        return this._buildHooks;
    }
    get buildHooksOptions() {
        return this._buildHooksOptions;
    }
    get handlers() {
        return this._handlers;
    }
    get wrappers() {
        return this._wrappers;
    }
    get baseHandler() {
        return async (event, context) => {
            const responseHeaders = {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Methods": "*",
            };
            // Fetch the path components from /api/<name> or /.netlify/functions/<name>
            // match with regex
            const routeRegex = /^(?:\/.netlify\/functions\/handler\/|\/api\/)([^/]+)(\/.*)?$/;
            const components = event.path.match(routeRegex);
            const name = components?.[1] ?? "not-found";
            const webhookHandler = name.startsWith("webhook");
            const handler = this._handlers[name];
            const isStaging = event.rawUrl?.includes(`.netlifystg.app`) ||
                event.path?.includes(`.netlifystg.app`);
            const jigsawUrl = isStaging
                ? INTEGRATION_API_URL_STAGING
                : INTEGRATION_API_URL_PROD;
            if (handler) {
                // Allow CORS preflight requests where the request does not come from the same origin
                if (event.httpMethod === "OPTIONS") {
                    return {
                        statusCode: 200,
                        headers: responseHeaders,
                    };
                }
                let nfToken = event.headers.cookie
                    ?.split(";")
                    .find((c) => c.includes("_nf-auth"))
                    ?.split("=")[1];
                if (!nfToken) {
                    nfToken = event.headers["netlify-token"];
                }
                if (!nfToken && !webhookHandler) {
                    return {
                        statusCode: 401,
                        headers: responseHeaders,
                        body: JSON.stringify({
                            error: "Unauthorized",
                        }),
                    };
                }
                const client = new NetlifyIntegrationClient(nfToken ?? "", this._slug, { jigsawUrl });
                const { siteId, teamId } = event.queryStringParameters ?? {};
                const { "provider-oauth-token": providerOAuthToken } = event.headers;
                event.path = `/${name}${components?.[2] ?? ""}`;
                const hasConnector = !!this._netlifyConnectPlugin;
                const hasBuildEventHandler = Object.values(this._buildHooks).filter(Boolean).length > 0;
                try {
                    const response = await handler(event, {
                        ...context,
                        siteId,
                        teamId,
                        providerOAuthToken,
                        client,
                        hasConnector,
                        hasBuildEventHandler,
                    });
                    response.headers = {
                        ...responseHeaders,
                        ...response.headers,
                    };
                    return response;
                }
                catch (e) {
                    console.error(e);
                    return {
                        statusCode: 500,
                        headers: responseHeaders,
                        body: "An unhandled error occurred",
                    };
                }
            }
            return {
                statusCode: 404,
                headers: responseHeaders,
                body: JSON.stringify({
                    error: `Handler ${name} not found`,
                }),
            };
        };
    }
    /**
     * `addConnector` creates a connector definition and attaches it to the integration definition.
     */
    addConnector({ defineOptions, initState, ...config }) {
        if (this._netlifyConnectPlugin) {
            throw new Error(`Connector plugin already exists. Only one connector can be built per integration.`);
        }
        if (!config?.typePrefix) {
            throw new Error(`You must provide a default typePrefix when creating a connector.`);
        }
        const connector = new NetlifyConnector(config);
        this._netlifyConnectPlugin = connector;
        if (initState !== undefined) {
            connector.init(initState);
        }
        if (defineOptions !== undefined) {
            connector.defineOptions(defineOptions);
        }
        return connector;
    }
    get netlifyConnectPlugin() {
        return this._netlifyConnectPlugin ?? null;
    }
    getBuildConfig({ netlifyConfig }) {
        let buildConfig;
        // Attempt to find the integration-specific configuration data
        const integrations = netlifyConfig?.integrations || [];
        if (Array.isArray(integrations)) {
            const integration = integrations.find((integration) => integration.name === this._slug);
            if (integration) {
                if (this._buildConfigurationSchema && integration.config) {
                    try {
                        buildConfig = this._buildConfigurationSchema.parse(integration.config);
                    }
                    catch (e) {
                        if (e instanceof ZodError) {
                            console.error("Failed to parse build configuration:", e.message);
                        }
                        return;
                    }
                }
            }
            if (!this._buildConfigurationSchema) {
                buildConfig = integration?.config;
            }
        }
        return buildConfig;
    }
    getBuildEventHandlersToRun({ netlifyConfig, }) {
        const buildConfig = this.getBuildConfig({ netlifyConfig }) || {};
        return Object.entries(this._buildHooks || {}).reduce((buildEventHandlers, [key, buildEventHandler]) => {
            if (!buildEventHandler) {
                return buildEventHandlers;
            }
            const dynamicConditional = this.buildHooksOptions?.[key]?.if;
            if (!dynamicConditional ||
                (dynamicConditional instanceof Function &&
                    dynamicConditional(buildConfig))) {
                buildEventHandlers[key] = buildEventHandler;
            }
            return buildEventHandlers;
        }, {});
    }
}
//# sourceMappingURL=index.js.map