import { ZodObject, ZodOptional, ZodDefault, ZodString, ZodNumber, ZodBoolean, ZodArray, } from "zod";
import "zod-metadata/register";
import { zodToJsonSchema } from "zod-to-json-schema";
const CONFIG_SDL_TAB_SPACING = `  `;
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function fieldNeedsRecursion(field) {
    return (field?._def.innerType instanceof ZodObject ||
        (field?._def.innerType instanceof ZodDefault &&
            field._def.innerType._def?.innerType instanceof ZodObject));
}
function getIsOptionalFieldString(field) {
    const optional = field._def.innerType instanceof ZodOptional ||
        field._def.innerType instanceof ZodDefault;
    let opStr = optional ? `` : `!`;
    if (!!opStr &&
        (field._def.typeName === `ZodOptional` ||
            field._def.typeName === `ZodDefault`)) {
        opStr = ``;
    }
    return opStr;
}
function createConfigSdl({ name, sdl, objStr, level, }) {
    if (level !== 0) {
        return objStr + `type ${capitalize(name)} {\n` + `  ${sdl}\n` + `}`;
    }
    const configStr = `input Config {\n` + `  ${sdl}\n` + `}`;
    return objStr + configStr;
}
function getGraphqlTypeFromZodType(zodType) {
    // given a zod type, return the corresponding graphql type
    const type = zodType;
    if (type instanceof ZodOptional || type instanceof ZodDefault) {
        return getGraphqlTypeFromZodType(type._def.innerType);
    }
    if (type instanceof ZodObject) {
        return capitalize(type._def.typeName);
    }
    if (type?._def.innerType instanceof ZodObject) {
        return getGraphqlTypeFromZodType(type._def.innerType);
    }
    if (type instanceof ZodArray) {
        return getGraphqlTypeFromZodType(type._def.type);
    }
    if (type instanceof ZodObject) {
        return capitalize(type._def.typeName);
    }
    switch (true) {
        case type instanceof ZodString:
            return `String`;
        case type instanceof ZodNumber:
            return `Int`;
        case type instanceof ZodBoolean:
            return `Boolean`;
        default:
            return `String`;
    }
}
export function zodToGraphqlSdl(zObject, options = {
    level: 0,
    name: ``,
}) {
    const { level, name } = options;
    // given a zod schema, create a graphql sdl string from it
    if (zObject instanceof ZodDefault) {
        zObject = zObject._def.innerType;
    }
    const fields = zObject.shape;
    const objects = [];
    const sdl = Object.keys(fields)
        .map((key) => {
        // get the field name and description
        const field = fields[key];
        const originalMeta = field.getMeta();
        const meta = { ...originalMeta };
        const schema = zodToJsonSchema(field);
        const { default: defaultValue } = schema;
        if (defaultValue) {
            meta.defaultValue = defaultValue;
            let helpText = [
                meta.helpText,
                defaultValue && `The default is **${defaultValue}**.`,
            ];
            if (meta.defaultValuePosition === `before`) {
                helpText = helpText.reverse();
            }
            meta.helpText = helpText.filter(Boolean).join(` `);
        }
        let gqlType;
        // recursively create sdl for nested objects
        if (fieldNeedsRecursion(field)) {
            const sdl = zodToGraphqlSdl(field._def.innerType, {
                level: level + 1,
                name: capitalize(key),
            });
            gqlType = capitalize(key);
            objects.push(sdl);
        }
        if (Object.keys(meta).length === 0) {
            throw new Error(`Meta info is required on all option field definitions.

Refer to the following example:
        
connector.defineOptions(({ zod }) => {
  return zod.object({
    foo: zod.string().meta({
      label: 'Example field',
      helpText: 'Some helpful text about this field',
      secret: false // set this to true for API tokens and other secret values
    })
  })
})`);
        }
        const desc = Object.keys(meta).length
            ? `""" ${JSON.stringify(meta)} """\n${CONFIG_SDL_TAB_SPACING}`
            : ``;
        // a field is optional if it is an instance of ZodOptional or ZodDefault
        const opStr = getIsOptionalFieldString(field);
        // handle arrays and arrays of objects
        if (field instanceof ZodArray) {
            // we need to check if the array is an array of objects
            if (field._def.type instanceof ZodObject) {
                const sdl = zodToGraphqlSdl(field._def.type, {
                    level: level + 1,
                    name: capitalize(key),
                });
                gqlType = capitalize(key);
                objects.push(sdl);
            }
            return `${desc}${key}: [${gqlType || getGraphqlTypeFromZodType(field)}!]${opStr}`;
        }
        // return the description, key, type, and isRequired/opStr string
        return `${desc}${key}: ${gqlType || getGraphqlTypeFromZodType(field)}${opStr}`;
    })
        .join(`\n${CONFIG_SDL_TAB_SPACING}`);
    const objStr = objects.length ? objects.join(`\n`) + `\n` : ``;
    // create types and inputs for the sdl
    return createConfigSdl({ name, sdl, objStr, level });
}
//# sourceMappingURL=zod-to-sdl.js.map