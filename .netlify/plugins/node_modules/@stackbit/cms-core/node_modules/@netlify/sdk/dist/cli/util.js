import { resolve } from "path";
import os from "os";
import { load } from "js-yaml";
import chalk from "chalk";
import fsExtraPkg from "fs-extra";
import { z } from "zod";
const { readFileSync, existsSync, readJSON } = fsExtraPkg;
const IntegrationConfigurationSchema = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    slug: z.string().regex(/^[a-z0-9-]+$/, "slug must be lowercase with dashes"),
    scopes: z
        .object({
        all: z.boolean().optional(),
        site: z.array(z.enum(["read", "write"])).optional(),
        env: z.array(z.enum(["read", "write", "delete"])).optional(),
        user: z.array(z.enum(["read", "write"])).optional(),
    })
        .optional(),
    integrationLevel: z.enum(["site", "team", "team-and-site"]).optional(),
    use_cjs_shims: z.boolean().optional(),
    connector: z
        .object({
        "local-frontend": z
            .object({
            port: z.number(),
            command: z.string(),
            directory: z.string(),
        })
            .optional(),
    })
        .optional(),
});
const possibleFiles = [
    "integration.yaml",
    "integration.yml",
    "integration.netlify.yaml",
    "integration.netlify.yml",
];
const getConfigurationFile = (cwd = process.cwd()) => {
    const fileName = possibleFiles.find((fileName) => existsSync(resolve(cwd, fileName)));
    return fileName;
};
export const getConfiguration = async (cwd = process.cwd()) => {
    const fileName = getConfigurationFile(cwd);
    if (!fileName) {
        throw new Error(`No configuration file found in ${cwd}`);
    }
    try {
        const { config } = load(readFileSync(resolve(cwd, fileName), "utf-8"));
        if (!config) {
            throw new Error("No configuration found");
        }
        const parseResult = IntegrationConfigurationSchema.safeParse(config);
        if (!parseResult.success) {
            console.error(parseResult.error.message);
            throw new Error("Invalid Configuration");
        }
        const buildSiteId = process.env.SITE_ID;
        if (buildSiteId) {
            const metadataRes = await fetch(`https://api.netlifysdk.com/meta/integration-host-site/${buildSiteId}`);
            if (metadataRes.status === 200) {
                const { slug } = (await metadataRes.json());
                config.slug = slug;
            }
        }
        return config;
    }
    catch (e) {
        console.error(e);
        console.error(`No configuration found in ${fileName} in ${cwd}`);
        process.exit(1);
    }
};
export const getIntegrationModule = async (builtPath, directory = process.cwd()) => {
    try {
        const integrationModule = await import(builtPath);
        const { integration } = integrationModule;
        if (!integration) {
            const { sourceFilePath } = await getIntegrationBuildInfo({
                cwd: directory,
            });
            throw new Error(`Your integration must be a named export in your main TS file (at ${sourceFilePath}).

For example:

import { NetlifyIntegration } from "@netlify/sdk";
const integration = new NetlifyIntegration();

export { integration } // <-- this is required.`);
        }
        return integration;
    }
    catch (e) {
        console.log(chalk.red("Could not load module"));
        if (e.message) {
            console.error(e.message);
        }
        throw e;
    }
};
export const getIntegrationBuildInfo = async ({ cwd, outDirOveride, }) => {
    const integrationPackageJson = await readJSON(resolve(cwd, "package.json"));
    // main points to our entrypoint
    const { main } = integrationPackageJson;
    if (!main) {
        throw new Error(`${integrationPackageJson.name || `package`} must set a "main" property in package.json`);
    }
    const sourceFilePath = resolve(cwd, main);
    if (!existsSync(sourceFilePath)) {
        throw new Error(`${integrationPackageJson.name || `package`}'s main property in package.json points to a non-existing file`);
    }
    const outDir = outDirOveride || resolve(`${cwd}/.ntli`);
    const builtPath = `${outDir}/index.js`;
    const packageName = integrationPackageJson.name;
    return {
        integrationPackageJson,
        sourceFilePath,
        builtPath,
        outDir,
        packageName,
    };
};
export function getDepNames(packageJsonContents, opts) {
    const deps = {
        ...(packageJsonContents.dependencies || {}),
        ...(packageJsonContents.devDependencies || {}),
    };
    return Object.keys(Object.fromEntries(Object.entries(deps).filter(([_, v]) => {
        const shouldExternalize = 
        // dont exclude file:/link: deps because they're local and must be bundled.
        // they wont be installable from NPM when this package is published.
        !v.startsWith("file:") && !v.startsWith("link:");
        return opts.external ? shouldExternalize : !shouldExternalize;
    })));
}
export function getInternalDepNames(packageJsonContents) {
    return getDepNames(packageJsonContents, {
        external: false,
    });
}
export function getExternalDepNames(packageJsonContents) {
    return getDepNames(packageJsonContents, {
        external: true,
    });
}
export function removeBundledDepsFromPackageJsonContents(packageJsonContents) {
    const internalDeps = getInternalDepNames(packageJsonContents);
    function removeInternalDeps(deps) {
        return Object.fromEntries(Object.entries(deps || {}).filter(([depName]) => !internalDeps.includes(depName)));
    }
    return {
        ...packageJsonContents,
        dependencies: removeInternalDeps(packageJsonContents.dependencies),
        devDependencies: removeInternalDeps(packageJsonContents.devDependencies),
    };
}
export const getSettings = () => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    if (!fsExtraPkg.existsSync(settingsPath)) {
        return {};
    }
    const settings = fsExtraPkg.readJSONSync(settingsPath);
    return settings;
};
export const updateSettings = (newSettings) => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    const settings = {
        ...(getSettings() || {}),
        ...newSettings,
    };
    fsExtraPkg.ensureFileSync(settingsPath);
    fsExtraPkg.writeJSONSync(settingsPath, settings);
};
//# sourceMappingURL=util.js.map