import { omitByUndefined } from "../utils/omit-by-undefined.js";
import { isTest, localDevWarnOnce, slugifyLocale } from "./utils.js";
import { ModelError } from "./error.js";
// See https://www.notion.so/netlify/Connector-localization-stage-1-f2d04ba3c13c4b1aacd60dfd37d781d0?pvs=4
export class ModelTransformer {
    builder;
    definition;
    isVisualEditorType = false;
    constructor(init) {
        this.definition = init.definition;
        this.builder = init.builder;
    }
    get runtimePlatform() {
        return this.builder.runtimePlatform;
    }
    inputNeedsDefaultLocalization(input) {
        if (typeof input === `undefined` || input === null)
            return true;
        if (Array.isArray(input))
            return true;
        if (typeof input === `object`) {
            // check if the object is localized
            for (const locale of this.definition.ModelBuilder.locales) {
                // atleast one locale code as a property is treated as a user localized field
                if (locale.code in input) {
                    return false;
                }
            }
        }
        return true;
    }
    // To allow connectors to easily enable localization without everything breaking, we allow non-localized values on localized fields and treat them as the default locale. This fn normalizes input data that's not localized into a default localized field shape.
    defaultLocalizeFieldValue(input) {
        if (this.inputNeedsDefaultLocalization(input)) {
            const defaultLocale = this.definition.ModelBuilder.getDefaultLocale();
            if (!defaultLocale)
                throw new Error(`No default locale found, but the Netlify SDK attempted to access one. This is a Netlify SDK bug.`);
            return {
                [defaultLocale]: input,
            };
        }
        if (typeof input !== `object` || !input) {
            throw new Error(`Expected value ${input} to be an object, but it's not. This is a Netlify SDK bug.`);
        }
        return input;
    }
    updateTreeContext(field, treeContext) {
        const updatedTreeContext = {
            path: field.name === `<ROOT_NODE>`
                ? treeContext.path
                : [...treeContext.path, field.name],
            visitorState: treeContext.visitorState,
        };
        return updatedTreeContext;
    }
    toOutputValue(input, field, treeContext) {
        const updatedTreeContext = this.updateTreeContext(field, treeContext);
        switch (field.list) {
            case true:
            case "required":
                return this.toOutputValueList(input, field, updatedTreeContext);
            case false:
            case undefined:
                return this.toOutputValueSingle(input, field, updatedTreeContext);
        }
    }
    maybeVisitListValue(input, field, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NO: backwards compat. Seems type visitors behave differently for enum vs non-enum list values.
        // enum visitors receive the whole array while all others are visited on each array item.
        if (this.definition.isEnumType) {
            return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
        }
        // OH NO 2: before transformer refactor we weren't running type visitors on relationship fields, only on root node values
        if (this.definition.isNodeType && !field.isRootValue) {
            // backwards compat
            return input;
        }
        return input?.map?.((item) => this.definition.ModelWalker.visitInputValue(item, treeContext.visitorState));
    }
    convertObjectLocaleValues(localized, convertValue, treeContext) {
        const convertedLocales = {};
        for (const locale of Object.keys(localized)) {
            if (this.definition.ModelBuilder.localeCodes.has(locale)) {
                convertedLocales[locale] = convertValue(localized[locale], locale);
            }
            else if (isTest) {
                throw new ModelError(`Encountered unknown locale ${locale} at path ${treeContext.path.join(".")}. This error is only thrown when process.env.NODE_ENV === "test"`);
            }
            else {
                localDevWarnOnce(`unknown-field-locale`, `While processing localized field ${treeContext.path.join(`.`)}, found field property that is not a known locale. Property: ${locale}, available locale codes: ${Array.from(this.definition.ModelBuilder.localeCodes.keys()).join(`, `)}`);
            }
        }
        return convertedLocales;
    }
    parseVisitedInputListLocalized(maybeLocalized, field, treeContext) {
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue, locale) => this.parseVisitedInputList(objectValue, field, {
            ...treeContext,
            path: [...treeContext.path, locale],
        }), treeContext);
    }
    toOutputValueList(input, field, treeContext) {
        const visited = 
        // if the field is localized and the field value is also a localized object
        field.localized && !this.inputNeedsDefaultLocalization(input)
            ? // visit each localized value
                this.convertObjectLocaleValues(input, (fieldVal) => {
                    return this.maybeVisitListValue(fieldVal, field, treeContext);
                }, treeContext)
            : // otherwise visit the input directly, it's not a localized object
                this.maybeVisitListValue(input, field, treeContext);
        if (!visited && field.list !== "required") {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, field, treeContext);
                    return this.toCreateListFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toCreateListFieldValue(this.parseVisitedInputList(visited, field, treeContext), field, treeContext);
                }
            }
            case "netlify-connect": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, field, treeContext);
                    return this.toConnectListFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toConnectListFieldValue(this.parseVisitedInputList(visited, field, treeContext), field, treeContext);
                }
            }
        }
    }
    maybeVisitSingleValue(input, field, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NOE: before models refactor we were only running type visitors for document types when they weren't relationship fields. In other words document/node visitors only run on the top level inserted node/document, not on any fields of that type
        if (this.definition.isNodeType && !field.isRootValue)
            return input;
        return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
    }
    parseVisitedInputSingleLocalized(maybeLocalized, field, treeContext) {
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue, locale) => this.parseVisitedInputSingle(objectValue, field, {
            ...treeContext,
            path: [...treeContext.path, locale],
        }), treeContext);
    }
    toOutputValueSingle(input, field, treeContext) {
        const visited = 
        // if the field is localized and the field value is also a localized object
        field.localized && !this.inputNeedsDefaultLocalization(input)
            ? // visit each localized value
                this.convertObjectLocaleValues(input, // <- !inputNeedsDefaultLocalization implies this. TODO: refactor this to remove `as`
                (fieldVal) => {
                    return this.maybeVisitSingleValue(fieldVal, field, treeContext);
                }, treeContext)
            : // otherwise visit the input directly, it's not a localized object
                this.maybeVisitSingleValue(input, field, treeContext);
        if (!visited && !field.required) {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, field, treeContext);
                    return this.toCreateSingleFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toCreateSingleFieldValue(this.parseVisitedInputSingle(visited, field, treeContext), field, treeContext);
                }
            }
            case "netlify-connect": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, field, treeContext);
                    return this.toConnectSingleFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toConnectSingleFieldValue(this.parseVisitedInputSingle(visited, field, treeContext), field, treeContext);
                }
            }
        }
    }
    toListFieldValue(input, field, treeContext) {
        if (!input && field.list !== `required`)
            return null;
        switch (this.runtimePlatform) {
            case "netlify-create": {
                return this.toCreateListFieldValue(input, field, treeContext);
            }
            case "netlify-connect": {
                return this.toConnectListFieldValue(input, field, treeContext);
            }
        }
    }
    notImplemented(methodName) {
        return new Error(`ModelTransformer.${methodName}() not implemented for type ${this.definition.getTypeName()} of kind ${this.definition.kind}`);
    }
    removeObjectKeysThatHaveNoFieldWithThatName(visited) {
        // Remove any keys that aren't defined fields
        Object.keys(visited || {}).forEach((key) => {
            const fieldName = this.definition.getFinalFieldName(key, visited?.__typename);
            if (!this.definition.ModelWalker.allowedFieldNames.has(fieldName)) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete visited[key];
            }
        });
        return visited;
    }
    toConnectFieldsDefinitionSDL() {
        const { definition } = this;
        let sdl = ``;
        for (const field of definition.fields) {
            const fieldName = field.name;
            const { type } = field;
            if (field.gql?.hidden === true) {
                continue;
            }
            const fieldTypeName = definition.getDefinedTypeName(type, fieldName);
            const transformer = this.definition.parseNameToTransformer(fieldTypeName);
            const resolvedField = this.definition.resolveModelField(field);
            const fieldModel = this.definition.ModelBuilder.models.get(fieldTypeName);
            let authDirective = ``;
            if (fieldModel) {
                const additionalFieldLabels = this.definition.fieldAuthLabels[fieldName];
                authDirective = fieldModel.getAuthorizationDirectiveSDL(additionalFieldLabels);
            }
            else {
                authDirective =
                    this.definition.getAuthorizationDirectiveForScalarFieldSDL(fieldName);
            }
            let fieldSdl = ``;
            if (authDirective) {
                fieldSdl = transformer.toConnectFieldDefinition({
                    ...resolvedField,
                    // auth directive fields must be nullable or unauthed queries will break with unrelated errors about
                    // returning null for non nullable fields
                    required: false,
                    list: resolvedField.list ? true : undefined,
                });
            }
            else {
                fieldSdl = transformer.toConnectFieldDefinition(resolvedField);
            }
            if (!fieldSdl)
                continue;
            fieldSdl += authDirective;
            sdl += fieldSdl;
            sdl += "\n";
            if (field.localized) {
                switch (this.definition.ModelBuilder.runtimePlatform) {
                    case "netlify-connect":
                        for (const { code } of this.definition.ModelBuilder.locales) {
                            const localizedFieldName = `${fieldName}__${slugifyLocale(code)}`;
                            // TODO: seems like these extra localized field definitions are in the wrong place which makes adding the link directive difficult
                            // refactor this so this isn't so hacky and verbose by moving it into the field to gql field method
                            sdl += `  ${localizedFieldName}: ${this.modelFieldToGraphQlFieldType(resolvedField)}${this.modelFieldToLinkDirective({
                                ...resolvedField,
                                name: localizedFieldName,
                            }, resolvedField.type.isNodeType ? `id` : undefined)}\n`;
                        }
                        break;
                    case "netlify-create":
                        // TODO: we may need something like this to support filtering by localized field values in Create
                        // in Connect the fieldName__locale fields can be used to filter, but in Create, those don't exist
                        // As of Jun 10th 2024 this wasn't part of requirements for shipping field localization, and I couldn't get this working properly. So I'm leaving this snippet here incase we need to pick back up from this point.
                        //
                        // for (const { code } of this.definition.ModelBuilder.locales) {
                        //   const linkDirective = ` @link(from: "${fieldName}.locales.${code}.value"${
                        //     this.definition?.isMixedUnion ? ` keepObjects: true` : ``
                        //   })`;
                        //
                        //   sdl += `  ${fieldName}__${slugifyLocale(code)}: ${this.modelFieldToGraphQlFieldType(resolvedField)}${linkDirective}\n`;
                        // }
                        break;
                }
            }
        }
        return sdl;
    }
    modelFieldToGraphQlFieldType(modelField, opts) {
        const listOpen = modelField.list ? `[` : ``;
        const type = opts?.asTypeName ||
            this.definition.prefixedTypeName(this.definition.getDefinedTypeName(modelField.type), modelField);
        // localized fields can't be non null in the gql api as it's extremely common for values besides the default language to be nullable, meaning querying for a non-default locale will almost always lead to query errors
        const nullMark = modelField.required && !modelField.localized ? `!` : ``;
        const listClose = modelField.list ? `]` : ``;
        const listNullMark = modelField.list === "required" ? `!` : ``;
        return listOpen + type + nullMark + listClose + listNullMark;
    }
    // Handles converting a ModelField into an SDL field representation, with null marks, lists, and proxies, depending on the field definition.
    modelFieldToGraphQLFieldSDL(modelField, opts) {
        const description = modelField?.description
            ? `  """${modelField.description}"""\n`
            : ``;
        const fieldName = modelField.name;
        const proxyDirective = this.modelFieldToCreateGraphQLProxy(modelField, opts?.proxyFrom);
        const linkDirective = this.modelFieldToLinkDirective(modelField, opts?.linkFrom);
        const localizedDirective = this.fieldToLocalizedDirective(modelField, opts?.proxyFrom);
        return `${description}  ${fieldName}: ${this.modelFieldToGraphQlFieldType(modelField, opts) + localizedDirective + proxyDirective + linkDirective}`;
    }
    modelFieldToLinkDirective(modelField, linkFrom) {
        return linkFrom
            ? ` @link(from: "${modelField.name}.${linkFrom}"${this.definition?.isMixedUnion ? ` keepObjects: true` : ``})`
            : ``;
    }
    fieldToLocalizedDirective(modelField, proxyFrom) {
        if (!modelField.localized) {
            return ``;
        }
        // codes item index maps to the same index in codesProxyFrom
        // ie: for slug "en-US"
        // with @localized(codes: ["fr-CA", "en-US"], codesProxyFrom: ["fieldName.something.fr_CA.value", "fieldName.something.en_US.value"])
        // The server would find the codes index of en-US, and use that index to find the relevant proxy in localCodesProxyFrom.
        // Why not use input objects? Seems content-engine&gatsby&connect never supported complex inputs in directive args.
        // Rather than do a bunch of work to fix it everywhere, this index lookup already works and is simple enough
        return ` @localized(
  codes: [${this.definition.ModelBuilder.locales
            .map((locale) => `"${locale.code}"`)
            .join(`, `)}],
  codesProxyFrom: [${this.definition.ModelBuilder.locales
            .map((locale) => `"${this.fieldToLocaleProxyArg(modelField, proxyFrom, locale.code)}"`)
            .join(", ")}]
)`;
    }
    fieldToLocaleProxyArg(modelField, proxyFrom, locale) {
        if (!locale)
            return ``;
        switch (this.runtimePlatform) {
            case "netlify-create":
                return `${modelField.name}.locales.${locale}.${proxyFrom}`;
            case "netlify-connect":
                // in production runtime connect, neo4j must store fields in a flat structure, for example a string field cannot be stored
                // as an object where the keys are locales with string values
                // to get around this, we store each localized field beside the original field in a flat structure.
                // for ex fieldName__en_US.
                // the locale must be slugified since this is a GraphQL field name
                return `${modelField.name}__${slugifyLocale(locale)}${this.definition.isNodeType ? `.id` : ``}`;
        }
    }
    modelFieldToCreateGraphQLProxy(modelField, proxyFrom) {
        if (modelField.localized) {
            // Add a proxy to the default locale when a field is localized
            // this is so Connect and the visual editor gql api can resolve localized fields without yet having the @locale() directive
            // and also resolve the default locale when @locale() is supported, but not provided from the client query.
            return ` @proxy(from: "${this.fieldToLocaleProxyArg(modelField, proxyFrom, this.definition.ModelBuilder.getDefaultLocale())}")`;
        }
        if (!proxyFrom) {
            return ``;
        }
        return this.proxyFrom(`${modelField.name}.${proxyFrom}`);
    }
    proxyFrom(proxyFrom) {
        if (this.runtimePlatform !== `netlify-create`) {
            return ``;
        }
        return ` @proxy(from: "${proxyFrom}")`;
    }
    modelFieldToSharedCreateProperties(modelField) {
        return omitByUndefined({
            name: modelField.name,
            default: modelField.editor?.initialValue,
            group: modelField.editor?.group,
            readOnly: modelField.editor?.readOnly,
            hidden: modelField.editor?.hidden,
            label: modelField.editor?.label,
            description: modelField.description,
            localized: modelField.localized,
            // any field names starting with _ are internal mandatory fields.
            // they shouldn't be set as required in the Create UI as content admins
            // don't need to set these fields, connector authors do.
            required: modelField.name.startsWith(`_`)
                ? undefined
                : modelField.required,
            controlType: this.modelFieldToSharedControlType(modelField),
        });
    }
    modelFieldToSharedCreateNumberProperties(modelField) {
        const { max, min, step, unit } = modelField.editor?.numberOptions || {};
        return {
            type: "number",
            min,
            max,
            step,
            unit,
        };
    }
    modelFieldToSharedControlType(field) {
        const controlType = field.editor?.controlType;
        // These aren't Netlify Create control types, the SDK uses them to differentiate between an Asset that's a file or an image.
        if (controlType === `file` || controlType === `image`) {
            return undefined;
        }
        return controlType;
    }
    // converts this SDK model into a top level Connect SDL GraphQL type
    toConnectDefinition(_ctx) {
        throw this.notImplemented(`toConnectDefinition`);
    }
    toConnectFieldLocalizedDefinition(_ctx) {
        throw this.notImplemented(`toConnectDefinition`);
    }
    // converts this model into a field definition within another top level SDL type
    toConnectFieldDefinition(modelField) {
        switch (modelField.list) {
            case "required":
            case true:
                return this.toConnectListFieldDefinition(modelField);
            case false:
            default:
                return this.toConnectSingleFieldDefinition(modelField);
        }
    }
    toConnectSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    toConnectListFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    // converts this model into a top level Create model definition
    toCreateDefinition() {
        throw this.notImplemented(`toCreateDefinition`);
    }
    // converts this model into a field definition at any level on another Create model definition or field
    toCreateFieldDefinition(modelField) {
        const resolvedModelField = this.definition.resolveModelField(modelField);
        switch (modelField.list) {
            case "required":
            case true:
                return this.toCreateListFieldDefinition(resolvedModelField);
            case false:
            default:
                return this.toCreateSingleFieldDefinition(resolvedModelField);
        }
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateSingleFieldDefinition`);
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateListFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateListFieldDefinition`);
    }
    // takes in connector user input data and normalizes it for storage in Netlify Create
    toCreateSingleFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValue`);
    }
    toCreateSingleFieldValueLocalized(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValueLocalized`);
    }
    // same as above but for when this type is used in a list
    toCreateListFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateListFieldValue`);
    }
    toCreateListFieldValueLocalized(input, field, treeContext) {
        return {
            type: `list`,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                if (!Array.isArray(value)) {
                    throw new Error(`Encountered non-array value where an array was expected. This may be a bug in the Netlify SDK.`);
                }
                return {
                    locale,
                    items: value.map((v) => this.toCreateSingleFieldValue(v, {
                        ...field,
                        // need to set list to false because this field is a list type, but we're
                        // processing each item in that list using the field definition.
                        list: false,
                        // Also set localized to false since we're already localizing at this level
                        localized: false,
                    }, { ...treeContext, path: [...treeContext.path, locale] })),
                };
            }, treeContext),
        };
    }
    // same as above but for Netlify Connect data storage
    toConnectSingleFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toConnectSingleFieldValue`);
    }
    toConnectSingleFieldValueLocalized(input, field, treeContext) {
        const formattedLocales = {};
        for (const locale of Object.keys(input)) {
            formattedLocales[locale] = this.toConnectSingleFieldValue(input[locale], field, treeContext);
        }
        return formattedLocales;
    }
    toConnectListFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toConnectListFieldValue`);
    }
    toConnectListFieldValueLocalized(input, field, treeContext) {
        const formattedLocales = {};
        for (const locale of Object.keys(input)) {
            formattedLocales[locale] = this.toConnectListFieldValue(input[locale], { ...field, localized: false }, treeContext);
        }
        return formattedLocales;
    }
    // throws helpful errors when the data that's about to be inserted in the DB is the wrong type
    // "parseVisited" because the connector can insert any shape they want, and then transform it to the right shape with a visitor fn. So we need to validate that it's the right type _after_ they've visited it (if they did visit it - we will still parse here if they didn't. naming?)
    // only runs during local dev so that incorrect data in prod doesn't kill the whole sourcing process. or perhaps we can catch ModelError and only warn in prod, but fail sourcing in dev.
    parseVisitedInputSingle(_visited, _field, _treeContext) {
        throw this.notImplemented(`parseVisitedInputSingle`);
    }
    parseVisitedInputList(_visited, _field, _treeContext) {
        throw this.notImplemented(`parseVisitedInputList`);
    }
}
//# sourceMappingURL=transformer.js.map