import path from "path";
import { parentPort, workerData } from "worker_threads";
import fsExtra from "fs-extra";
import { zodToGraphqlSdl } from "../../integration/connect/utils/zod-to-sdl.js";
import { getConfiguration, getIntegrationModule, } from "../../cli/util.js";
const { writeFile, ensureDir } = fsExtra;
// this worker is used to load the latest version of the integration module.
// because esm doesn't allow clearing the require cache, this allows us to get the latest version of the integration module including any user code changes.
// previously we just appended a query param to the import, but that creates a memory leak where copies of the same module are loaded into memory over and over again and never garbage collected.
class IntegrationWorker {
    integrationModulePath;
    integrationDirectory;
    integration;
    config;
    constructor() {
        if (!parentPort) {
            throw new Error("No parent port. integrationWorker must be run in a worker thread.");
        }
        const { integrationPath } = workerData;
        if (!integrationPath) {
            throw new Error(`No integration path provided.`);
        }
        // [userdir]/.ntli/index.js
        this.integrationModulePath = integrationPath;
        // [userdir]/
        this.integrationDirectory = path.dirname(path.dirname(integrationPath));
        parentPort.on(`message`, async (message) => {
            const { type, id, payload } = message;
            if (!type) {
                throw new Error(`No message type provided.`);
            }
            if (!message.id) {
                throw new Error(`No message id provided.`);
            }
            if (type !== `loadModule` && !this.integration) {
                throw new Error(`Integration not loaded but ${type} message was received. The integration worker must be loaded before any other messages are sent.`);
            }
            if (type in this && this[type] && typeof this[type] === `function`) {
                try {
                    // eslint-disable-next-line @typescript-eslint/await-thenable -- Please fix me, I didn't have the guts to touch this
                    const result = await this[type](payload);
                    parentPort?.postMessage({
                        id,
                        result,
                    });
                }
                catch (e) {
                    console.error(e);
                    throw e;
                }
            }
            else {
                throw new Error(`Unknown message type: ${type}`);
            }
        });
    }
    async loadModule(directory) {
        try {
            const integration = await getIntegrationModule(this.integrationModulePath, directory);
            this.integration = integration;
            this.config = await getConfiguration(this.integrationDirectory);
            return true;
        }
        catch (e) {
            console.error(e);
            return {
                failed: true,
                message: (e.stack ?? "") +
                    `\n\nintegration path: ${this.integrationDirectory}`,
            };
        }
    }
    async hasConnector() {
        return !!this.integration?.netlifyConnectPlugin;
    }
    async writeConnectorOptionsSchema() {
        if (!this.integration) {
            throw new Error(`No integration loaded.`);
        }
        if (!this.integration.netlifyConnectPlugin) {
            throw new Error(`No connector found in integration.`);
        }
        const optionsSchema = this.integration.netlifyConnectPlugin.getOptionsSchema();
        const optionsSDL = zodToGraphqlSdl(optionsSchema);
        if (!this.config?.slug) {
            throw new Error(`An integration.yaml with a slug is required`);
        }
        const staticDir = path.join(this.integrationDirectory, `/.ntli/site/static/${this.config.slug}/connector`);
        await ensureDir(staticDir);
        const optionsSchemaPath = path.join(staticDir, `options-sdl.gql`);
        await writeFile(optionsSchemaPath, optionsSDL);
        return true;
    }
    getConnectorConfig() {
        return this.integration?.netlifyConnectPlugin?.config || {};
    }
}
new IntegrationWorker();
//# sourceMappingURL=worker.js.map