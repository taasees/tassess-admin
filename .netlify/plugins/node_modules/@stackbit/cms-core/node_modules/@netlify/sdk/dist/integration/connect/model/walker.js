import { builtInScalars, } from "./definition.js";
import { ModelError } from "./error.js";
import { isTest, isLocalDev, slugifyLocale } from "./utils.js";
export class ModelWalker {
    definition;
    getModelByName;
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.definition = model;
        this.getModelByName = getModelByName;
    }
    build() {
        if (this.definition.isUnionType && this.definition.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.definition.compositeTypes) {
                const typeName = this.definition.getDefinedTypeName(type, this.definition.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel && !builtInScalars.has(typeName)) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.definition.getTypeName()}"`);
                }
                if (typeModel) {
                    for (const { name } of typeModel.getFields()) {
                        this.allowedFieldNames.add(name);
                    }
                }
            }
        }
        for (const fieldDefinition of this.definition.getFields()) {
            const fieldName = fieldDefinition.name;
            const fieldTypeName = this.definition.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInScalars.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.definition.getTypeName()}"`);
            }
            const unCameled = this.definition.camelToOriginalNames.get(fieldName);
            if (unCameled) {
                this.allowedFieldNames.add(unCameled);
            }
            this.allowedFieldNames.add(fieldName);
        }
    }
    fieldInfoByName(name, visitorState) {
        const definedField = this.definition.fieldsMap.get(name);
        if (!definedField) {
            throw new Error(`No defined field found for ${name}`);
        }
        const field = this.definition.resolveModelField(definedField);
        const originalFieldName = this.definition.camelToOriginalNames.get(definedField.name) ||
            definedField.name;
        return {
            name: definedField.name,
            originalName: originalFieldName,
            typeName: field.type.getTypeName(),
            list: field.list || false,
            required: field.required || false,
            is: {
                scalar: field.type.isScalarType,
                node: field.type.isNodeType,
                union: field.type.isUnionType,
                object: field.type.isObjectType,
            },
            get fields() {
                return field.type.ModelWalker.fields;
            },
            get visitorContext() {
                return visitorState.context;
            },
            setVisitorContext(newValue) {
                visitorState.context = newValue;
            },
        };
    }
    get fields() {
        const fields = {};
        const modelFields = this.definition.getFields();
        if (!modelFields.length)
            return undefined;
        for (const field of modelFields) {
            // ID field is on all node types, don't send it to visitor field info as it's not a user-defined field
            if (field.name === `id` && this.definition.isNodeType)
                continue;
            fields[field.name] = this.fieldInfoByName(field.name, {
                context: null,
            });
        }
        return fields;
    }
    visitInputValue(
    // input value can be "any" because the connector author can input any data they want and use the visitor to structure it in the shape defined by their models
    inputValue, visitorState) {
        if (typeof this.definition.visitor !== `function`) {
            return inputValue;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const walker = this;
        const visitorInfo = {
            setVisitorContext(newContext) {
                visitorState.context = newContext;
            },
            get fields() {
                return walker.fields;
            },
            get visitorContext() {
                return visitorState?.context;
            },
        };
        return this.definition.visitor(inputValue, visitorInfo);
    }
    transformModelValue({ modelValue, field, treeContext, }) {
        const transformer = this.definition.ModelTransformer;
        if (!transformer) {
            throw new Error(`ModelTransformer not found for model ${this.definition.getTypeName()} on field ${field.name}`);
        }
        const value = transformer.toOutputValue(modelValue, field, treeContext); // TODO: this is temporary to satisfy coerceModelValue
        return value;
    }
    coerceModelValue(modelValue, field, path = [], visitorState = { context: null }) {
        const model = field.type.isUnionType ? this.definition : field.type;
        const asWalker = model.ModelWalker;
        return asWalker.transformModelValue({
            modelValue,
            field: field,
            treeContext: {
                path,
                visitorState,
            },
        });
    }
    coerceFields(coercedValue, path, visitorState) {
        for (const definedField of this.definition.getFields()) {
            const field = this.definition.resolveModelField(definedField);
            const uncameled = this.definition.camelToOriginalNames.get(field.name);
            if (uncameled && typeof coercedValue[uncameled] !== `undefined`) {
                coercedValue[field.name] = coercedValue[uncameled];
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete coercedValue[uncameled];
            }
            if (field.visitor) {
                if (
                // if the field is localized
                field.localized &&
                    // and the field is an object with localized keys
                    !this.definition.ModelTransformer.inputNeedsDefaultLocalization(coercedValue[field.name])) {
                    // run the field visitor on each locale
                    coercedValue[field.name] =
                        this.definition.ModelTransformer.convertObjectLocaleValues(coercedValue[field.name], (fieldValue) => {
                            return field.visitor?.(fieldValue, this.fieldInfoByName(field.name, visitorState));
                        }, {
                            path,
                            visitorState,
                        });
                }
                else {
                    coercedValue[field.name] = field.visitor(coercedValue[field.name], this.fieldInfoByName(field.name, visitorState));
                }
            }
            if ((isLocalDev || isTest) &&
                // if the field is not defined as localized: true
                !field.localized &&
                // but the field data appears to be localized - ie the input data is an object with locales as keys
                !this.definition.ModelTransformer.inputNeedsDefaultLocalization(coercedValue[field.name])) {
                // error because if we silently allow this, the GraphQL API will be broken. Each localized field must have localized: true
                // so that we will add the @localized(codes:x) directive to it, signaling to the server how to resolve localized field data.
                // without this, the gql API will show cryptic errors about resolving the wrong shape for the type of the field.
                throw new ModelError(`Input data for field "${this.definition.getTypeName()}.${field.name}" appears to be localized, but this field is not defined as localized in this connector.

Example:

define.${this.definition.isObjectType ? "object" : "document"}({ 
  name: "${this.definition.getTypeName()}",
  fields: {
    ${field.name}: {
      // ...
      localized: true  <-- this is required but missing
    }
  }
})`);
            }
            const fieldValue = field.type.ModelWalker.transformModelValue({
                field,
                modelValue: coercedValue[field.name],
                treeContext: {
                    path,
                    visitorState,
                },
            });
            const shouldFlattenLocalizedField = field.localized &&
                this.definition.ModelBuilder.runtimePlatform === "netlify-connect" &&
                Boolean(fieldValue);
            if (!shouldFlattenLocalizedField) {
                coercedValue[field.name] = fieldValue;
            }
            else if (shouldFlattenLocalizedField) {
                // remove the non-localized field name so we don't double store all localized field values
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete coercedValue[field.name];
                // flatten localized field values
                // ie turn
                // fieldName: { en-US: "Hi" }
                // into
                // fieldName__en-US: "Hi"
                // In production connect a string field cannot be stored as an object where the keys are locales and the values are strings, so we flatten our localized object into multiple keys instead
                for (const [locale, localizedValue] of Object.entries(fieldValue)) {
                    coercedValue[`${field.name}__${slugifyLocale(locale)}`] =
                        localizedValue;
                }
            }
        }
    }
}
//# sourceMappingURL=walker.js.map