import { ModelBuilder } from "./model/builder.js";
import { CSIBridgeAPI } from "./bridge/csi-module-bridge.js";
import { SourcePluginBridgeAPI } from "./bridge/source-plugin-bridge.js";
import { ModelError } from "./model/error.js";
import { delayedExit } from "./utils/delayed-exit.js";
import { getAPIPromises } from "./utils/api-promises.js";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, lmdbStoredScheduledActionToStackbit, } from "./utils/data.js";
import { createId } from "./utils/create-id.js";
/*
 * This class is used to store a running instance of a connector, and the instanceID used to look it up
 * The NetlifyConnector class represents the connector implementation, and the ConfiguredNetlifyConnector is a running instance of that connector
 * One NetlifyConnector may have many ConfiguredNetlifyConnector instances, each with a unique instanceID
 * Each ConfiguredNetlifyConnector has one NetlifyConnector instance
 * This is so that the same connector can be used multiple times with different options with separate memory state for each
 */
export class ConfiguredNetlifyConnector {
    NetlifyConnector;
    instanceID;
    sourcePluginAPI;
    csiModuleAPI;
    /**
     * As of January 24, 2023:
     *
     * Knowledge of what platform the connector is running on changes the logic that happens as part of Netlify Create.
     * As there might be other platforms that also need to change their behaviour based on the environment that the connector
     * is running in the future, we're storing this information in the connector instance.
     *
     */
    platform = "unknown";
    runtimeSupportsCreate = false;
    warmCacheKey = `netlify-connector-warm-cache`;
    ModelBuilder;
    nodesApi = { webhookBody: {} };
    createApi = {};
    optionsValues = {};
    initState = {};
    syncCount = 0;
    slug;
    config;
    constructor({ NetlifyConnector, instanceID, config, slug, }) {
        this.instanceID = instanceID;
        this.NetlifyConnector = NetlifyConnector;
        this.config = config;
        this.slug = slug;
        this.ModelBuilder = new ModelBuilder({
            nodesApi: this.nodesApi,
            createApi: this.createApi,
            supports: NetlifyConnector.supports,
            slug: this.slug,
            createId: this.createId.bind(this),
            shouldHandleCreateSupport: this.shouldHandleCreateSupport.bind(this),
            instanceID,
        });
        this.sourcePluginAPI = new SourcePluginBridgeAPI(this);
        this.csiModuleAPI = new CSIBridgeAPI(this);
    }
    createId(id, modelName) {
        return createId(modelName + id, this.instanceID);
    }
    // get getAPIPromises for this configured connector instance by apiName
    getAPIPromises(apiName) {
        const promises = getAPIPromises(this.instanceID, apiName, this.NetlifyConnector.supports);
        if (apiName === "init") {
            // connect init runs on both Connect/Create so wait for it to resolve before setting the platform
            // no matter the platform, the init promise will always resolve,
            promises.connect?.promise?.finally(() => {
                if (process.env.SDK_ENV === "development") {
                    this.platform = "local";
                }
                else if (process.env.RESOURCE_TYPE === "DATA_LAYER") {
                    // The above env var is set in the Connect codebase itself
                    this.platform = "netlify-connect";
                }
                else if (this.shouldHandleCreateSupport()) {
                    this.platform = "netlify-visual-editor";
                }
            });
        }
        return promises;
    }
    get proxiedSchemas() {
        return this.NetlifyConnector.proxiedSchemas;
    }
    get definedImplementations() {
        return this.NetlifyConnector.definedImplementations;
    }
    get isUsingUnifiedAPI() {
        return this.NetlifyConnector.isUsingUnifiedAPI;
    }
    get supports() {
        return this.NetlifyConnector.supports;
    }
    shouldHandleCreateSupport() {
        return (this.NetlifyConnector.config.supports?.create &&
            this.runtimeSupportsCreate);
    }
    setRuntimeSupportsCreate() {
        if (this.config.supports?.create) {
            this.runtimeSupportsCreate = true;
            this.getAPIPromises(`runtime`).create.resolve();
        }
        else {
            throw new Error(`Connector does not support Netlify Create. This connector must enable Netlify Create support before it can be used.`);
        }
    }
    setOptionsValues(options) {
        try {
            this.NetlifyConnector.optionsSchema?.validate(options, this.slug);
        }
        catch (e) {
            if (e instanceof ModelError) {
                console.error(e.message);
            }
            else {
                console.error(e);
            }
            return delayedExit();
        }
        this.optionsValues = options;
    }
    setInitState(state) {
        this.initState = state;
    }
    async getLmdbDatastore() {
        const { getLmdbStore } = (await import(
        // content-engine is an external dep of the SDK, and the same content-engine instance must be used between Stackbit and the SDK
        // this is a non-statically analyzable import so stackbit can't bundle it in esbuild
        `@netlify/content-engine/dist/datastore/lmdb/lmdb-datastore.js?${Math.random()}`));
        const datastore = getLmdbStore();
        await datastore.ready();
        return datastore;
    }
    async restoreAllDocuments() {
        const datastore = await this.getLmdbDatastore();
        const allDocuments = [];
        for (const [name, definition] of this.ModelBuilder.models) {
            // assets are restored separately
            if (name === `Asset`)
                continue;
            // scheduled actions are restored separately
            if (name === "ScheduledAction")
                continue;
            const nodesOfModelType = datastore.getNodesByType(definition.prefixedTypeName());
            nodesOfModelType.forEach((n) => allDocuments.push(lmdbStoredDocumentToStackbit(n, definition)));
        }
        return allDocuments;
    }
    async restoreAllAssets() {
        const definition = this.ModelBuilder.models.get(`Asset`);
        if (!definition) {
            throw new Error("Expected Asset model to be defined, but it is not.");
        }
        const nodesOfModelType = (await this.getLmdbDatastore()).getNodesByType(definition.prefixedTypeName());
        return nodesOfModelType.map(lmdbStoredAssetToStackbit);
    }
    async restoreAllScheduledActions() {
        const definition = this.ModelBuilder.models.get("ScheduledAction");
        if (!definition) {
            throw new Error("Expected ScheduledAction model to be defined, but it is not.");
        }
        const store = await this.getLmdbDatastore();
        return store
            .getNodesByType("ScheduledAction")
            .map(lmdbStoredScheduledActionToStackbit);
    }
    async sync(args) {
        if (this.isUsingUnifiedAPI) {
            await this.unifiedSync(args);
        }
        else {
            await this.legacySync(args);
        }
    }
    legacySyncWrapper = (name, implementation) => {
        const models = this.ModelBuilder.modelDataAPIs;
        const cache = this.nodesApi.cache;
        const pluginOptions = this.nodesApi.pluginOptions;
        const webhookBody = this.nodesApi.webhookBody || {};
        if (!models || !cache || !pluginOptions) {
            throw new Error(`Cannot invoke events before models have been defined.`);
        }
        if (name === `updateNodes` && implementation === false) {
            const createAllNodes = this.definedImplementations["event.createAllNodes"];
            if (!createAllNodes) {
                throw new Error(`Cannot set updateNodes to false if createAllNodes is not defined.`);
            }
            return this.legacySyncWrapper(`createAllNodes`, createAllNodes);
        }
        if (implementation === false) {
            throw new Error(`Cannot set ${name} to false.`);
        }
        return implementation({
            models,
            cache,
            webhookBody,
        }, pluginOptions);
    };
    // for connectors that are using connector.event(name, impl) instead of the new unified connector API.
    // mostly needed in order to break up the unified API into smaller PR's and keep shipping small pieces
    async legacySync({ actions, cache }) {
        const { enableStatefulSourceNodes } = actions;
        if (typeof enableStatefulSourceNodes !== `function`) {
            if (!this.proxiedSchemas.length) {
                // all versions of content-engine have this API.
                // not all versions of Gatsby do. Since connectors built with this API can theoretically be run by Gatsby as well, and old versions of Gatsby, we need to throw here if the API is not available.
                throw new Error(`Your version of Gatsby is too old to support this plugin. You need gatsby@>=5.9.0 or any version of content-engine.`);
            }
        }
        const createAllNodes = this.definedImplementations["event.createAllNodes"];
        if (!createAllNodes) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No connector.createAllNodes(implementation) was defined. This API is required for all connectors.`);
        }
        const updateNodes = this.definedImplementations["event.updateNodes"];
        // updateNodes may be set to false, so need to check undefined
        if (typeof updateNodes === `undefined`) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No updateNodes implementation was defined. All connectors should support incremental data fetching. If yours cannot, you can set this API to "false" so that maintainers see immediately that your plugin does no caching. ie:

connector.event('createAllNodes', () => {})
connector.event('updateNodes', false)
`);
        }
        if (updateNodes !== false) {
            // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support incremental data updates.
            enableStatefulSourceNodes();
        }
        const isWarmCache = await cache.get(this.warmCacheKey);
        if (!isWarmCache) {
            await this.legacySyncWrapper(`createAllNodes`, createAllNodes);
            await cache.set(this.warmCacheKey, true);
        }
        else {
            return this.legacySyncWrapper(`updateNodes`, updateNodes);
        }
    }
    async unifiedSync({ actions, cache }) {
        const sync = this.definedImplementations.sync;
        if (!sync) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No connector.documents({ sync: implementation }) was defined. This API is required for all connectors.`);
        }
        if (this.supports.deltaSync) {
            const { enableStatefulSourceNodes } = actions;
            if (typeof enableStatefulSourceNodes !== `function`) {
                throw new Error(`Could not enable delta syncing. This is a bug in content-engine.`);
            }
            // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support delta syncing. This is the default behaviour
            enableStatefulSourceNodes();
        }
        const isDeltaSync = this.supports.deltaSync
            ? !!(await cache.get(this.warmCacheKey))
            : null;
        const { connect } = this.getAPIPromises(`sync`);
        const models = this.ModelBuilder.modelDataAPIs;
        const webhookBody = this.nodesApi.webhookBody || {};
        const options = this.optionsValues;
        if (!models || !cache || !options) {
            throw new Error(`Cannot invoke events before models have been defined.`);
        }
        await sync({
            models,
            cache,
            webhookBody,
            isInitialSync: !isDeltaSync,
            state: this.initState,
            options,
            platform: this.platform,
        });
        connect.resolve();
        if (!isDeltaSync && this.supports.deltaSync) {
            await cache.set(this.warmCacheKey, true);
        }
    }
    get typePrefix() {
        return this.optionsValues?.typePrefix || this.config.typePrefix;
    }
    async _buildDefinedModels(cache) {
        const modeler = this.definedImplementations.model;
        if (!modeler) {
            if (this.proxiedSchemas.length) {
                // if there are proxied schemas, it's fine that the connector didn't define models
                return {
                    sdl: ``,
                };
            }
            throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
        }
        const { sdl } = await this.ModelBuilder.build({
            modeler,
            typePrefix: this.typePrefix,
            cache,
            configurationOptions: this.optionsValues,
            state: this.initState,
            shouldAutoRenameFieldsAndModels: !this.supports.create,
            platform: this.platform,
        });
        return {
            sdl,
        };
    }
    async _initialize() {
        if (this.supports.create) {
            // TODO: figure out a way to remove this timeout entirely. It's no longer needed, however a lot of other logic is built around waiting here - removing it seems to cause race conditions.
            // in the meantime, SDK_WAIT_FOR_CREATE_RUNTIME_DURATION is used to speed up tests
            const durationEnvVar = Number(process.env.SDK_WAIT_FOR_CREATE_RUNTIME_DURATION);
            const duration = !isNaN(durationEnvVar) ? durationEnvVar : 500;
            // wait .05s for Create to start and respond to the runtime prom, otherwise assume there's no
            // Create runtime in the current process. This is a workaround because of the dynamic import of the integration in the CSI module. The dynamic import will resolve within this amount of time.
            // by default we resolve runtime create support as false so that the connector still works in Connect without Create
            const { create } = this.getAPIPromises(`runtime`);
            const runtimeCreateTimeout = setTimeout(() => {
                create.resolve(false);
            }, Number(duration));
            await create.promise;
            clearTimeout(runtimeCreateTimeout);
        }
        const { create, connect } = this.getAPIPromises(`init`);
        const init = this.definedImplementations.init;
        if (init) {
            const val = await init({
                options: this.optionsValues,
                cache: this.sourcePluginAPI.contentEngineCache,
                platform: this.platform,
            });
            if (val) {
                this.setInitState(val);
            }
        }
        connect.resolve();
        // receive the create API from Create for updating data.
        if (this.shouldHandleCreateSupport()) {
            const createAPI = await create.promise;
            if (createAPI) {
                for (const key of Object.keys(createAPI)) {
                    // @ts-ignore mutating each object key so that any references to the createApi object aren't lost
                    this.createApi[key] = createAPI[key];
                }
            }
        }
    }
}
export function setGlobalConnectorInstance(connectorName, instanceID, connectorInstance) {
    globalThis.__globalConnectorInstances ||= new Map();
    const instances = globalThis.__globalConnectorInstances;
    const instanceName = connectorName + instanceID;
    if (instances.has(instanceName)) {
        throw new Error(`Two connectors with the same name and instance ID ${instanceName} have been initialized. You'll need to ensure multiple connector instances that are using the same connector package have unique plugin options. One way to achieve this is by setting a different typePrefix setting for each configured connector.`);
    }
    instances.set(instanceName, connectorInstance);
}
// we need to get/set globally so instances can be looked up across different connectors in separate bundles - perhaps even on different SDK versions.
// This is to support cross-reference fields which can create a reference field from one connector to any other connector.
export function getGlobalConnectorInstance(connectorName, instanceID) {
    globalThis.__globalConnectorInstances ||= new Map();
    const instanceName = connectorName + instanceID;
    return globalThis.__globalConnectorInstances.get(instanceName);
}
//# sourceMappingURL=connector-instance.js.map