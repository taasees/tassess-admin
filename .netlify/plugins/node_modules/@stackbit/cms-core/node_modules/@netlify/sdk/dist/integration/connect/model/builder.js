import { writeFileSync } from "fs";
import { join } from "path";
import { ModelDefinition, builtInTypes, mappedBuiltinTypes, } from "./definition.js";
import { ModelError } from "./error.js";
import { localDevWarnOnce } from "./utils.js";
import * as scalar from "./transformers/scalar/index.js";
import { DocumentTransformer } from "./transformers/document.js";
import { ObjectTransformer } from "./transformers/object.js";
import { EnumTransformer } from "./transformers/enum.js";
import { UnionTransformer } from "./transformers/union.js";
import { CrossReferenceTransfromer } from "./transformers/cross-reference.js";
export class ModelBuilder {
    models = new Map();
    extendedModels = new Map();
    scalarModels = new Map();
    transformers = new Map();
    modelDataAPIs;
    complete = false;
    sdl = ``;
    locales = [];
    localeCodes = new Set();
    defaultLocale;
    schemaCustomizations;
    typePrefix = ``;
    nodesApi;
    createApi;
    createId;
    shouldHandleCreateSupport;
    slug;
    supports;
    instanceID;
    // original -> pascal
    pascaledNames = new Map();
    seenTypePaths = new Map();
    shouldAutoRenameFieldsAndModels = true;
    constructor({ nodesApi, createApi, supports, slug, createId, shouldHandleCreateSupport, instanceID, }) {
        this.nodesApi = nodesApi;
        this.createApi = createApi;
        this.supports = supports;
        this.slug = slug;
        this.instanceID = instanceID;
        this.createId = createId;
        this.shouldHandleCreateSupport = shouldHandleCreateSupport;
        this.reset();
    }
    getDefaultLocale() {
        return this?.defaultLocale?.code;
    }
    get runtimePlatform() {
        return this.shouldHandleCreateSupport()
            ? `netlify-create`
            : `netlify-connect`;
    }
    defineAPI({ isInternalType, isExtendedDefinition, }) {
        return {
            /**
             * @warning This API is experimental. Only use if you know what you're doing.
             */
            crossReference: (args) => this.newModelDefinition({
                ...args,
                kind: `CrossReference`,
                isInlineType: true,
                isInternalType,
                TransformerClass: CrossReferenceTransfromer,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             */
            enum: (args) => this.newModelDefinition({
                ...args,
                kind: `Enum`,
                isInternalType,
                TransformerClass: EnumTransformer,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             * Inline enum types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineEnum: (args) => this.newModelDefinition({
                ...args,
                kind: `Enum`,
                isInternalType,
                isInlineType: true,
                TransformerClass: EnumTransformer,
            }),
            /**
             * Defines a document model. Documents are database records that can be queried by their ID. Defining a document model allows you to create and update records of that model type during connector.sync(fn).
             *
             * Replaces the deprecated define.nodeModel() function.
             */
            document: (args) => this.newModelDefinition({
                ...args,
                kind: `Node`,
                isInternalType,
                isExtendedDefinition,
                TransformerClass: DocumentTransformer,
            }),
            /**
             * @deprecated - use define.document() instead, which is a direct replacement for this API
             */
            nodeModel: (args) => {
                localDevWarnOnce(`define.nodeModel`, `define.nodeModel() has been deprecated and renamed to define.document(). They work identically, but the deprecated method will be removed in a future SDK version.`);
                return this.newModelDefinition({
                    ...args,
                    kind: `Node`,
                    isInternalType,
                    TransformerClass: DocumentTransformer,
                });
            },
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: (args) => this.newModelDefinition({
                ...args,
                kind: `Object`,
                isInternalType,
                TransformerClass: ObjectTransformer,
            }),
            /**
             * Defines an inline object type. Object types are used to define fields on node models.
             * Inline object types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineObject: (args) => this.newModelDefinition({
                ...args,
                kind: `Object`,
                isInternalType,
                isInlineType: true,
                TransformerClass: ObjectTransformer,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: (args) => this.newModelDefinition({
                ...args,
                kind: `Union`,
                isInternalType,
                TransformerClass: UnionTransformer,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             * Inline union types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineUnion: (args) => this.newModelDefinition({
                ...args,
                kind: `Union`,
                isInternalType,
                isInlineType: true,
                TransformerClass: UnionTransformer,
            }),
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales) => {
                if (!Array.isArray(locales) || locales.length === 0) {
                    return;
                }
                const defaultLocales = locales.filter((l) => l.default);
                if (defaultLocales.length > 1) {
                    throw new ModelError(`More than one default locale found. Only one default locale is allowed.`);
                }
                if (defaultLocales.length === 0) {
                    // No default locale found, so set the first locale as default
                    locales[0].default = true;
                    this.defaultLocale = locales[0];
                }
                else {
                    this.defaultLocale = defaultLocales[0];
                }
                this.locales = locales;
                for (const locale of this.locales) {
                    this.localeCodes.add(locale.code);
                }
            },
        };
    }
    get pluginAPI() {
        return {
            define: this.defineAPI({ isInternalType: false }),
            extend: {
                Asset: (definition) => {
                    // for now only allow extending the builtin Asset model
                    const extended = this.defineAPI({
                        // not an internal type since the connector dev is adding this extended definition
                        isInternalType: false,
                        isExtendedDefinition: true,
                    }).document({
                        name: `Asset`,
                        fields: definition.fields,
                        visitor: definition.visitor,
                    });
                    return this.models
                        .get(`Asset`)
                        ?._mergeExtendedDefinition(extended, this);
                },
            },
        };
    }
    get defineInternal() {
        return this.defineAPI({ isInternalType: true });
    }
    defineInternalCreateModels() {
        const { create: supportsCreate } = this.supports;
        if (!supportsCreate) {
            return;
        }
        this.defineInternal.enum({
            name: `StatusEnum`,
            values: [`published`, `added`, `modified`],
        });
        this.defineInternal.object({
            name: `Thumbnail`,
            fields: {
                label: {
                    type: `String`,
                    required: true,
                    description: `The label of the thumbnail image in the editor`,
                },
                thumbnail: {
                    type: `url`,
                    required: true,
                    description: `The URL of the thumbnail image`,
                },
                value: {
                    type: `String`,
                    required: true,
                },
            },
        });
        this.defineInternal.document({
            name: `Asset`,
            editor: {
                label: `Asset`,
            },
            fields: {
                title: {
                    type: `String`,
                    required: true,
                },
                url: {
                    type: `String`,
                    required: true,
                },
                fileName: {
                    type: `String`,
                },
                contentType: {
                    type: `String`,
                },
                size: {
                    type: `Int`,
                },
                width: {
                    type: `Int`,
                },
                height: {
                    type: `Int`,
                },
            },
        });
        this.defineInternal.enum({
            name: "ScheduledActionAction",
            values: ["publish", "unpublish"],
        });
        this.defineInternal.enum({
            name: "ScheduledActionState",
            values: ["cancelled", "executing", "failed", "scheduled", "succeeded"],
        });
        this.defineInternal.document({
            name: "ScheduledAction",
            fields: {
                name: {
                    type: "String",
                    required: true,
                },
                action: {
                    type: "ScheduledActionAction",
                    required: true,
                },
                state: {
                    type: "ScheduledActionState",
                    required: true,
                },
                executeAt: {
                    type: "Date",
                    required: true,
                },
                documentIds: {
                    type: "String",
                    required: true,
                    list: true,
                },
            },
        });
    }
    async build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }) {
        this.reset();
        this.typePrefix = typePrefix;
        this.shouldAutoRenameFieldsAndModels =
            typeof shouldAutoRenameFieldsAndModels === `undefined`
                ? true
                : shouldAutoRenameFieldsAndModels;
        this.defineInternalCreateModels();
        this.initializeScalarDefinitions();
        try {
            const { define, extend } = this.pluginAPI;
            await modeler({
                define,
                extend,
                cache,
                state,
                platform,
                options: configurationOptions,
            }, configurationOptions);
        }
        catch (e) {
            console.warn(`Encountered errors while running the connector.model() API:`);
            console.error(e);
            process.exit(1);
        }
        this.validateModelHarmony();
        this.complete = true;
        this.finalizeModels();
        return {
            sdl: this.sdl,
        };
    }
    initializeScalarDefinitions() {
        this.scalarModels.clear();
        const scalars = [
            [`String`, scalar.StringTransformer],
            [`Slug`, scalar.SlugTransformer],
            [`Html`, scalar.HtmlTransformer],
            [`Color`, scalar.ColorTransformer],
            [`Text`, scalar.TextTransformer],
            [`Markdown`, scalar.MarkdownTransformer],
            [`JSON`, scalar.JSONTransformer],
            [`richText`, scalar.RichTextTransformer],
            [`Url`, scalar.UrlTransformer],
            [`Date`, scalar.DateTransformer],
            [`DateTime`, scalar.DateTimeTransformer],
            [`Boolean`, scalar.BooleanTransformer],
            [`Float`, scalar.FloatTransformer],
            [`Int`, scalar.IntegerTranformer],
            [`ID`, scalar.IDTransformer],
        ];
        for (const [name, TransformerClass] of scalars) {
            this.newModelDefinition({
                name,
                kind: `Scalar`,
                TransformerClass,
                isInternalType: true,
            });
        }
    }
    newModelDefinition(input) {
        const { nodesApi, createApi, shouldAutoRenameFieldsAndModels, supports, runtimePlatform, } = this;
        return new ModelDefinition({
            ...input,
            createId: this.createId,
            ModelBuilder: this,
            nodesApi,
            createApi,
            shouldAutoRenameFieldsAndModels,
            supports,
            runtimePlatform,
        });
    }
    getTypeCustomizations(typeName) {
        return this.schemaCustomizations?.typeCustomizations?.[typeName];
    }
    toCreateModels() {
        const createModels = [];
        if (!this.complete) {
            throw new Error(`Cannot generate Create models before ModelBuilder has built its internal models via ModelBuilder.build()`);
        }
        this.models.forEach((model) => {
            const createModel = model.toCreateModel();
            if (createModel)
                createModels.push(createModel);
        });
        if (process.env.NODE_ENV === `development`) {
            // write out stackbit types to a file for debugging
            writeFileSync(join(process.cwd(), `.ntli/netlify-create-types.json`), JSON.stringify(createModels, null, 2));
        }
        return createModels;
    }
    extendModel(model) {
        const typeName = model.getTypeName();
        this.extendedModels.set(typeName, model);
        return this;
    }
    // called by the ModelDefinition constructor for all new models that are created while modelDefiner is running in this.build()
    addModel(model) {
        const typeName = model.getTypeName();
        const existingDefinition = this.models.get(typeName);
        // inline types are allowed to be redefined any number of times - their type name is a hash of their definition
        // so it's impossible for them to conflict with other types
        if (existingDefinition && existingDefinition?.isInlineType) {
            return this;
        }
        if (existingDefinition &&
            existingDefinition.isInternalType &&
            existingDefinition.getTypeName() === `ScheduledAction`) {
            throw new ModelError(`The "ScheduledAction" model is a builtin model and cannot be redefined.`);
        }
        if (existingDefinition &&
            existingDefinition.isInternalType &&
            existingDefinition.getTypeName() === `Asset`) {
            throw new ModelError(`The "Asset" model is a builtin model and cannot be redefined. You can extend it with additional fields using the extend API:
connector.model(({ extend }) => {
  extend.Asset({
    fields: {
      newField: {
        type: "String",
        required: true,
      },
    },
  });
});`);
        }
        else if (existingDefinition && existingDefinition.isInternalType) {
            throw new ModelError(`Model name "${typeName}" is a reserved model name and cannot be redefined. Please choose a different name.`);
        }
        else if (existingDefinition) {
            throw new Error(`Model with name "${typeName}" was defined more than once. Model names must be unique. The first definition was:\n\n${existingDefinition.toSDL()}`);
        }
        // TODO: these are only separate temporarily while ModelTransformers are being added
        // we're adding scalar models first, with transformers, since no recursion is needed for scalar transformers
        // we'll then follow up and make all models use transformers
        if (model.isScalarType) {
            this.scalarModels.set(typeName, model);
        }
        else {
            this.models.set(typeName, model);
        }
        if (model.isNodeType) {
            this.modelDataAPIs[typeName] = model.dataAPI;
            // add keys with original input name, ie if name was product_categories, the
            // model name is ProductCategories, but the connector will likely need to fetch
            // and insert data with the original product_categories name
            if (model.getOriginalName() !== typeName) {
                this.modelDataAPIs[model.getOriginalName()] = model.dataAPI;
            }
        }
        return this;
    }
    reset() {
        this.locales = [];
        this.pascaledNames = new Map();
        this.models = new Map();
        this.extendedModels = new Map();
        this.seenTypePaths = new Map();
        this.modelDataAPIs = {
            async concurrent(count, modelCallback) {
                if (typeof count !== `number`) {
                    throw new ModelError(`models.concurrent(arg1) must be a number`);
                }
                if (count < 1) {
                    throw new ModelError(`models.concurrent(arg1) must be a positive number`);
                }
                if (Math.round(count) !== count) {
                    throw new ModelError(`models.concurrent(arg1) must be a whole number`);
                }
                const models = Array.from(this);
                const slots = Array(count).fill(null);
                function runNextModelInSlot() {
                    const model = models.pop();
                    if (!model)
                        return;
                    const mbePromise = modelCallback(model);
                    if (mbePromise && `then` in mbePromise) {
                        return mbePromise.then(runNextModelInSlot);
                    }
                    else {
                        return runNextModelInSlot();
                    }
                }
                await Promise.all(slots.map(runNextModelInSlot));
            },
        };
        Object.defineProperty(this.modelDataAPIs, Symbol.iterator, {
            value: function* () {
                for (const [name, model] of Object.entries(this)) {
                    if (typeof model === "function")
                        continue; // skip the iterator
                    if (`concurrent` === name)
                        continue; // skip non-model methods
                    if (name === model?.originalName && model.name !== model.originalName)
                        continue; // skip any original name models, these are duplicates added by original name for convinience
                    yield model;
                }
            },
            enumerable: false,
        });
        this.complete = false;
        this.sdl = ``;
    }
    finalizeModels() {
        this.sdl = ``;
        this.models.forEach((model) => {
            model.buildWalker();
            this.sdl += `${model.toSDL()}\n\n`;
        });
        this.scalarModels.forEach((model) => {
            // don't add sdl definitions for visual editor types (like slug/html/text) if the connector doesn't support create
            if (!this.supports.create && model.ModelTransformer.isVisualEditorType) {
                return;
            }
            const sdl = model.toSDL();
            if (sdl) {
                this.sdl += `${sdl}\n\n`;
            }
        });
        this.sdl = this.sdl.trim();
    }
    // used to track which types have been referenced by other types so we can throw errors (with helpful paths) for undefined types after building models
    setSeenTypePaths() {
        this.models.forEach((model) => {
            const modelTypeName = model.getTypeName();
            if (!this.seenTypePaths.has(modelTypeName)) {
                this.seenTypePaths.set(modelTypeName, [modelTypeName]);
            }
            for (const compositeType of model?.compositeTypes || []) {
                const compositeTypename = model.getDefinedTypeName(compositeType);
                if (!this.seenTypePaths.has(compositeTypename)) {
                    this.seenTypePaths.set(compositeTypename, []);
                }
                this.seenTypePaths.get(compositeTypename).push(`union ${modelTypeName} = ${compositeTypename} | ...`);
            }
            for (const fieldDefinition of model.getFields()) {
                const fieldName = fieldDefinition.name;
                const typeName = model.getDefinedTypeName(fieldDefinition.type, fieldName);
                if (!this.seenTypePaths.has(typeName)) {
                    this.seenTypePaths.set(typeName, []);
                }
                // store a backreference to this type. IE if the field is One.fieldA and fieldA has type Two, then
                // Two => ['One.fieldA', 'OtherType.fieldSomething'] is stored where we keep a list of every place that references this type
                this.seenTypePaths.get(typeName).push(`${modelTypeName}.${fieldName}`);
            }
        });
    }
    validateModelHarmony() {
        this.renamePascaledFieldTypes();
        this.setSeenTypePaths();
        this.panicOnUndefinedModels();
        this.handleMixedUnionTypes();
        this.throwOnLocalizedFieldsWhenNoLocalesAreDefined();
        this.throwOnMixedUnionListFields();
        this.throwOnInlineUnionMemberTypes();
    }
    // "inline" types are types where the typename is a hash of the type definition.
    // these types shouldn't be used in unions because the __typename can't be set when inserting documents, and the query isn't predictable when querying (... on InlineObject_432j32kl) as the hash may change - which will then require all client queries to be updated to continue working
    throwOnInlineUnionMemberTypes() {
        for (const model of this.models.values()) {
            if (!model.isUnionType)
                continue;
            for (const type of model?.compositeTypes || []) {
                const typeName = model.getDefinedTypeName(type);
                if (this.models.get(typeName)?.isInlineType) {
                    throw new ModelError(`Inline types cannot be used in unions. The type "${typeName}" is an inline type and is used in a union in "${model.getTypeName()}"`);
                }
            }
        }
    }
    throwOnMixedUnionListFields() {
        // this limitation only applies if the connector supports Netlify Create
        if (!this.supports.create)
            return;
        for (const [, model] of this.models) {
            for (const [, field] of model.fieldsMap) {
                const fieldModel = this.models.get(model.getDefinedTypeName(field.type));
                if (!fieldModel)
                    continue;
                if (fieldModel.isMixedUnion && !field.list) {
                    throw new ModelError(`Mixed unions (documents and objects) are only supported when they're used in list fields. A non-list field with a mixed union type exists as "${model.getTypeName()}.${field.name}"`);
                }
            }
        }
    }
    renamePascaledFieldTypes() {
        if (!this.pascaledNames.size) {
            return;
        }
        for (const model of this.models.values()) {
            // pascal union/interface type references
            if (model.compositeTypes) {
                let index = -1;
                for (const type of model.compositeTypes) {
                    index++;
                    // Definition objects don't need to be renamed here, only rename strings
                    if (typeof type !== `string`)
                        continue;
                    const pascaled = this.pascaledNames.get(type);
                    if (pascaled) {
                        model.compositeTypes[index] = pascaled;
                        model.compositeTypesSet.delete(type);
                        model.compositeTypesSet.add(pascaled);
                    }
                }
            }
            for (const def of Object.values(model.fields)) {
                const pascaled = this.pascaledNames.get(model.getDefinedTypeName(def.type));
                if (pascaled) {
                    def.type = pascaled;
                }
            }
        }
    }
    throwOnLocalizedFieldsWhenNoLocalesAreDefined() {
        if (this.locales.length > 0)
            return;
        for (const model of this.models.values()) {
            for (const field of model.getFields()) {
                if (field.localized) {
                    throw new ModelError(`Field ${model.getTypeName()}.${field.name}.localized is set to true, but this connector has not defined any locales. Fields cannot be localized unless locales are defined.

Example:

connector.model(({ define }) => {
  define.locales([
    { code: "en-US", default: true },
    { code: "ca-FR" }
  ])
})`);
                }
            }
        }
    }
    handleMixedUnionTypes() {
        for (const model of this.models.values()) {
            if (model.isUnionType && model.compositeTypes) {
                const foundTypes = {
                    node: [],
                    object: [],
                    union: [],
                    scalar: [],
                };
                for (const type of model.compositeTypes) {
                    const typename = model.getDefinedTypeName(type);
                    if (builtInTypes.has(typename)) {
                        foundTypes.scalar.push(typename);
                        continue;
                    }
                    const fullType = this.models.get(typename);
                    if (!fullType)
                        continue;
                    if (fullType.isObjectType)
                        foundTypes.object.push(typename);
                    if (fullType.isNodeType)
                        foundTypes.node.push(typename);
                    if (fullType.isUnionType)
                        foundTypes.union.push(typename);
                }
                if (foundTypes.object.length && foundTypes.scalar.length) {
                    throw new ModelError(`Object and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.object,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                if (foundTypes.node.length && foundTypes.scalar.length) {
                    throw new ModelError(`Node and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.node,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                const isMixedUnion = foundTypes.node.length && foundTypes.object.length;
                if (isMixedUnion) {
                    model.setIsMixedUnion();
                }
                if (foundTypes.node.length) {
                    model.setIsNodeUnion();
                }
            }
        }
    }
    panicOnUndefinedModels() {
        const undefinedModelErrors = new Map();
        for (const [seenTypeName, sdlPaths] of this.seenTypePaths.entries()) {
            if (!this.models.has(seenTypeName) &&
                !builtInTypes.has(seenTypeName) &&
                !mappedBuiltinTypes.has(seenTypeName)) {
                if (!undefinedModelErrors.has(seenTypeName)) {
                    undefinedModelErrors.set(seenTypeName, new Set());
                }
                for (const sdlPath of sdlPaths) {
                    undefinedModelErrors.get(seenTypeName).add(sdlPath);
                }
            }
        }
        if (undefinedModelErrors.size > 0) {
            const errorMessages = Array.from(undefinedModelErrors.entries()).map(([typeName, sdlPaths]) => {
                return `Undefined type "${typeName}", referenced on type fields:\n\n${Array.from(sdlPaths.keys())
                    .map((sdlPath) => {
                    return ` - ${sdlPath}`;
                })
                    .join(`\n`)}\n`;
            });
            errorMessages.forEach((message) => {
                console.error(message);
            });
            if (undefinedModelErrors.size > 1) {
                console.error(`There were ${undefinedModelErrors.size} referenced type names which haven't been defined. Either your plugin has a typo or there are types which haven't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            else {
                console.error(`There was 1 referenced type name which hasn't been defined. Either your plugin has a typo or there is a type which hasn't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            setTimeout(() => {
                // leave a little time for large errors to print
                process.exit(1);
            }, 100);
        }
    }
}
//# sourceMappingURL=builder.js.map