import { resolve, parse } from "path";
import { execSync } from "child_process";
import chalk from "chalk";
import pkg from "fs-extra";
import { outdent as javascript } from "outdent";
import { build, context, build as esbuild, } from "esbuild";
import { getPackageVersion } from "../integration/ui/utils/package-version.js";
import { handler } from "../constants/handler.js";
import { getDefaultEsbuildConfig } from "./commands/build.js";
const { ensureFile, ensureDir, copySync, copyFile, copyFileSync, writeFile, writeJSON, readdirSync, existsSync, readJSON, stat, } = pkg;
export { buildExtensionUI, } from "./build/build_extension_ui.js";
export { generateConnectPlugin, createDevelopmentContentEngine, } from "../integration/connect/cli.js";
export const generateBuildEventHandler = async (integration, config, opts) => {
    if (Object.values(integration.buildHooks).every((value) => !value)) {
        console.log(chalk.white("No build event handlers found."));
        return;
    }
    const { outDir, cwd } = opts;
    const integrationPackageJson = await readJSON(resolve(cwd, "package.json"));
    const { dependencies } = integrationPackageJson;
    await ensureDir(resolve(outDir, "build"));
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [resolve(outDir, "index.js")],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: resolve(outDir, "build/integration.js"),
    };
    await esbuild(esbuildOptions);
    let exportedPluginCode = javascript `
    import { integration } from './integration.js';
    integration._slug = '${config.slug}';\n
  `;
    exportedPluginCode += javascript `
    export default function netlifyIntegration(_inputs, { netlifyConfig }) {
      return integration.getBuildEventHandlersToRun({ netlifyConfig });
    };`;
    // generate random 5 character string
    const randomString = Math.random().toString(36).substring(2, 7);
    const version = `0.0.0-${randomString}`;
    const name = `${config.slug}-buildhooks`;
    const sdkVersion = getPackageVersion();
    // build any internal functions
    await buildInternalFunctions({
        config,
        integration,
        outDir,
        type: "function",
    });
    // build any internal edge functions
    await buildInternalFunctions({ config, integration, outDir, type: "edge" });
    if (existsSync(resolve(cwd, "assets"))) {
        copySync(resolve(cwd, "assets"), resolve(outDir, "build/assets"));
    }
    await writeFile(resolve(outDir, "build/index.js"), exportedPluginCode);
    await writeJSON(resolve(outDir, "build/package.json"), {
        main: "index.js",
        type: "module",
        version,
        name,
        dependencies: { ...dependencies, "@netlify/sdk": sdkVersion },
    });
    await writeFile(resolve(outDir, "build/manifest.yml"), `name: ${name}`);
    execSync(`npm pack`, {
        cwd: resolve(outDir, "build"),
    });
    const packedFile = `${name
        .replaceAll("@", "")
        .replaceAll("/", "-")}-${version}.tgz`;
    await ensureDir(resolve(outDir, "site/static/packages"));
    copyFileSync(resolve(outDir, `build/${packedFile}`), resolve(outDir, "site/static/packages", "buildhooks.tgz"));
};
export const createIntegrationUIFiles = async (surfaceScriptUrl, outDir, slug) => {
    // You're probably thinking, "Why are you using a the date as a query param?"
    // Well, it's because we want to bust the cache each time the rebuild happens.
    // It turns out functions that run on the ESBuild plugins import the file once
    // and then cache it. So, we need to bust the cache each time we rebuild.
    const now = Date.now();
    const uiModule = await import(`${outDir}/site/static/ui/integration-ui.js?${now}`);
    const { config, script } = uiModule.integrationUI.generateUIConfig(surfaceScriptUrl);
    config.integrationSlug = slug;
    console.log(chalk.white("Generating UI surfaces"));
    await ensureDir(resolve(outDir, "site/static/ui"));
    await writeFile(resolve(outDir, "site/static/ui/integration-ui.json"), JSON.stringify(config));
    if (script) {
        const builtPath = resolve(outDir, "site/static/ui/integration-ui.js");
        await ensureFile(builtPath);
        await writeFile(builtPath, script, { flag: "a" });
    }
};
export const buildIntegrationUI = async ({ outDir, mainPath, surfaceScriptUrl, watch, id, }) => {
    let integrationUIFilePath;
    if (existsSync(resolve(mainPath, "../ui/index.ts"))) {
        integrationUIFilePath = resolve(mainPath, "../ui/index.ts");
    }
    else if (existsSync(resolve(mainPath, "../ui/index.js"))) {
        integrationUIFilePath = resolve(mainPath, "../ui/index.js");
    }
    else {
        console.log(chalk.white("No integration UI found"));
        return;
    }
    if (integrationUIFilePath) {
        console.log(chalk.white("Building integration UI..."));
        const buildOptions = {
            entryPoints: [integrationUIFilePath],
            bundle: true,
            format: "esm",
            outfile: `${outDir}/site/static/ui/integration-ui.js`,
            platform: "node",
            keepNames: true,
            minify: true,
        };
        if (watch) {
            try {
                const buildContext = await context({
                    ...buildOptions,
                    plugins: [
                        {
                            name: "rebuild-listener",
                            setup(build) {
                                let shouldNotifyRebuildListeners = false;
                                // sometimes esbuild immediately rebuilds twice on start,
                                setTimeout(() => 
                                // so only notify listeners if it's been more than 100ms since the build started
                                (shouldNotifyRebuildListeners = true), 100);
                                let notifying = false;
                                build.onEnd(async () => {
                                    if (notifying) {
                                        return;
                                    }
                                    notifying = true;
                                    if (shouldNotifyRebuildListeners) {
                                        await createIntegrationUIFiles(surfaceScriptUrl, outDir, id);
                                        console.log(chalk.green("Integration UI rebuilt"));
                                    }
                                    notifying = false;
                                });
                            },
                        },
                    ],
                });
                await buildContext.watch();
                await buildContext.rebuild();
            }
            catch (e) {
                console.log(chalk.red("Could not build integration UI"));
                console.log(e);
                throw e;
            }
        }
        else {
            try {
                await build(buildOptions);
            }
            catch (e) {
                console.log(chalk.red("Could not build integration UI"));
                console.log(e);
                throw e;
            }
        }
        await createIntegrationUIFiles(surfaceScriptUrl, outDir, id);
    }
};
export const processHandlers = async (opts, config) => {
    const { outDir } = opts;
    const handlerDir = resolve(outDir, "site/netlify/functions");
    await ensureDir(handlerDir);
    await ensureDir(resolve(outDir, "site/netlify/integration"));
    await copyFile(resolve(outDir, "index.js"), resolve(outDir, "site/netlify/integration/index.js"));
    const handlerCode = handler("../integration", config);
    await writeFile(resolve(handlerDir, "handler.js"), handlerCode);
};
export const processWrappers = async (wrappers, opts) => {
    if (!Object.keys(wrappers).length)
        return;
    const { outDir } = opts;
    console.log(chalk.white("Generating wrapper functions..."));
    const wrapperFile = resolve(outDir, "wrappers/index.js");
    await ensureFile(wrapperFile);
    await copyFile(resolve(outDir, "index.js"), resolve(outDir, "wrappers/integration.js"));
    let wrapperCode = javascript `import { integration } from './integration.js';\n\n`;
    Object.entries(wrappers).map(async ([key]) => {
        wrapperCode += javascript `export const ${key} = integration.wrappers['${key}'];\n`;
    });
    await writeFile(wrapperFile, wrapperCode);
};
const bundleEdgeFunction = (config) => async (srcPath, outPath) => {
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [srcPath],
        bundle: true,
        format: "esm",
        platform: "browser",
        outfile: outPath,
        plugins: [
            {
                name: "dependency-check",
                setup(build) {
                    build.onResolve({ filter: /.*/ }, (args) => {
                        // Check if the path is not a URL and not a relative path
                        if (!args.path.startsWith("http://") &&
                            !args.path.startsWith("https://") &&
                            !args.path.startsWith(".") &&
                            !args.path.startsWith("/")) {
                            throw new Error(`Invalid dependency found: ${args.path}. Edge Functions injected through integrations can only import local files, deno modules and npm modules with URL imports.`);
                        }
                        return null;
                    });
                },
            },
        ],
    };
    await esbuild(esbuildOptions);
};
const copyFunctionDirectory = async (source, target, bundleFunction) => {
    await ensureDir(target);
    const items = readdirSync(source, { withFileTypes: true });
    items.forEach(async (item) => {
        const srcPath = resolve(source, item.name);
        const targetPath = resolve(target, item.name);
        if (item.isDirectory()) {
            await copyFunctionDirectory(srcPath, targetPath, bundleFunction);
        }
        else {
            await bundleFunction(srcPath, targetPath);
        }
    });
};
const buildInternalFunctions = async ({ integration, outDir, type, config, }) => {
    const settings = type === "function"
        ? integration._functionsSettings
        : integration._edgeFunctionsSettings;
    if (settings) {
        const { path: internalFunctionsPath, prefix: internalFunctionsPrefix } = settings;
        if (internalFunctionsPath && internalFunctionsPrefix) {
            await ensureDir(internalFunctionsPath);
            const internalFunctions = await pkg.readdir(internalFunctionsPath);
            if (!internalFunctions || internalFunctions.length === 0) {
                throw new Error(`No internal ${type === "edge" ? "edge functions" : "functions"} found.`);
            }
            for (const fn of internalFunctions || []) {
                const newFilePath = resolve(outDir, type === "function" ? "build/functions" : "build/edge-functions", `${internalFunctionsPrefix}_${parse(fn).base}`);
                const oldFilePath = resolve(internalFunctionsPath, fn);
                try {
                    const stats = await stat(oldFilePath);
                    if (stats.isFile()) {
                        await ensureFile(newFilePath);
                        await bundleFunction(config)(oldFilePath, newFilePath);
                    }
                    else if (stats.isDirectory()) {
                        await copyFunctionDirectory(oldFilePath, newFilePath, type === "function"
                            ? bundleFunction(config)
                            : bundleEdgeFunction(config));
                    }
                }
                catch (err) {
                    console.error(err);
                }
            }
        }
    }
};
const bundleFunction = (config) => async (srcPath, outPath) => {
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [srcPath],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: outPath,
    };
    await esbuild(esbuildOptions);
};
//# sourceMappingURL=index.js.map