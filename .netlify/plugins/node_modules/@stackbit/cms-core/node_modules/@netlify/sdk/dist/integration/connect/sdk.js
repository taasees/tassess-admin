import zodLib from "zod";
import { register } from "zod-metadata";
register(zodLib);
import { ConnectorOptionsSchema, } from "./utils/options.js";
import { ModelError } from "./model/error.js";
import { makeInstanceID } from "./utils/instance-id.js";
import { ConfiguredNetlifyConnector, getGlobalConnectorInstance, setGlobalConnectorInstance, } from "./connector-instance.js";
import { localDevWarnOnce } from "./model/utils.js";
export class NetlifyConnector {
    config;
    started = false; // true if the first event loop tick has occurred. Plugin APIs cannot be dynamically assigned after this as the "exports" should be static. so this value is checked before assigning plugin APIs. It must be false to assign plugin APIs.
    definedImplementations = Object.create(null);
    isUsingUnifiedAPI = false;
    optionsSchema;
    proxiedSchemas = [];
    supports = {
        create: false,
        deltaSync: true,
    };
    constructor(config) {
        this.config = {
            ...config,
            localDevOptions: config.localDevOptions ?? {},
            supports: config.supports ?? {},
        };
        this.supports = {
            ...this.supports,
            ...config.supports,
        };
        this.optionsSchema = new ConnectorOptionsSchema(({ zod }) => zod.object({}));
        setImmediate(() => {
            // plugins may only add APIs on the first event loop tick.
            // exported APIs are static and cannot be dynamically assigned.
            this.started = true;
            if (!this.definedImplementations.model) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
            }
            if ((this.definedImplementations["event.updateNodes"] ||
                this.definedImplementations["event.createAllNodes"]) &&
                this.definedImplementations.sync) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`connector.event() and connector.documents() cannot both be used. If you're trying the new connector.documents() API, you must remove all calls to connector.event(). connector.sync(implementation) has replaced all connector.event() calls.`);
            }
            if (!this.definedImplementations.sync &&
                !this.definedImplementations["event.createAllNodes"]) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                if (this.supports.create) {
                    throw new Error(`No connector.sync(fn) implementation was defined. This API is required for all connectors.`);
                }
            }
        });
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     * @deprecated Prefer specifying this via `NetlifyIntegration#addConnector({ initState, <...> })`
     */
    init = (init) => {
        this.checkCanDefine(`init`);
        this.definedImplementations.init = init;
    };
    // TODO: defineOptions will be deprecated once the SDK has a way to specify configuration schemas:
    /**
     * `defineOptions` accepts a function that Defines the user configuration options for your `NetlifyConnector`.
     */
    defineOptions = (definer) => {
        this.checkCanDefine(`defineOptions`);
        this.optionsSchema = new ConnectorOptionsSchema(definer);
    };
    getOptionsSchema() {
        return this.optionsSchema.buildSchema();
    }
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler) {
        this.checkCanDefine(`model`);
        if (this.definedImplementations.model) {
            throw new ModelError(`connector.model() may only be called one time, but has been called more than once.`);
        }
        this.definedImplementations.model = modeler;
    }
    sync(sync) {
        this.checkCanDefine(`sync`);
        if (this.definedImplementations.sync) {
            throw new ModelError(`connector.sync() may only be called one time, but has been called more than once.`);
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations.sync = sync;
    }
    hasAccess(userFn) {
        this.checkCanDefine(`hasAccess`);
        this.definedImplementations.hasAccess = userFn;
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    assets(args) {
        this.checkCanDefine(`assets`);
        if (this.definedImplementations["assets.upload"]) {
            throw new ModelError(`connector.assets() may only be called one time, but has been called more than once.`);
        }
        this.isUsingUnifiedAPI = true;
        const { create } = args;
        if (!create) {
            throw new ModelError(`connector.assets({ create }) must be called with a 'create' implementation.`);
        }
        this.definedImplementations[`assets.upload`] = create;
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    documents(args) {
        this.checkCanDefine(`documents`);
        for (const apiName of [
            `documents.update`,
            `documents.create`,
            `documents.delete`,
            `documents.publish`,
        ]) {
            if (this.definedImplementations[apiName]) {
                throw new ModelError(`connector.documents() may only be called one time, but it's been called more than once.`);
            }
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations["documents.update"] = args.update;
        this.definedImplementations["documents.create"] = args.create;
        this.definedImplementations["documents.delete"] = args.delete;
        this.definedImplementations["documents.publish"] = args.publish;
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    scheduledActions(methods) {
        this.checkCanDefine("scheduledActions");
        for (const apiName of [
            "scheduledActions.update",
            "scheduledActions.create",
            "scheduledActions.delete",
        ]) {
            if (this.definedImplementations[apiName]) {
                throw new ModelError("connector.scheduledActions() may only be called one time, but it's been called more than once.");
            }
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations["scheduledActions.create"] = methods.create;
        this.definedImplementations["scheduledActions.delete"] = methods.delete;
        this.definedImplementations["scheduledActions.update"] = methods.update;
    }
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     *
     * @deprecated This API has been replaced with connector.sync(({ isInitialSync }) => {})
     */
    event(name, implementation) {
        if (this.definedImplementations[`event.${name}`]) {
            throw new ModelError(`connector.event('${name}', implementation) was already defined. You may only define each event once.`);
        }
        localDevWarnOnce(`connector.event.${name}`, `connector.event("${name}", fn) has been deprecated and replaced with connector.sync(({ isInitialSync }) => {}). Combine your createAllNodes and updateNodes implementations into a single connector.sync(implementation) to make it easier to upgrade in the next SDK major version release.`);
        this.definedImplementations[`event.${name}`] = implementation;
    }
    checkCanDefine(apiName) {
        if (this.started) {
            throw new Error(`Cannot call ${apiName} after the first event loop tick.\n\nPlease call connector().${apiName}() synchronously in your plugin's main module. Plugin implementations cannot be dynamically assigned.`);
        }
    }
    proxySchema(fn) {
        this.proxiedSchemas.push(fn);
    }
    // Multiple instances of the same connector may need to exist within the same process, so create and store instances by a unique hashed ID
    getConnectorInstance(options, connectorName) {
        const instanceID = options.instanceID ?? makeInstanceID(options);
        const existingConnector = getGlobalConnectorInstance(connectorName, instanceID);
        if (existingConnector) {
            return existingConnector;
        }
        const connectorInstance = new ConfiguredNetlifyConnector({
            slug: connectorName,
            options,
            instanceID,
            NetlifyConnector: this,
            config: this.config,
        });
        setGlobalConnectorInstance(connectorName, instanceID, connectorInstance);
        return connectorInstance;
    }
}
//# sourceMappingURL=sdk.js.map