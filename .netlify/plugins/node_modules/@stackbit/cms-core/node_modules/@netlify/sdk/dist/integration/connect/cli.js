import { resolve, join } from "path";
import { execSync } from "child_process";
import * as url from "url";
import { contentEngine, } from "@netlify/content-engine";
import { outdent as javascript } from "outdent";
import fsExtra from "fs-extra";
import chalk from "chalk";
import { removeBundledDepsFromPackageJsonContents, } from "../../cli/util.js";
const { pathExistsSync, readFileSync, writeFile, writeJSON, copyFile, copy, ensureDir, existsSync, } = fsExtra;
/**
 * Adds the absolute path of the bundled plugin package.json to the engine config
 * when the engine is started this allows it to use the bundled local plugin.
 */
function getEngineConfigWithBundledPlugin({ cwd, integration, }) {
    const connectorConfig = integration?.netlifyConnectPlugin?.config || {};
    if (`developmentConfig` in connectorConfig) {
        throw new Error(`developmentConfig has been replaced with localDevOptions. The old config took a list of plugins while the new one takes an object of options for your connector to be used during connector development.`);
    }
    if (`devConfigOptions` in connectorConfig) {
        throw new Error(`devConfigOptions has been renamed to localDevOptions. The functionality has not changed, only the name has.`);
    }
    // specifying the path to a package.json file in the plugins array will cause the plugin to be loaded from that path
    const localPluginPackageJSONPath = resolve(cwd, `.ntli/connector`, `package.json`);
    const localDevOptions = integration?.netlifyConnectPlugin?.config?.localDevOptions;
    const engineConfig = {
        // allow testing running more than one plugin instance at a time
        plugins: Array.isArray(localDevOptions)
            ? localDevOptions.map((options) => {
                return {
                    resolve: localPluginPackageJSONPath,
                    options: options || {},
                };
            })
            : [
                {
                    resolve: localPluginPackageJSONPath,
                    options: localDevOptions || {},
                },
            ],
    };
    return engineConfig;
}
export async function createDevelopmentContentEngine({ integration, cwd, engineOptions, }) {
    const engineConfig = getEngineConfigWithBundledPlugin({
        integration,
        cwd: cwd,
    });
    const hooksPath = join(cwd, `/.ntli/connector/content-engine-hooks.cjs`);
    const useHooks = integration.netlifyConnectPlugin?.supports?.create && existsSync(hooksPath);
    engineOptions = {
        engineConfig: { ...engineConfig, ...(engineOptions?.engineConfig || {}) }, // this configures plugin settings for the engine. developers that use the SDK specify these when calling integration.addConnector({ localDevOptions: { ... } })
        frameworkHooks: useHooks ? hooksPath : undefined,
        printLogs: false,
        ...(engineOptions || {}),
    };
    if (process.env.LOG_LEVEL) {
        engineOptions.env = {
            LOG_LEVEL: process.env.LOG_LEVEL,
        };
    }
    engineOptions.env ||= {};
    if (process.env.CONTENT_ENGINE_ENV) {
        const parsedOptions = process.env.CONTENT_ENGINE_ENV.split(`,`);
        for (const pair of parsedOptions) {
            const [key, value] = pair.split(`:`);
            engineOptions.env[key] = value;
        }
    }
    // Set the SDK_ENV because the connector's constructor method
    // needs context of what platform it is running on.
    // NODE_ENV isn't used because the connector could be running
    // in a development environment that's not the `netlify-integration` CLI (e.g: Stackbit dev)
    engineOptions.env = {
        ...(engineOptions.env || {}),
        SDK_ENV: `development`,
    };
    const engine = contentEngine(engineOptions);
    engine.onStdOut((data) => {
        const message = data.toString();
        // don't filter logs when a log level is set
        if (typeof process.env.LOG_LEVEL !== `undefined`) {
            process.stdout.write(message);
            return;
        }
        // temporary log filtering until we add flags to Stackbit/content-engine to turn off certain logs
        for (const logPart of [
            // content-engine
            `Loading plugins - `,
            `Fetching API Data - `,
            `Creating GraphQL schemas - `,
            `[content-engine] starting "`,
            `building schema - `,
            `update integration data - `,
            `[content-engine] initializing`,
            `[content-engine] sync started`,
            `[content-store] Update document`,
            `[content-engine] stopping subprocess`,
            `Clean up stale nodes`,
            ` is ready:`,
            `http://localhost:${chalk.bold(`8000`)}/__graphql`,
            // stackbit dev
            `Open ${chalk.bold(`http://localhost:8090/_stackbit`)} in your browser`,
            "reloading stackbit config from: stackbit.config.js",
            `Server started. Forwarding requests to:`,
            `Content sources found: `,
            `Loaded content source data: `,
            `Site directory: `,
            `Initializing content source: `,
            `Using Content Source Interface`,
            `[content-store] Update document`,
            `[content-store] reset content source`,
        ]) {
            if (message.includes(logPart))
                return;
        }
        process.stdout.write(message);
    });
    engine.onStdErr((data) => {
        const message = data.toString();
        if (message.includes(`has generated no Gatsby nodes. Do you need it?`))
            return;
        process.stderr.write(data);
    });
    return { engine };
}
export const generateConnectPlugin = async (integrationWorker, config, opts) => {
    const { outDir, watchMode } = opts;
    const connectorDir = resolve(outDir, `connector`);
    if (!(await integrationWorker.hasConnector())) {
        console.log(chalk.white("No Netlify Connect plugin API's found."));
        return;
    }
    const packageJSONContents = await fsExtra.readJSON(resolve(opts.cwd, `package.json`));
    // there should be no bundled dependencies in the plugin package.json
    // because they're in the bundle already.
    const normalizedPackageJSON = removeBundledDepsFromPackageJsonContents(packageJSONContents);
    // a .ts "main" will cause content-engine and gatsby to error.
    delete normalizedPackageJSON.main;
    if (!watchMode) {
        const sdkPackageJSON = await fsExtra.readJSON(
        // use fs because adding json imports to tsconfig and importing package.json breaks /dist because package.json is outside /src
        new URL(`../../../package.json`, import.meta.url));
        // if this isn't an sdk prerelease version
        // for ex not: v1.45.9-pr-1234
        if (!sdkPackageJSON.version.includes(`-pr-`)) {
            // prevent the bundled connector from using a different installed version of the SDK
            delete normalizedPackageJSON?.dependencies?.["@netlify/sdk"];
            delete normalizedPackageJSON?.devDependencies?.["@netlify/sdk"];
            normalizedPackageJSON.dependencies ||= {};
            normalizedPackageJSON.dependencies["@netlify/sdk"] =
                // only allow patch versions of the current sdk version that we're building with
                `~${sdkPackageJSON.version}`; // this allows for security updates and bug fixes, but not new features - this means we don't need to treat our internal API as a breaking external API - in production, connectors will always use the same feature version of the SDK they were bundled with
        }
    }
    let version;
    if (watchMode) {
        // changing the version in watch mode every time will cause the cache to be wiped out on every code save. Can't do that! If there's no version in package.json then allow it to be undefined.
        version = normalizedPackageJSON.version;
    }
    else {
        // if it's not watch mode then it's build mode, prefer the package.json version and fall back to the generated version if it's not there. A version is needed for the package to be published. Using Date.now() will mean each new release is numerically sortable as later than the last release.
        const randomString = Math.random().toString(36).substring(2, 7);
        version = `0.0.0-${randomString}`;
    }
    const name = `${config.slug}-connector`;
    await ensureDir(connectorDir);
    await copyFile(resolve(outDir, "index.js"), resolve(connectorDir, "index.js"));
    const sourceMapJSON = await fsExtra.readJSON(resolve(outDir, "index.js.map"));
    sourceMapJSON.sources = sourceMapJSON.sources.map((source) => join(`../`, source));
    await writeJSON(resolve(connectorDir, `index.js.map`), sourceMapJSON);
    await writeJSON(resolve(connectorDir, `package.json`), {
        ...normalizedPackageJSON,
        name,
        version,
    }, {
        spaces: 2,
    });
    const assetsSrcDir = resolve(outDir, `assets`);
    if (pathExistsSync(assetsSrcDir)) {
        console.info(`Copying assets directory to built connector`);
        const assetsConnectorDir = resolve(connectorDir, `assets`);
        await copy(assetsSrcDir, assetsConnectorDir);
    }
    const templateDir = join(url.fileURLToPath(new URL(".", import.meta.url)), `templates/`);
    const rand = Math.random();
    const templateData = {
        // In watch mode stackbit bundles our template file and puts it in a nested subdir (.stackbit/something) because we're simulating a stackbit site inside .ntli to inject our CSI module automatically without the integration dev creating a stackbit.config.js file. So we need ../../
        // In production this isn't the case and the template file isn't rebundled by stackbit, so the import is relative to the integration bundle: ./
        integrationImportPath: `${watchMode ? "../../" : "./"}${rand.toString()}-index.js`,
        configSlug: name,
        addContentEngineConfig: !watchMode,
    };
    await copyFile(join(templateDir, `netlify-connect.template.d.ts`), resolve(connectorDir, `gatsby-node.d.ts`));
    const connectTemplateFile = readFileSync(join(templateDir, `netlify-connect.template.js`), `utf8`);
    await writeFile(join(connectorDir, `gatsby-node.js`), replaceTemplateDataString(connectTemplateFile, templateData));
    await integrationWorker.writeConnectorOptionsSchema();
    const connectorConfig = await integrationWorker.getConnectorConfig();
    const supportsCreate = connectorConfig.supports?.create;
    if (watchMode && supportsCreate) {
        await writeStackbitDevFiles({
            connectorDir,
            integrationConfig: config,
            connectorConfig,
        });
    }
    if (supportsCreate) {
        await writeFile(resolve(connectorDir, `${rand}-index.js`), javascript `
        // the only purpose of this file is to prevent stackbit/esbuild from bundling ./index.js.
        // Since the name of this file is completely random, it can't statically determine
        // how to bundle it :)
        export * from "./index.js"
`);
        await copyFile(join(templateDir, `netlify-create.template.d.ts`), resolve(connectorDir, `netlify-create.d.ts`));
        const templateFile = readFileSync(join(templateDir, `./netlify-create.template.js`), {
            encoding: `utf8`,
        });
        let csiFileContents = replaceTemplateDataString(templateFile, templateData);
        if (!watchMode) {
            // we need to warm the import cache in production so that we don't get a dynamic import race condition
            // this is hacky, but makes it work until we don't need a Create bridge template file anymore
            csiFileContents = `import "${templateData.integrationImportPath}"\n${csiFileContents}`;
        }
        await writeFile(resolve(connectorDir, `netlify-create.js`), csiFileContents);
    }
    if (!watchMode && process.env.SDK_SKIP_PACKING !== `true`) {
        execSync(`npm pack`, {
            cwd: connectorDir,
        });
        const packedFile = `${name
            .replaceAll("@", "")
            .replaceAll("/", "-")}-${version}.tgz`;
        await ensureDir(resolve(outDir, "site/static/packages"));
        await copyFile(resolve(outDir, `connector/${packedFile}`), resolve(outDir, "site/static/packages", "connector.tgz"));
    }
};
function replaceTemplateDataString(templateString, templateData) {
    const templateLines = templateString.split(`\n`);
    const replaceAt = templateLines.findIndex((l) => l.startsWith(`const templateData = global`)) + 1;
    return javascript `
        const templateData = ${JSON.stringify(templateData, null, 2)}

        ${templateLines.slice(replaceAt).join("\n")}
    `;
}
export function getConnectorLocalFrontendConfig(integrationConfig) {
    const localFrontendConfig = integrationConfig?.connector?.["local-frontend"];
    return localFrontendConfig || false;
}
export async function writeStackbitDevFiles({ connectorDir, integrationConfig, connectorConfig, }) {
    const localFrontendConfig = getConnectorLocalFrontendConfig(integrationConfig) || { port: null, directory: null };
    const createSSGPort = localFrontendConfig.port ?? false;
    await writeFile(resolve(connectorDir, "content-engine-hooks.cjs"), javascript `
        const { join } = require('path')
        import(join(__dirname, 'index.js')).then(() => {
          const { start } = require('@stackbit/dev/dist/dev.js')
          start({
            ssgPort: ${createSSGPort || 3000},
            ssgHost: '127.0.0.1',
            rootDir: __dirname,
            telemetryTrack: (event, data) => {
              if (process.send && event === 'Stackbit Dev Start') {
                // stackbit dev may start on a different port than the default 8090, this allows us to grab which port it's running on
                process.send({ type: 'SDK_START_STACKBIT_DEV', data: { port: data.port }  })
              }
            }
          })
        })
`);
    let createConfigFilePath = undefined;
    if (localFrontendConfig?.directory) {
        const frontendPath = join(connectorDir, `../../`, localFrontendConfig.directory);
        const filesInPath = fsExtra.readdirSync(frontendPath);
        const configNames = filesInPath.filter((name) => name.startsWith(`stackbit.config.`));
        if (configNames.length > 1)
            throw new Error(`Found multiple Netlify Create configuration files (filenames starting with create.config.*). Only one is allowed.`);
        if (configNames.length) {
            createConfigFilePath = join(frontendPath, configNames[0]);
        }
    }
    await writeFile(resolve(connectorDir, `stackbit.config.js`), makeStackbitConfigString({
        createConfigFilePath,
        connectorConfig,
    }));
}
function makeStackbitConfigString({ createConfigFilePath, connectorConfig, }) {
    const configs = Array.isArray(connectorConfig?.localDevOptions)
        ? connectorConfig.localDevOptions || {}
        : [connectorConfig.localDevOptions || {}];
    const contentSourceStrings = configs.map((options) => javascript `new CreateConnector({ options: ${JSON.stringify(options, null, 2)}})`);
    if (createConfigFilePath) {
        return javascript `
              import CreateConnector from './netlify-create.js'
              import config from "${createConfigFilePath}"

              const contentSources = config.contentSources || []

              if (!contentSources.find(source => source instanceof CreateConnector)) {
                ${contentSourceStrings
            .map((s) => `contentSources.push(${s})`)
            .join("\n")}
              }

              export default {
                ...config,
                contentSources
              }
          `;
    }
    else {
        return javascript `
              import CreateConnector from './netlify-create.js'

              export default {
                stackbitVersion: '~0.6.0',
                nodeVersion: '18',
                contentSources: [
                  ${contentSourceStrings.join(",\n")}
                ]
              }
        `;
    }
}
//# sourceMappingURL=cli.js.map