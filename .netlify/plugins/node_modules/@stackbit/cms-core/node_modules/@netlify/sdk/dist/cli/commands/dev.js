import readline from "readline";
import { spawn } from "child_process";
import chalk from "chalk";
import open from "open";
import { getSettings, updateSettings } from "../util.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { getConnectorLocalFrontendConfig, } from "../../integration/connect/cli.js";
import { build } from "./build.js";
import { preview } from "./preview.js";
export const dev = async ({ ...opts }) => {
    process.env.NODE_ENV = `development`;
    const buildApi = await build({
        ...opts,
        watch: true,
    });
    if (!buildApi || !buildApi.integration.netlifyConnectPlugin) {
        if (opts.connector) {
            throw new Error(`No Connector found`);
        }
        return;
    }
    const { startEngine } = await preview({
        ...opts,
        dev: true,
        // When building Integration UI-style integrations, force disable building the UI because the UI
        // code doesn't yet support dev mode
        ui: false,
    });
    if (opts.connector && startEngine) {
        handleConnectorPlugin({ buildApi, startEngine });
    }
};
export let connectorDevMode = getSettings()?.connectorDevMode || `clear cache on save`;
const handleConnectorPlugin = async ({ buildApi, startEngine, }) => {
    const supportsNetlifyCreate = !!buildApi.integration.netlifyConnectPlugin?.supports?.create;
    ntliLog("connector");
    const engine = await startEngine();
    const localFrontendConfig = getConnectorLocalFrontendConfig(buildApi.config);
    if (supportsNetlifyCreate) {
        handleFrontendProcess(localFrontendConfig);
    }
    handleConnectorKeypressListener({
        engine,
        supportsNetlifyCreate,
        localFrontendConfig,
    });
    logMode(supportsNetlifyCreate);
    buildApi.onRebuild(async () => {
        // restart content engine with the new bundle.
        // the engine runs in a worker thread and
        // calling .restart() will kill the worker and
        // start a new one that uses the new bundle that was just built.
        ntliLog(`connector`);
        await engine.stop();
        if (connectorDevMode === `rebundle-only on save`) {
            engine.initialize().then(() => {
                logMode(supportsNetlifyCreate);
            });
        }
        else {
            engine
                .sync({
                runServer: true,
                clearCache: connectorDevMode === `clear cache on save`,
            })
                .then(() => {
                logMode(supportsNetlifyCreate);
            });
        }
    });
};
let connectorKeypressListenerAdded = false;
export const handleConnectorKeypressListener = ({ engine, supportsNetlifyCreate, localFrontendConfig, }) => {
    const createLocalDev = localFrontendConfig && supportsNetlifyCreate
        ? localFrontendConfig
        : undefined;
    if (!connectorKeypressListenerAdded) {
        connectorKeypressListenerAdded = true;
        readline.emitKeypressEvents(process.stdin);
        process.stdin?.setRawMode?.(true);
        const stackbitURL = `http://localhost:8090/_stackbit`;
        const urls = {
            connect: `http://localhost:8000/__graphql`,
            create: supportsNetlifyCreate ? stackbitURL : null,
            framework: createLocalDev?.port
                ? `http://localhost:${createLocalDev.port}`
                : null,
        };
        process.stdin.on("keypress", (_str, key) => {
            if (key.name === "o") {
                void open(urls.connect, { wait: true }).catch(() => {
                    ntliLog(`Failed to open Connect API. You can manually navigate to ${urls.connect} in your browser.`);
                });
            }
            else if (urls.create && key.name === "c" && !key.ctrl) {
                void open(urls.create, { wait: true }).catch(() => {
                    ntliLog(`Failed to open local Netlify Create. You can manually navigate to ${urls.create} in your browser.`);
                });
            }
            else if (
            // still show the [f] keymap even if there's no framework url. we will print instructions on how to enable it if it's not configured (below)
            (urls.framework || supportsNetlifyCreate) &&
                key.name === "f") {
                if (urls.framework) {
                    void open(urls.framework, { wait: true }).catch(() => {
                        ntliLog(`Failed to open your local frontend app. You can manually navigate to ${urls.framework} in your browser.`);
                    });
                }
                else {
                    ntliLog(`
This connector supports Netlify Create but no local frontend configuration was found in integration.yaml\nThe local Netlify Create studio UI will run but you wont see a frontend app running inside Create studio.

To run a frontend framework app and test your connector as if you were one of your users, update your \`integration.yaml\` to include a \`connector.local-frontend\` block. For example:

config:
  slug: acme
  package_prefix: "@acme/connector"
  version: 1.0.0
  connector:
    local-frontend:
      port: 3000
      command: "pnpm run start"
      directory: "./local-frontend"
  `);
                }
            }
            else if (key.name === "m") {
                if (connectorDevMode === `clear cache on save`) {
                    connectorDevMode = `data update on save`;
                }
                else if (connectorDevMode === `data update on save`) {
                    connectorDevMode = `rebundle-only on save`;
                }
                else if (connectorDevMode === `rebundle-only on save`) {
                    connectorDevMode = `clear cache on save`;
                }
                updateSettings({ connectorDevMode });
                console.log(getModeLog());
            }
            else if ((key.ctrl && key.name === "c") || key.name === "q") {
                process.exit(); // If user presses CTRL+C, exit the process
            }
            else if (key.name === "r") {
                printResetHeader();
                ntliLog(`connector`);
                engine
                    .restart({
                    runServer: true,
                    clearCache: connectorDevMode === `clear cache on save`,
                })
                    .then(() => {
                    logMode(supportsNetlifyCreate);
                });
            }
            else if (key.name === "s") {
                console.log("");
                ntliLog(`syncing connector`);
                engine.sync();
            }
        });
    }
};
const getModeLog = () => `${chalk.grey(`[m]`)} mode (${connectorDevMode === `clear cache on save`
    ? chalk.yellow(connectorDevMode)
    : connectorDevMode === `rebundle-only on save`
        ? chalk.blue(connectorDevMode)
        : chalk.green(connectorDevMode)})`;
const logMode = (supportsCreate) => {
    console.log(chalk.blue(`Keys:`));
    console.log(getModeLog());
    console.log(`${chalk.grey(`[r]`)} restart process`);
    console.log(`${chalk.grey(`[s]`)} sync data\n`);
    console.log(chalk.blue(`Open:`));
    if (supportsCreate) {
        console.log(`${chalk.grey(`[c]`)} Netlify Create`);
    }
    console.log(`${chalk.grey(`[o]`)} Netlify Connect API`);
    if (supportsCreate) {
        console.log(`${chalk.grey(`[f]`)} frontend app`);
    }
};
async function handleFrontendProcess(localFrontendConfig) {
    if (!localFrontendConfig) {
        return;
    }
    const { command, directory, port } = localFrontendConfig || {};
    if (!command || !port) {
        console.warn(`When using integration.yaml connector.local-frontend you must provide a port and command to start a frontend for local Netlify Create. \n\nFound: ${JSON.stringify(localFrontendConfig, null, 2)}\nSkipping connector local dev frontend settings\n`);
        return;
    }
    const [bin, ...args] = command.split(` `);
    const frameworkP = spawn(bin, args, {
        stdio: `pipe`,
        cwd: directory || process.cwd(),
        detached: true,
    });
    let sawFirstCompileLog = false;
    frameworkP.stdout.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        // omit ugly/noisy nextjs logs
        if (message.includes(`compiling /`))
            return;
        if (message.includes(`compiled client and server successfully`)) {
            if (!sawFirstCompileLog) {
                sawFirstCompileLog = true;
                return;
            }
            // for compiled still print a more minimal log
            process.stdout.write(chalk.yellow(`frontend`) + `: compiled\n`);
            return;
        }
        if (message.includes(`started server on`) && message.includes(`:${port}`)) {
            return;
        }
        if (message.includes(`> next`) &&
            message.includes(`@`) &&
            message.includes(` dev /`))
            return;
        process.stdout.write(chalk.yellow(`frontend`) + `: ${message}`);
    });
    frameworkP.stderr.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        if (message.includes(`Fast Refresh had to perform a full reload.`))
            return;
        process.stderr.write(chalk.red(`frontend`) + `: ${message}`);
    });
    const { pid } = frameworkP;
    // kill frameworkP and all it's children when this process exits
    process.on("exit", async () => {
        if (pid) {
            process.kill(-pid);
        }
    });
}
//# sourceMappingURL=dev.js.map