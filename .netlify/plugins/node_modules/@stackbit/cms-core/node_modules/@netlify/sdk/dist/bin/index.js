import { createRequire } from "node:module";
import path from "node:path";
import process from "node:process";
const currentFilePath = new URL(import.meta.url).pathname;
const isInSDKRepo = currentFilePath.includes(`/packages/sdk/dist/bin/index.js`) &&
    !currentFilePath.includes(`node_modules`);
export async function main() {
    if (await attemptToUseCwdSDKPackage()) {
        return; // we switched to the local bin, don't run the rest of the code below
    }
    const { Command } = await import("@commander-js/extra-typings");
    const { build, dev, preview, init } = await import("../cli/commands/index.js");
    const siteType = process.env.UNSTABLE__USE_EXTENSION_UI === "true"
        ? "extension-ui"
        : "integration-ui";
    const cwd = process.cwd();
    const program = new Command();
    program
        .command("init")
        .action(init)
        .option("-s, --slug <slug>", "The slug of the integration")
        .option("-d, --description <description>", "The description of the integration")
        .option("-l, --integrationLevel <integrationLevel>", "The integrationLevel of the integration")
        .option("-p, --permissions <scopes>", "The permission scopes of the integration");
    const withBuildCommonFlags = (program) => {
        return program
            .option("-a, --all", "Build all components of the integration")
            .option("-c, --connector", "Build the Netlify Connect plugin of the integration")
            .option("-b, --buildtime", "Build the buildtime component of the integration")
            .option("-s, --site", "Build the serverless component of the integration");
    };
    withBuildCommonFlags(program.command("build"))
        .option("-w, --watch", "Build integration and then watch for changes", false)
        .action(async ({ all, buildtime, connector, site, ...opts }) => {
        await build({
            cwd,
            siteType,
            ...opts,
            ...normalizeBuildTargets({
                all,
                buildtime,
                connector,
                site,
            }),
        });
    });
    withBuildCommonFlags(program.command("dev")).action(async ({ all, buildtime, connector, site, ...opts }) => {
        await dev({
            cwd,
            siteType,
            ...opts,
            ...normalizeBuildTargets({
                all,
                buildtime,
                connector,
                site,
            }),
        });
    });
    program
        .command("preview")
        .option("-c, --connector", "Preview the GraphQL server for your Netlify Connect plugin", false)
        .option("-d --dev", "Run the preview server in development mode", false)
        .action((opts) => {
        preview({
            ...opts,
            cwd,
            siteType,
        });
    });
    program.parse();
}
// this is wrapped conditionally so that when we require the SDK bin from the node_modules of the cwd, we don't immediately run its main function - that would cause infinite recursion of attempting to use the cwd sdk bin
if (!process.env.SDK_BIN_SWITCH_PATH) {
    main();
}
const normalizeBuildTargets = ({ all: _all, buildtime: _buildtime, connector: _connector, site: _site, }) => {
    let buildtime;
    let connector;
    let site;
    // If no build target is explicitly specified, default to all
    if (_all === undefined &&
        _buildtime === undefined &&
        _connector === undefined &&
        _site === undefined) {
        _all = true;
    }
    if (_all) {
        // If all = true, enable all build targets
        buildtime = true;
        connector = true;
        site = true;
    }
    else {
        // Otherwise, only build the specified targets
        buildtime = _buildtime === undefined ? false : _buildtime;
        connector = _connector === undefined ? false : _connector;
        site = _site === undefined ? false : _site;
    }
    return {
        buildtime,
        connector,
        site,
    };
};
async function attemptToUseCwdSDKPackage() {
    if (isInSDKRepo) {
        // if the currently running file is inside the sdk repo and not inside node_modules, we don't want to use the cwd sdk bin
        // this is so we can test our local changes to the SDK without this file switching over to the local bin in the cwd node_modules
        console.warn(`This CLI process is running from your local SDK repo. Using the SDK bin in ${currentFilePath}. Users should not see this message.`);
        return false;
    }
    try {
        // if this is already set, we've already switched to the cwd sdk bin and that bin is itself trying to switch to the cwd sdk bin,
        // so we should stop here to prevent infinite recursion - the fn that called this one will run its own logic when we return false here
        if (process.env.SDK_BIN_SWITCH_PATH) {
            return false;
        }
        const requirePath = path.join(process.cwd() +
            // without subdir it seems to want to resolve from the parent dir of cwd
            `/subdir`);
        const require = createRequire(requirePath);
        const localBinPath = require.resolve("@netlify/sdk/bin");
        if (!localBinPath) {
            return false;
        }
        process.env.SDK_BIN_SWITCH_PATH = localBinPath;
        // @ts-ignore - this import may or may not exist. If it doesn't, we'll catch the error and fall back to the global SDK
        const bin = await import(localBinPath);
        if (`main` in bin && typeof bin.main === `function`) {
            await bin.main();
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        console.log(``);
        e instanceof Error ? console.error(e.message) : console.error(e);
        console.log(``);
        console.warn(`Errored importing local @netlify/sdk module. Falling back to the globally installed bin. Upgrade your project to the latest version of @netlify/sdk to fix this error.\n`);
    }
    return false;
}
//# sourceMappingURL=index.js.map