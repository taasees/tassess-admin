import { execSync } from "node:child_process";
import { existsSync, rmSync, mkdirSync, writeFileSync } from "node:fs";
import { resolve, join, dirname } from "node:path";
import chalk from "chalk";
import { build as esbuild, context, } from "esbuild";
import { copy } from "esbuild-plugin-copy";
import { IntegrationWorkerManager } from "../worker/manager.js";
import { buildExtensionUI, buildIntegrationUI, generateBuildEventHandler, generateConnectPlugin, processHandlers, processWrappers, } from "../index.js";
import { getConfiguration, getExternalDepNames, getIntegrationBuildInfo, getIntegrationModule, } from "../util.js";
import { ntliLog, printResetHeader } from "../../utils.js";
const __dirname = new URL(".", import.meta.url).pathname;
export const build = async (opts) => {
    const isPreview = !!opts.previewUrl;
    const config = await getConfiguration(opts.cwd);
    // remove dist folders
    rmSync(resolve(opts.cwd, ".ntli"), { recursive: true, force: true });
    const { outDir, builtPath, sourceFilePath, integrationPackageJson, packageName, } = await getIntegrationBuildInfo({
        cwd: opts.cwd,
        outDirOveride: opts.dir,
    });
    // Lint the project
    if (existsSync(resolve(opts.cwd, "tsconfig.json"))) {
        // generate a tsconfig that wraps their tsconfig and excludes any files that are not imported in their main package
        const tsconfig = `
      {
        "extends": "../tsconfig.json",
        "include": ["${resolve(opts.cwd, integrationPackageJson.main)}"]
      }
    `;
        mkdirSync(resolve(opts.cwd, ".ntli"));
        writeFileSync(resolve(opts.cwd, ".ntli/tsconfig.build.json"), tsconfig);
        try {
            execSync(`npx tsc --noEmit --skipLibCheck -p ./.ntli/tsconfig.build.json`, {
                // write errors and output to process stdio
                stdio: `inherit`,
            });
        }
        catch (e) {
            if (e instanceof Error) {
                console.error(chalk.red(e.message));
            }
            process.exit(1);
        }
    }
    const { main } = integrationPackageJson;
    if (opts.connector) {
        // we need to bundle this so it can be used in template files for Connect/Create that are not bundled, but are copied to the built integration
        await esbuild({
            bundle: true,
            format: "esm",
            platform: "node",
            entryPoints: [
                join(__dirname, "../../integration/connect/utils/instance-id.js"),
            ],
            outfile: join(dirname(builtPath), "/connector/instance-id.js"),
        });
    }
    // each function added to this array is invoked when the integration is rebundled
    const rebuildListeners = [];
    function onRebuild(listener) {
        rebuildListeners.push(listener);
    }
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [sourceFilePath],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: builtPath,
        external: getExternalDepNames(integrationPackageJson),
        sourcemap: "linked",
        plugins: [
            copy({
                assets: {
                    // resolved based on cwd
                    from: ["src/assets/**/*"],
                    // ^^ doesn't copy files/dirs starting with . for some reason
                    // adding "src/assets/.**/*" causes the copy plugin to throw errors.
                    // possibly due to changes in the new esbuild watch mode API.
                    // resolved based on outfile
                    to: ["assets"],
                    // watch assets for changes in watch mode
                    watch: opts.watch,
                },
                copyOnStart: true,
            }),
            copy({
                assets: {
                    from: ["./README.md"],
                    to: ["./README.md"],
                    watch: opts.watch,
                },
            }),
        ],
    };
    const integrationWorker = new IntegrationWorkerManager(builtPath);
    if (opts.watch) {
        const buildContext = await context({
            ...esbuildOptions,
            plugins: [
                ...(esbuildOptions.plugins || []),
                {
                    name: "rebuild-listener",
                    setup(build) {
                        let shouldNotifyRebuildListeners = false;
                        // sometimes esbuild immediately rebuilds twice on start,
                        setTimeout(() => 
                        // so only notify listeners if it's been more than 100ms since the build started
                        (shouldNotifyRebuildListeners = true), 1000);
                        let notifying = false;
                        build.onEnd(async () => {
                            if (notifying) {
                                return;
                            }
                            notifying = true;
                            if (shouldNotifyRebuildListeners) {
                                printResetHeader();
                                await integrationWorker.reload();
                                for (const listener of rebuildListeners) {
                                    await listener();
                                }
                            }
                            notifying = false;
                        });
                    },
                },
            ],
        });
        printResetHeader();
        await buildContext.rebuild();
        await buildContext.watch();
    }
    else {
        await esbuild(esbuildOptions);
    }
    const integration = await getIntegrationModule(builtPath, opts.cwd);
    await integrationWorker.loadModule(opts.cwd);
    if (!integration) {
        return false;
    }
    if (opts.buildtime) {
        ntliLog("Generating build event handlers...");
        await generateBuildEventHandler(integration, { ...config, slug: isPreview ? "netlify-preview" : config.slug }, {
            cwd: opts.cwd,
            outDir,
        });
    }
    if (opts.site && opts.siteType === "integration-ui") {
        ntliLog("Generating Function handlers...");
        await processHandlers({
            cwd: opts.cwd,
            outDir,
        }, { ...config, slug: isPreview ? "netlify-preview" : config.slug });
        await buildIntegrationUI({
            mainPath: main,
            outDir,
            surfaceScriptUrl: opts.previewUrl
                ? `${opts.previewUrl}/ui/integration-ui.js`
                : `https://netlify-integration-${config.slug}.netlify.app/ui/integration-ui.js`,
            watch: opts.watch,
            id: config.slug,
        });
    }
    if (integration.wrappers) {
        await processWrappers(integration.wrappers, {
            cwd: opts.cwd,
            outDir,
        });
    }
    if (opts.connector) {
        await generateConnectPlugin(integrationWorker, config, {
            cwd: opts.cwd,
            outDir,
            watchMode: opts.watch,
        });
    }
    if (opts.site && opts.siteType === "extension-ui") {
        const mode = opts.watch ? "dev" : "build";
        ntliLog(`Building Extension UI${opts.watch ? " in watch mode" : ""}...`);
        const buildExtensionUIPromise = buildExtensionUI({
            stderr: process.stderr,
            stdout: process.stdout,
        }, {
            cwd: opts.cwd,
            outdir: outDir,
            mode,
            meta: {
                name: config.name ?? "",
                slug: config.slug,
            },
        });
        if (!opts.watch) {
            // XXX(ndhoule): Sorry! This is a gross hack for the time being. `buildExtensionUI` only
            // resolves when the underlying command completes; in watch mode, it will run as long as
            // you're watching. The control flow in the rest of this function is not really amenable to
            // long-lived promises, though.
            //
            // (In the future, we should use an `AbortSignal` to cancel this long-running task and await
            // all the build steps in a `Promise.all()`.)
            await buildExtensionUIPromise;
        }
    }
    if (!opts.watch) {
        ntliLog("Build complete!");
    }
    if (opts.connector && opts.watch) {
        onRebuild(async () => {
            generateConnectPlugin(integrationWorker, config, {
                cwd: opts.cwd,
                outDir,
                watchMode: opts.watch,
            });
        });
        if (opts.site && opts.siteType === "integration-ui") {
            onRebuild(() => {
                processHandlers({
                    cwd: opts.cwd,
                    outDir,
                }, { ...config, slug: isPreview ? "netlify-preview" : config.slug });
            });
        }
        if (integration.wrappers) {
            onRebuild(() => {
                processWrappers(integration.wrappers, {
                    cwd: opts.cwd,
                    outDir,
                });
            });
        }
    }
    if (!opts.watch) {
        integrationWorker.stop();
    }
    return {
        config,
        cwd: opts.cwd,
        integration,
        onRebuild,
        packageName,
        slug: config.slug,
    };
};
export function getDefaultEsbuildConfig(config) {
    if (config.use_cjs_shims) {
        return { inject: [join(__dirname, `../cjs-shim.js`)] };
    }
    return {};
}
//# sourceMappingURL=build.js.map