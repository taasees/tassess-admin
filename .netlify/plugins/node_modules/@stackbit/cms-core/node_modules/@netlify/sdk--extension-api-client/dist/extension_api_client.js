import { default as w } from "wretch";
import { INTEGRATION_API_URL_PROD } from "./constants.js";
import { NetlifyClient } from "./netlify_api_client.js";
import { envVarFromSlug } from "./utils.js";
export class AlreadyEnabledError extends Error {
    constructor() {
        super("Already enabled");
    }
}
export class NetlifyIntegrationClient extends NetlifyClient {
    netlifyToken;
    integration;
    integrationApi;
    constructor(netlifyToken, integration, { jigsawUrl = "", netlifyApiUrl = "" } = {}) {
        super(netlifyToken, {
            baseUrl: netlifyApiUrl !== ""
                ? netlifyApiUrl
                : `${INTEGRATION_API_URL_PROD}/api/v1`,
        });
        this.netlifyToken = netlifyToken;
        this.integration = integration;
        this.integrationApi = w()
            .url(jigsawUrl !== "" ? jigsawUrl : INTEGRATION_API_URL_PROD)
            .headers({
            "netlify-token": netlifyToken,
        });
    }
    /**
     * Returns the integration configuration for a site for the current integration.
     */
    getSiteIntegration = async (siteId) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .get()
            .json();
    };
    /**
     * Returns the integration configuration for a team for the current integration.
     */
    getTeamIntegration = async (teamId) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .get()
            .json();
    };
    /**
     * Enables this integration for a team, it is also possible to immediately pass a configuration object with the integration's configuration.
     */
    enableTeamIntegration = async (teamId, config = {}) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .post({ config })
            .json();
    };
    /**
     * Enables this integration for a site, passing a configuration object.
     */
    enableSiteIntegration = async (siteId, config) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .post({ config })
            .json();
    };
    /**
     * Updates the integration configuration for a site.
     */
    updateSiteIntegration = async (siteId, config) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .put({ config })
            .res();
    };
    /**
     * Updates the integration configuration for a team.
     */
    updateTeamIntegration = async (teamId, config) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .put({ config })
            .res();
    };
    /**
     * Disables this integration for a site, which also deletes the configuration.
     */
    disableSiteIntegration = async (siteId) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .delete()
            .res();
    };
    /**
     * Disables this integration for a team, and deletes the associated configuration for the integration.
     */
    disableTeamIntegration = async (teamId) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .delete()
            .res();
    };
    /**
     * Generates a build token for a site, allowing a build hook to use the Build Context API.
     */
    generateBuildToken = async (siteId, teamId) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}/generate-build-token`)
            .post({ teamId })
            .json();
    };
    /**
     * Validates a build token, returning the siteId and teamId if the token is valid and returning an error if the token is invalid.
     */
    exchangeBuildToken = async (siteId) => {
        const integrationSecret = process.env["INTEGRATION_SECRET"];
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}/exchange-build-token`)
            .post({ token: this.netlifyToken, secret: integrationSecret })
            .json();
    };
    /**
     * Sets the build token for a site. Build tokens can be created using the `generateBuildToken` method.
     */
    async setBuildToken(accountId, siteId, token) {
        const safeSlug = envVarFromSlug(this.integration);
        await this.createOrUpdateVariable({
            accountId,
            siteId,
            key: `${safeSlug}_BUILD_TOKEN`,
            value: token,
        });
    }
    /**
     * Removes the build token for a site.
     */
    async removeBuildToken(accountId, siteId) {
        const safeSlug = envVarFromSlug(this.integration);
        await this.deleteEnvironmentVariable({
            accountId,
            siteId,
            key: `${safeSlug}_BUILD_TOKEN`,
        });
    }
    /**
     * Enables the build hook for a site.
     */
    enableBuildEventHandlers = (siteId) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .put({ has_build_hook_enabled: true })
            .res();
    };
    /**
     * Disables the build hook for a site.
     */
    disableBuildEventHandlers = (siteId) => {
        return this.integrationApi
            .url(`/site/${siteId}/integrations/${this.integration}`)
            .put({ has_build_hook_enabled: false })
            .res();
    };
    enableConnectors = (teamId) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .put({ has_connectors_enabled: true })
            .res();
    };
    disableConnectors = (teamId) => {
        return this.integrationApi
            .url(`/team/${teamId}/integrations/${this.integration}`)
            .put({ has_connectors_enabled: false })
            .res();
    };
}
//# sourceMappingURL=extension_api_client.js.map