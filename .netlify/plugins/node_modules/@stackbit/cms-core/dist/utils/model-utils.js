"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModelMap = exports.validateModels = exports.normalizeModels = void 0;
const lodash_1 = __importDefault(require("lodash"));
const sdk_1 = require("@stackbit/sdk");
function normalizeModels({ models, logger }) {
    return models.map((model) => {
        model = { ...model };
        if (!('name' in model)) {
            logger.warn('model does not have a name');
        }
        if (!('type' in model)) {
            logger.warn(`model '${model['name']}' does not have a type, using 'object'`);
            lodash_1.default.set(model, 'type', 'object');
        }
        // add model label if not set
        if (!('label' in model)) {
            model.label = lodash_1.default.startCase(model.name);
        }
        if (!('fields' in model) || !Array.isArray(model.fields)) {
            model.fields = [];
        }
        if ((0, sdk_1.isPageModel)(model)) {
            // set default urlPath if not set
            if (!model.urlPath) {
                model.urlPath = '/{slug}';
            }
        }
        (0, sdk_1.assignLabelFieldIfNeeded)(model);
        if ((model.type === 'data' || model.type === 'page') && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: 'document'
            }));
        }
        else if (model.type === 'object' && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: 'object'
            }));
        }
        model = (0, sdk_1.mapModelFieldsRecursively)(model, (field) => {
            field = { ...field };
            if (!('label' in field)) {
                field.label = lodash_1.default.startCase(field.name);
            }
            if (field.actions) {
                field.actions = field.actions.map((action) => ({
                    ...action,
                    type: action.type ?? 'field'
                }));
            }
            (0, sdk_1.mapListItemsPropsOrSelfSpecificProps)(field, (listItemsPropsOrField) => {
                if ((0, sdk_1.isObjectField)(listItemsPropsOrField)) {
                    (0, sdk_1.assignLabelFieldIfNeeded)(listItemsPropsOrField);
                }
                else if ((0, sdk_1.isCrossReferenceField)(listItemsPropsOrField)) {
                    listItemsPropsOrField.models = validateAndNormalizeCrossReferenceModels({
                        crossReferenceModels: listItemsPropsOrField.models,
                        models,
                        logger
                    });
                }
                return listItemsPropsOrField;
            });
            return field;
        });
        return model;
    });
}
exports.normalizeModels = normalizeModels;
function validateAndNormalizeCrossReferenceModels({ crossReferenceModels, models, logger }) {
    const modelGroupsByModelName = models.reduce((modelGroups, model) => {
        if (!(model.name in modelGroups)) {
            modelGroups[model.name] = [];
        }
        modelGroups[model.name].push(model);
        return modelGroups;
    }, {});
    // Match cross-reference models to the group of content source models with
    // the same name. Then, match the cross-reference model to content source
    // model by comparing srcType and srcProjectId. If after the comparison,
    // there are more than one model left, log a warning and filter out that
    // cross-reference model so it won't cause any model ambiguity.
    const nonMatchedCrossReferenceModels = [];
    const normalizedCrossReferenceModels = crossReferenceModels.reduce((matchedCrossReferenceModels, crossReferenceModel) => {
        const models = modelGroupsByModelName[crossReferenceModel.modelName];
        if (!models) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels: [] });
            return matchedCrossReferenceModels;
        }
        const matchedModels = models.filter((model) => {
            const matchesType = !crossReferenceModel.srcType || model.srcType === crossReferenceModel.srcType;
            const matchesId = !crossReferenceModel.srcProjectId || model.srcProjectId === crossReferenceModel.srcProjectId;
            return matchesType && matchesId;
        });
        if (matchedModels.length !== 1) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels });
            return matchedCrossReferenceModels;
        }
        const matchedModel = matchedModels[0];
        matchedCrossReferenceModels.push({
            modelName: crossReferenceModel.modelName,
            srcType: matchedModel.srcType,
            srcProjectId: matchedModel.srcProjectId
        });
        return matchedCrossReferenceModels;
    }, []);
    // Log model matching warnings using user logger
    for (const { crossReferenceModel, matchedModels } of nonMatchedCrossReferenceModels) {
        let message = `a model of cross-reference field: '${crossReferenceModel.modelName}'`;
        if (crossReferenceModel.srcType) {
            message += `, srcType: '${crossReferenceModel.srcType}'`;
        }
        if (crossReferenceModel.srcProjectId) {
            message += `, srcProjectId: '${crossReferenceModel.srcProjectId}'`;
        }
        message = message + ` defined in stackbit config`;
        let contentSourceModelsMessage;
        if (matchedModels.length) {
            const matchesModelsMessage = matchedModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
            contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
        }
        else {
            contentSourceModelsMessage = ' does not match any content source model';
        }
        logger.warn(message + contentSourceModelsMessage);
    }
    return normalizedCrossReferenceModels;
}
function validateModels({ models, logger }) {
    const { config, errors } = (0, sdk_1.validateConfig)({
        stackbitVersion: '0.5.0',
        models: models,
        dirPath: '.',
        filePath: 'stackbit.config.js'
    });
    for (const error of errors) {
        logger.warn(error.message);
    }
    return config.models;
}
exports.validateModels = validateModels;
function getModelMap({ models }) {
    return models.reduce((res, model) => {
        res[model.name] = model;
        return res;
    }, {});
}
exports.getModelMap = getModelMap;
//# sourceMappingURL=model-utils.js.map