"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCustomAction = exports.resolveCustomActionPermissions = exports.resolveCustomActionsById = exports.getGlobalAndBulkAPIActions = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const config_delegate_1 = require("./config-delegate");
const document_hooks_1 = require("./document-hooks");
const store_to_csi_docs_converter_1 = require("./store-to-csi-docs-converter");
const field_path_utils_1 = require("./field-path-utils");
const content_store_utils_1 = require("../content-store-utils");
async function getGlobalAndBulkAPIActions({ stackbitConfig, customActionRunStateMap, contentSourceDataById, userLogger, pageUrl, user, locale, currentPageDocument }) {
    if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
        return [];
    }
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById: contentSourceDataById,
        logger: userLogger
    });
    return (0, utils_1.mapPromise)(stackbitConfig.actions, async (action) => {
        const actionId = globalActionId(action);
        const actionRunState = customActionRunStateMap[actionId];
        let state;
        const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
        const commonStateOptions = {
            actionId: actionId,
            currentLocale: locale,
            currentUser: user,
            currentPageUrl: pageUrl,
            currentPageDocument: pageDocument,
            ...configDelegate
        };
        if (actionRunState?.runningHandler) {
            state = 'running';
        }
        else if (action.state) {
            state = await action.state(commonStateOptions);
        }
        else {
            state = actionRunState?.lastResultState ?? 'enabled';
        }
        let permissionsResult;
        if (commonStateOptions.currentUser) {
            const commonPermissionsOptions = {
                ...lodash_1.default.omit(commonStateOptions, ['currentUser']),
                userContext: commonStateOptions.currentUser
            };
            permissionsResult = resolveCustomActionPermissions({ action, commonPermissionsOptions, contentSourceDataById });
        }
        return (0, utils_1.omitByNil)({
            type: action.type,
            actionId: actionId,
            name: action.name,
            label: action.label ?? lodash_1.default.startCase(action.name),
            icon: action.icon,
            state: state,
            inputFields: action.inputFields,
            hidden: action.hidden,
            permissions: permissionsResult
        });
    });
}
exports.getGlobalAndBulkAPIActions = getGlobalAndBulkAPIActions;
async function resolveCustomActionsById({ getActionRequest, customActionRunStateMap, contentSourceDataById, stackbitConfig, userLogger }) {
    const result = [];
    const { customActionIds, locale, user, pageUrl, currentPageDocument } = getActionRequest;
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById,
        logger: userLogger
    });
    for (const actionId of customActionIds) {
        const extendedAction = findCustomActionById({
            actionId,
            customActionRunStateMap,
            contentSourceDataById,
            stackbitConfig
        });
        if (!extendedAction) {
            userLogger.debug(`custom action with id: '${actionId}' was not found`);
            continue;
        }
        const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
        const commonStateOptions = {
            actionId: actionId,
            currentLocale: locale,
            currentUser: user,
            currentPageUrl: pageUrl,
            currentPageDocument: pageDocument,
            ...configDelegate
        };
        try {
            let state;
            if (extendedAction.runningHandler) {
                state = 'running';
            }
            else if (extendedAction.state) {
                if (extendedAction.type === 'global' || extendedAction.type === 'bulk') {
                    state = await extendedAction.state(commonStateOptions);
                }
                else if (extendedAction.type === 'document') {
                    const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                        documentSpec: extendedAction.documentSpec,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        document: document,
                        model: model
                    });
                }
                else if (extendedAction.type === 'objectModel') {
                    const stateObjectParams = getHandlerParamsForObjectModelAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                }
                else if (extendedAction.type === 'objectField') {
                    const stateObjectParams = getHandlerParamsForObjectFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                }
                else if (extendedAction.type === 'field') {
                    const stateFieldParams = getHandlerParamsForFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateFieldParams
                    });
                }
                else {
                    const _exhaustiveCheck = extendedAction;
                    continue;
                }
            }
            else {
                state = extendedAction.lastResultState ?? 'enabled';
            }
            let permissionsResult;
            if (commonStateOptions.currentUser) {
                const commonPermissionsOptions = {
                    ...lodash_1.default.omit(commonStateOptions, ['currentUser']),
                    userContext: commonStateOptions.currentUser
                };
                permissionsResult = resolveCustomActionPermissions({ action: extendedAction, commonPermissionsOptions, contentSourceDataById });
            }
            result.push((0, utils_1.omitByNil)({
                actionId: actionId,
                type: storeActionTypeToAPIActionType(extendedAction.type),
                name: extendedAction.name,
                label: extendedAction.label,
                icon: extendedAction.icon,
                state: state,
                inputFields: extendedAction.inputFields,
                hidden: extendedAction.hidden,
                permissions: permissionsResult
            }));
        }
        catch (error) {
            userLogger.warn(`getCustomActionsById: error resolving custom action, id: '${actionId}', error: ${error.message}`);
        }
    }
    return result;
}
exports.resolveCustomActionsById = resolveCustomActionsById;
function resolveCustomActionPermissions({ action, commonPermissionsOptions, contentSourceDataById }) {
    if (typeof action?.permissions !== 'function' || !commonPermissionsOptions.userContext) {
        return undefined;
    }
    let document, model, stateParams;
    switch (action.type) {
        case 'global':
        case 'bulk':
            return action.permissions?.(commonPermissionsOptions);
        case 'document':
            ({ document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: action.documentSpec,
                contentSourceDataById
            }));
            return action.permissions?.({ ...commonPermissionsOptions, document, model });
        case 'objectModel':
            stateParams = getHandlerParamsForObjectModelAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
        case 'objectField':
            stateParams = getHandlerParamsForObjectFieldAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
        case 'field':
            stateParams = getHandlerParamsForFieldAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
    }
}
exports.resolveCustomActionPermissions = resolveCustomActionPermissions;
function runCustomAction({ runActionRequest, customActionRunStateMap, contentSourceDataById, stackbitConfig, userLogger }) {
    const extendedAction = findCustomActionById({
        actionId: runActionRequest.actionId,
        customActionRunStateMap,
        contentSourceDataById,
        stackbitConfig
    });
    if (!extendedAction) {
        throw new Error(`Error running action: action not found, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    const prevResultState = extendedAction.lastResultState;
    if (extendedAction.lastResultState && extendedAction.lastResultState !== 'enabled') {
        throw new Error(`Error running action: action is not enabled, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    try {
        const actionLogger = userLogger.createLogger({ label: `action:${extendedAction.name}` });
        const configDelegate = (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: contentSourceDataById, logger: actionLogger });
        const currentPageDocument = getCSIDocumentWithSourceFromDocumentSpec(runActionRequest.currentPageDocument, configDelegate);
        customActionRunStateMap[runActionRequest.actionId] = {
            runningHandler: true,
            lastResultState: 'running'
        };
        const commonRunOptions = {
            actionId: extendedAction.actionId,
            inputData: runActionRequest.inputData,
            currentLocale: runActionRequest.locale,
            currentUser: runActionRequest.user,
            currentPageUrl: runActionRequest.pageUrl,
            currentPageDocument: currentPageDocument,
            getContentSourceActionsForSource: (0, document_hooks_1.getContentSourceActionsForSourceThunk)({
                getContentSourceDataById: () => contentSourceDataById,
                logger: userLogger,
                user: runActionRequest.user,
                stackbitConfig: stackbitConfig
            }),
            getUserContextForContentSourceType: (0, content_store_utils_1.getUserContextForSrcTypeThunk)(runActionRequest.user),
            ...configDelegate
        };
        let promise;
        if (extendedAction.type === 'global') {
            promise = extendedAction.run(commonRunOptions);
        }
        else if (extendedAction.type === 'bulk') {
            const documents = runActionRequest.documents.map((documentSpec) => {
                const { document } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                    documentSpec,
                    contentSourceDataById
                });
                return document;
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                documents
            });
        }
        else if (extendedAction.type === 'document') {
            const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: extendedAction.documentSpec,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                document,
                model,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'objectModel') {
            const handlerObjectParams = getHandlerParamsForObjectModelAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'objectField') {
            const handlerObjectParams = getHandlerParamsForObjectFieldAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'field') {
            const handlerFieldParams = getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerFieldParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else {
            throw new Error(`action type ${extendedAction.type} not supported`);
        }
        return promise
            .then((actionResult) => {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: actionResult?.state
            };
            userLogger.debug(`Action completed: ${extendedAction.actionId}`);
            return Promise.resolve((0, utils_1.omitByNil)({
                actionId: extendedAction.actionId,
                actionName: extendedAction.name,
                actionType: storeActionTypeToAPIActionType(extendedAction.type),
                // TODO: resolve the state if state function is defined
                state: actionResult?.state ?? 'enabled',
                success: actionResult?.success,
                error: actionResult?.error,
                result: actionResult?.result
            }));
        })
            .catch((error) => {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
            userLogger.debug(`Error running action: ${error.message}`);
            return Promise.resolve({
                actionId: extendedAction.actionId,
                actionName: extendedAction.name,
                actionType: storeActionTypeToAPIActionType(extendedAction.type),
                // TODO: resolve the state if state function is defined
                state: prevResultState ?? 'enabled',
                error: `Error running action: ${error.message}`
            });
        });
    }
    catch (error) {
        if (customActionRunStateMap[runActionRequest.actionId]) {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
        }
        userLogger.debug(`Error running action: ${error.message}`);
        return Promise.resolve({
            actionId: runActionRequest.actionId,
            actionName: extendedAction?.name ?? runActionRequest.actionName,
            actionType: storeActionTypeToAPIActionType(extendedAction?.type) ?? runActionRequest.actionType,
            // TODO: resolve the state if state function is defined
            state: prevResultState ?? 'enabled',
            error: `Error running action: ${error.message}`
        });
    }
}
exports.runCustomAction = runCustomAction;
function getCSIDocumentWithSourceFromDocumentSpec(documentSpec, configDelegate) {
    return documentSpec
        ? configDelegate.getDocumentById({
            id: documentSpec.srcDocumentId,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        })
        : undefined;
}
function getHandlerParamsForObjectModelAction({ extendedAction, contentSourceDataById }) {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });
    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }
    const documentField = fieldActionCommonParams.documentField;
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const objectModel = contentSourceData.modelMap[documentField.modelName];
    if (!objectModel || objectModel.type !== 'object') {
        throw new Error(`object model '${documentField.modelName}' not found`);
    }
    return {
        ...fieldActionCommonParams,
        documentField,
        modelField: fieldActionCommonParams.modelField,
        objectModel: {
            ...objectModel,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}
function getHandlerParamsForObjectFieldAction({ extendedAction, contentSourceDataById }) {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });
    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }
    return {
        ...fieldActionCommonParams,
        documentField: fieldActionCommonParams.documentField,
        modelField: fieldActionCommonParams.modelField
    };
}
function getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById }) {
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(`document not found for srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`);
    }
    const model = contentSourceData.modelMap[document.srcModelName];
    if (!model) {
        throw new Error(`model '${document.srcModelName}' not found`);
    }
    const mappedCSIDocument = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({ document, csiDocument });
    // the documentField should be localized because fieldPath includes locales
    const { modelField, documentField } = (0, field_path_utils_1.getModelAndDocumentFieldForLocalizedFieldPath)({
        document,
        fieldPath: extendedAction.fieldPath,
        modelMap: contentSourceData.modelMap
    });
    const csiDocumentField = documentField ? (0, store_to_csi_docs_converter_1.mapStoreFieldToCSIField)(documentField) : undefined;
    return {
        parentDocument: mappedCSIDocument,
        parentModel: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        },
        documentField: csiDocumentField,
        modelField: modelField,
        fieldPath: extendedAction.fieldPath
    };
}
function getCSIDocumentAndModelWithSourceFromDocumentSpec({ documentSpec, contentSourceDataById }) {
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(`document not found, srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`);
    }
    const mappedDocument = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({
        document,
        csiDocument
    });
    const model = contentSourceData.modelMap[mappedDocument.modelName];
    if (!model) {
        throw new Error(`model '${mappedDocument.modelName}' not found`);
    }
    return {
        document: mappedDocument,
        model: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}
function storeActionTypeToAPIActionType(storeActionType) {
    if (storeActionType === 'objectModel' || storeActionType === 'objectField') {
        return 'object';
    }
    return storeActionType;
}
function findCustomActionById({ actionId, customActionRunStateMap, contentSourceDataById, stackbitConfig }) {
    const actionRunState = customActionRunStateMap[actionId];
    if (isGlobalActionId(actionId)) {
        if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
            return undefined;
        }
        const actionName = getGlobalActionNameFromId(actionId);
        const action = stackbitConfig.actions.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            ...action,
            actionId,
            label: action.label ?? lodash_1.default.startCase(action.name),
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    }
    const { srcType, srcProjectId, srcDocumentId, actionName, fieldPath } = parseActionId(actionId) ?? {};
    if (!srcType || !srcProjectId || !srcDocumentId || !actionName) {
        return undefined;
    }
    const documentSpec = { srcType, srcProjectId, srcDocumentId };
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(srcType, srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[srcDocumentId];
    if (!document) {
        return undefined;
    }
    const modelName = document.srcModelName;
    const model = contentSourceData.modelMap[modelName];
    // The model of a document is always 'page' or 'data',
    // this condition helps TS to infer the right type of model.actions
    if (!model || (model.type !== 'page' && model.type !== 'data')) {
        return undefined;
    }
    if (typeof fieldPath === 'undefined') {
        // fieldPath was not provided, therefore the model must be of type "page" or "data",
        // and the action type must be 'document'
        const action = model.actions?.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId,
            label: action.label ?? lodash_1.default.startCase(action.name),
            documentSpec,
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    }
    else {
        const { modelField, documentField } = (0, field_path_utils_1.getModelAndDocumentFieldForLocalizedFieldPath)({
            document,
            fieldPath,
            modelMap: contentSourceData.modelMap
        });
        if ('actions' in modelField && Array.isArray(modelField.actions)) {
            const action = modelField.actions.find((action) => action.name === actionName);
            if (action) {
                return {
                    // if configuration is updated, the new action properties will override the stored action properties
                    ...action,
                    type: action.type === 'object' ? 'objectField' : 'field',
                    actionId,
                    label: action.label ?? lodash_1.default.startCase(action.name),
                    documentSpec,
                    fieldPath,
                    runningHandler: actionRunState?.runningHandler,
                    lastResultState: actionRunState?.lastResultState
                };
            }
        }
        if (modelField.type === 'model') {
            if (!documentField || documentField.type !== 'model' || documentField.localized || documentField.isUnset) {
                return undefined;
            }
            const modelName = documentField.srcModelName;
            const model = contentSourceData.modelMap[modelName];
            if (!model || model.type !== 'object') {
                return undefined;
            }
            if (!('actions' in model && Array.isArray(model.actions))) {
                return undefined;
            }
            // This is a nested model of type "object", so the action must be CustomActionObjectModel
            const action = model.actions.find((action) => action.name === actionName);
            if (!action) {
                return undefined;
            }
            return {
                // if configuration is updated, the new action properties will override the stored action properties
                ...action,
                type: 'objectModel',
                actionId,
                label: action.label ?? lodash_1.default.startCase(action.name),
                documentSpec,
                fieldPath,
                runningHandler: actionRunState?.runningHandler,
                lastResultState: actionRunState?.lastResultState
            };
        }
    }
}
function globalActionId(action) {
    return `config.actions.${action.name}`;
}
function isGlobalActionId(actionId) {
    return actionId.startsWith('config.actions.');
}
function getGlobalActionNameFromId(actionId) {
    return actionId.substring('config.actions.'.length);
}
function parseActionId(actionId) {
    try {
        return JSON.parse(actionId);
    }
    catch (e) {
        return undefined;
    }
}
//# sourceMappingURL=custom-actions.js.map