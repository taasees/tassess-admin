export default class ConnectorWrapper {
    constructor({ integration, config }) {
        this.integration = integration;
        this.options = config;
        this.connector = integration.netlifyConnectPlugin;
    }
    getContentSourceType() {
        // todo
        return 'todo';
    }
    getProjectId() {
        // todo
        return '1';
    }
    async getVersion() {
        return { interfaceVersion: '0.7.3', contentSourceVersion: '0.1' };
    }
    getProjectEnvironment() {
        // todo
        return 'main';
    }
    getProjectManageUrl() {
        return this.connector._getProjectManageUrl();
    }
    // todo make these custom error classes to be thrown from within
    // sync/create/publish/etc
    hasAccess() {
        return Promise.resolve({
            hasPermissions: true,
            hasConnection: true
        });
    }
    validateDocuments() {
        return Promise.resolve({ errors: [] });
    }
    // for now reset/destroy are not needed
    reset() {
        return Promise.resolve();
    }
    destroy() {
        return Promise.resolve();
    }
    async _getAPIPromises(name) {
        return this.connector.getAPIPromises(name);
    }
    async _getImplementation(name) {
        return this.connector.definedImplementations.get(name);
    }
    async init({ cache }) {
        this.integration.netlifyConnectPlugin?.setRuntimeSupportsCreate();
        // wait for Connects init to finish
        const { connect, create } = await this._getAPIPromises('init');
        await connect.promise;
        // send back the Create cache so the SDK can use it to insert & delete
        // documents/assets/etc
        create.resolve(cache);
    }
    async updateDocument(options) {
        const update = await this._getImplementation('documents.update');
        if (update) {
            return update(options);
        }
        throw new Error('connector.documents({ update: fn }) is not implemented');
    }
    async createDocument(options) {
        const create = await this._getImplementation('documents.create');
        if (create) {
            return create(options);
        }
        throw new Error('connector.documents({ create: fn }) is not implemented');
    }
    async deleteDocument(options) {
        const del = await this._getImplementation('documents.delete');
        if (del) {
            return del(options);
        }
        throw new Error('connector.documents({ delete: fn }) is not implemented');
    }
    async publishDocuments(options) {
        const publish = await this._getImplementation('documents.publish');
        if (publish) {
            return publish(options);
        }
        throw new Error('connector.documents({ publish: fn }) is not implemented');
    }
    async getSchema() {
        const models = await this.getModels();
        const locales = await this.getLocales();
        return {
            models: models || [],
            locales: locales || [],
            context: {}
        };
    }
    async getModels() {
        const { connect, create } = await this._getAPIPromises('model');
        const modelBuilder = await connect.promise;
        try {
            const models = modelBuilder.toCreateModels();
            return models;
        }
        catch (e) {
            create.reject(e);
        }
        finally {
            create.resolve();
        }
    }
    async getLocales() {
        return this.connector._getLocales();
    }
    async connectSyncFinished() {
        const { connect } = await this._getAPIPromises(`sync`);
        await connect.promise;
        return this.connector;
    }
    async getDocuments() {
        return (await this.connectSyncFinished()).restoreAllDocuments();
    }
    async getAssets() {
        return (await this.connectSyncFinished()).restoreAllAssets();
    }
    async uploadAsset(options) {
        //TODO
        return {
            id: '',
            type: 'asset',
            manageUrl: '',
            status: 'added',
            createdAt: '',
            updatedAt: '',
            fields: {},
            context: undefined
        };
    }
    async updateAsset(options) {
        throw new Error('connector.asset({ update: fn }) is not implemented');
    }
    getContentEngineConfig() {
        return {
            connector: 'unified-connector-test-connector',
            plugins: [
                {
                    resolve: 'unified-connector-test-connector',
                    options: this.options || {}
                }
            ]
        };
    }
    async onFilesChange({ updatedFiles }) {
        return {};
    }
}
//# sourceMappingURL=connector-wrapper.mjs.map