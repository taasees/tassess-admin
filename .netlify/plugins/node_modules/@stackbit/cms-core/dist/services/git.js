"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitService = void 0;
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const fs_extra_1 = __importDefault(require("fs-extra"));
const GIT_LOG_CHANGE_TYPES = {
    M: 'modified',
    A: 'added',
    D: 'deleted'
};
class GitService {
    constructor(options) {
        this.branchFetched = false;
        this.repoUrl = options.repoUrl;
        this.repoDir = options.repoDir;
        this.repoBranch = options.repoBranch;
        this.repoPublishBranch = options.repoPublishBranch;
        this.worker = options.worker;
        this.runCommand = options.runCommand;
        this.skipPush = options.skipPush;
        this.logger = options.logger.createLogger({ label: 'git' });
        this.userLogger = options.userLogger.createLogger({ label: 'git' });
        this.pullListeners = [];
        this.pushListeners = [];
    }
    getRepoUrl() {
        return this.repoUrl;
    }
    getRepoBranch() {
        return this.repoBranch;
    }
    getRepoPublishBranch() {
        return this.repoPublishBranch;
    }
    getRepoDir() {
        return this.repoDir;
    }
    addPullListener(listener) {
        this.pullListeners.push(listener);
    }
    removePullListener(listener) {
        this.pullListeners = this.pullListeners.filter((existingListener) => existingListener != listener);
    }
    async notifyPullListeners(options) {
        for (const listener of this.pullListeners) {
            try {
                await listener(options);
            }
            catch (err) {
                this.logger.error('Error invoking pull listener', { ...options, err });
            }
        }
    }
    addPushListener(listener) {
        this.pushListeners.push(listener);
    }
    removePushListener(listener) {
        this.pushListeners = this.pushListeners.filter((existingListener) => existingListener != listener);
    }
    async notifyPushListeners() {
        for (const listener of this.pushListeners) {
            try {
                await listener();
            }
            catch (err) {
                this.logger.error('Error invoking push listener', { err });
            }
        }
    }
    async commit(author, files) {
        const filePaths = lodash_1.default.map(files, 'filePath');
        this.logger.debug('Commit scheduled', filePaths);
        return this.worker.schedule(async () => {
            this.logger.debug('Commit running', filePaths);
            const message = files
                .reduce((messages, file) => {
                messages.push(`${path_1.default.parse(file.filePath).base}: ${file.description}`);
                return messages;
            }, [])
                .join('.\n');
            await this.runCommand('git', ['add', ...filePaths], { cwd: this.repoDir });
            await this.runCommand('git', ['commit', '--no-verify', '--author', `${author.name || author.email} <${author.email}>`, '-m', message], {
                cwd: this.repoDir
            }).catch((err) => { }); // don't fail if nothing to commit
            this.logger.debug('Commit done', filePaths);
        });
    }
    async push() {
        if (this.skipPush) {
            this.logger.debug('Push skipped...');
            return Promise.resolve();
        }
        this.logger.debug('Push scheduled');
        await this.worker.schedule(async () => {
            this.logger.debug('Push running');
            await this.runCommand('rm', ['-rf', '.git/rebase-merge'], { cwd: this.repoDir }).catch((err) => { }); // fixes leftover rebase directory with autostash
            await this.runCommand('git', ['pull', 'origin', this.repoBranch, '--rebase', '--autostash', '-Xtheirs'], { cwd: this.repoDir });
            await this.runCommand('git', ['push', '--no-verify', 'origin', this.repoBranch], { cwd: this.repoDir });
            this.logger.debug('Push done');
        });
        return this.notifyPushListeners();
    }
    async commitAndPush(author, files) {
        await this.commit(author, files);
        return this.push();
    }
    async pull(branch) {
        let updatedFiles = [];
        const pullBranch = branch ?? this.repoBranch;
        this.logger.debug('Pull scheduled', { pullBranch });
        await this.worker.schedule(async () => {
            this.logger.debug('Pull running', { pullBranch });
            await this.runCommand('git', ['fetch', '--no-write-fetch-head', 'origin'], { cwd: this.repoDir }).catch((err) => this.logger.error('Error fetching before pull', { err }));
            updatedFiles = await this.diffBranches(pullBranch, pullBranch);
            if (pullBranch === this.repoBranch) {
                await this.runCommand('git', ['pull', 'origin', '--rebase', '--autostash', '-Xtheirs'], { cwd: this.repoDir });
            }
            this.logger.debug('Pull done', { pullBranch });
        });
        await this.notifyPullListeners({ branch: pullBranch, updatedFiles });
    }
    async publishAll(author) {
        this.logger.debug('Publish all started');
        const publishDir = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        await this.runCommand('git', ['clone', this.repoUrl, '--branch', this.repoPublishBranch, publishDir]);
        try {
            await this.runCommand('git', ['merge', `origin/${this.repoBranch}`, this.repoPublishBranch, '-Xtheirs'], { cwd: publishDir });
            await this.runCommand('git', ['commit', '--author', `${author.name || author.email} <${author.email}>`, `-m`, 'Publish'], {
                cwd: publishDir
            }).catch(() => { });
            await this.runCommand('git', ['push', 'origin'], { cwd: publishDir });
        }
        finally {
            await fs_extra_1.default.remove(publishDir);
        }
        this.logger.debug('Publish all done');
    }
    async publishFiles(author, filePaths) {
        this.logger.debug('Publish files started', filePaths);
        const publishDir = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        await this.runCommand('git', ['clone', this.repoUrl, '--branch', this.repoPublishBranch, publishDir]);
        try {
            await this.runCommand('git', ['checkout', '-b', 'stackbit-publish-branch'], { cwd: publishDir });
            const filePathsToAdd = [];
            for (const filePath of filePaths) {
                const srcFilePath = path_1.default.join(this.repoDir, filePath);
                const destFilePath = path_1.default.join(publishDir, filePath);
                if (await fs_extra_1.default.pathExists(srcFilePath)) {
                    await fs_extra_1.default.ensureDir(path_1.default.dirname(destFilePath));
                    await fs_extra_1.default.copy(srcFilePath, destFilePath);
                    filePathsToAdd.push(filePath);
                }
                else if (await fs_extra_1.default.pathExists(destFilePath)) {
                    // remove file if it was deleted from preview branch but exists in publish branch
                    await this.runCommand('git', ['rm', filePath], { cwd: publishDir });
                }
            }
            await this.runCommand('git', ['add', '--ignore-errors', ...filePathsToAdd], { cwd: publishDir });
            await this.runCommand('git', ['commit', '--author', `${author.name || author.email} <${author.email}>`, '-m', 'Publish'], {
                cwd: publishDir
            }).catch((err) => {
                return;
            });
            await this.runCommand('git', ['checkout', this.repoBranch], { cwd: publishDir });
            await this.runCommand('git', ['merge', 'stackbit-publish-branch', this.repoBranch, '-Xtheirs'], { cwd: publishDir });
            await this.runCommand('git', ['checkout', this.repoPublishBranch], { cwd: publishDir });
            await this.runCommand('git', ['merge', 'stackbit-publish-branch', this.repoPublishBranch, '-Xtheirs'], { cwd: publishDir });
            await this.runCommand('git', ['push', 'origin', this.repoPublishBranch, this.repoBranch], { cwd: publishDir });
        }
        finally {
            await fs_extra_1.default.remove(publishDir);
        }
        this.logger.debug('Publish files done', filePaths);
    }
    publish(author, filePaths) {
        this.logger.debug('Publish scheduled');
        return this.worker.schedule(async () => {
            if (filePaths) {
                if (!filePaths.length) {
                    this.logger.debug('Nothing to publish');
                    return;
                }
                return this.publishFiles(author, filePaths);
            }
            else {
                return this.publishAll(author);
            }
        });
    }
    parseGitCommitAuthor(author) {
        if (!author) {
            return author;
        }
        const regex = /(.*)\((.*)\)/;
        const match = author.match(regex);
        if (match) {
            const [authorEmail, authorName] = match.slice(1);
            if (authorName === 'Stackbit Code Editor') {
                return 'stackbit';
            }
            return authorEmail ? authorEmail.toLowerCase() : author;
        }
        return author;
    }
    async diffBranches(fromBranch, toBranch) {
        const result = await this.runCommand('git', [
            'diff',
            '--name-only',
            '--no-renames',
            `origin/${toBranch}..${fromBranch}`
        ], { cwd: this.repoDir });
        return result.stdout.split('\n').filter(Boolean);
    }
    async diff() {
        this.logger.debug('Diff check scheduled');
        return this.worker.schedule(async () => {
            this.logger.debug('Diff check running');
            const result = await this.diffBranches(this.repoBranch, this.repoPublishBranch);
            this.logger.debug('Diff check done');
            return result;
        });
    }
    async commitLog() {
        this.logger.debug('Changes check scheduled');
        return this.worker.schedule(async () => {
            this.logger.debug('Changes check running');
            if (!this.branchFetched && this.repoPublishBranch !== this.repoBranch) {
                await this.runCommand('git', ['fetch', '--no-write-fetch-head', 'origin', `${this.repoPublishBranch}:${this.repoPublishBranch}`], {
                    cwd: this.repoDir
                });
                this.branchFetched = true;
            }
            const logResult = await this.runCommand('git', ['log', '--pretty=format:commit:%H%n%at%n%ae%x28%an%x29', '--name-status', `${this.repoPublishBranch}..${this.repoBranch}`], { cwd: this.repoDir });
            this.logger.debug('Changes check done');
            return logResult.stdout
                .split('commit:')
                .filter(Boolean)
                .map((rawCommit) => {
                const split = rawCommit.trim().split('\n');
                return {
                    author: this.parseGitCommitAuthor(split[2]),
                    timestamp: split[1] ? new Date(parseInt(split[1]) * 1000) : undefined,
                    commitHash: split[0],
                    changes: split
                        .slice(3)
                        .map((line) => line.trim().split(/\t/))
                        .filter(Boolean)
                        .filter(([status, filename, _]) => status && filename)
                        .map(([status, filename, auxFilename]) => {
                        const gitStatus = GIT_LOG_CHANGE_TYPES[status] || 'modified';
                        if (status?.startsWith('R100')) {
                            return {
                                status: gitStatus,
                                filePath: auxFilename,
                                fromFilePath: filename
                            };
                        }
                        return {
                            status: gitStatus,
                            filePath: filename
                        };
                    })
                };
            })
                .reverse();
        });
    }
}
exports.GitService = GitService;
//# sourceMappingURL=git.js.map