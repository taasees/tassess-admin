import _ from 'lodash';
import os from 'os';
import path from 'path';
import { v4 as uuid } from 'uuid';
import fse from 'fs-extra';

import {
    GitServiceInterface,
    GitServicePullListener,
    GitServicePushListener,
    GitFileCommitDescriptor,
    GitAuthor,
    GitCommitLogEntry,
    Logger
} from '@stackbit/types';
import { Worker } from '@stackbit/utils';

import { DocumentStatus } from '@stackbit/types';
import { CommandRunner } from '@stackbit/types';

const GIT_LOG_CHANGE_TYPES: Record<string, DocumentStatus> = {
    M: 'modified',
    A: 'added',
    D: 'deleted'
};

export class GitService implements GitServiceInterface {
    private readonly repoUrl: string;
    private readonly repoDir: string;
    private readonly repoBranch: string;
    private readonly repoPublishBranch: string;
    private readonly worker: Worker;
    private readonly runCommand: CommandRunner;
    private readonly logger: Logger;
    private readonly userLogger: Logger;
    private readonly skipPush?: boolean;
    private pullListeners: GitServicePullListener[];
    private pushListeners: GitServicePushListener[];

    private branchFetched: boolean = false;

    constructor(options: {
        repoUrl: string;
        repoDir: string;
        repoBranch: string;
        repoPublishBranch: string;
        worker: Worker;
        runCommand: CommandRunner;
        skipPush?: boolean;
        logger: Logger;
        userLogger: Logger;
    }) {
        this.repoUrl = options.repoUrl;
        this.repoDir = options.repoDir;
        this.repoBranch = options.repoBranch;
        this.repoPublishBranch = options.repoPublishBranch;
        this.worker = options.worker;
        this.runCommand = options.runCommand;
        this.skipPush = options.skipPush;
        this.logger = options.logger.createLogger({ label: 'git' });
        this.userLogger = options.userLogger.createLogger({ label: 'git' });

        this.pullListeners = [];
        this.pushListeners = [];
    }

    getRepoUrl() {
        return this.repoUrl;
    }

    getRepoBranch() {
        return this.repoBranch;
    }

    getRepoPublishBranch() {
        return this.repoPublishBranch;
    }

    getRepoDir() {
        return this.repoDir;
    }

    addPullListener(listener: GitServicePullListener) {
        this.pullListeners.push(listener);
    }

    removePullListener(listener: GitServicePullListener) {
        this.pullListeners = this.pullListeners.filter((existingListener) => existingListener != listener);
    }

    async notifyPullListeners(options: { branch: string; updatedFiles: string[] }) {
        for (const listener of this.pullListeners) {
            try {
                await listener(options);
            } catch (err) {
                this.logger.error('Error invoking pull listener', { ...options, err });
            }
        }
    }

    addPushListener(listener: GitServicePushListener) {
        this.pushListeners.push(listener);
    }

    removePushListener(listener: GitServicePushListener) {
        this.pushListeners = this.pushListeners.filter((existingListener) => existingListener != listener);
    }

    async notifyPushListeners() {
        for (const listener of this.pushListeners) {
            try {
                await listener();
            } catch (err) {
                this.logger.error('Error invoking push listener', { err });
            }
        }
    }

    private async commit(author: GitAuthor, files: GitFileCommitDescriptor[]) {
        const filePaths = _.map(files, 'filePath');
        this.logger.debug('Commit scheduled', filePaths);
        return this.worker.schedule(async () => {
            this.logger.debug('Commit running', filePaths);
            const message = files
                .reduce((messages: string[], file) => {
                    messages.push(`${path.parse(file.filePath).base}: ${file.description}`);
                    return messages;
                }, [])
                .join('.\n');
            await this.runCommand('git', ['add', ...filePaths], { cwd: this.repoDir });
            await this.runCommand('git', ['commit', '--no-verify', '--author', `${author.name || author.email} <${author.email}>`, '-m', message], {
                cwd: this.repoDir
            }).catch((err) => {}); // don't fail if nothing to commit
            this.logger.debug('Commit done', filePaths);
        });
    }

    private async push() {
        if (this.skipPush) {
            this.logger.debug('Push skipped...');
            return Promise.resolve();
        }
        this.logger.debug('Push scheduled');
        await this.worker.schedule(async () => {
            this.logger.debug('Push running');
            await this.runCommand('rm', ['-rf', '.git/rebase-merge'], { cwd: this.repoDir }).catch((err) => {}); // fixes leftover rebase directory with autostash
            await this.runCommand('git', ['pull', 'origin', this.repoBranch, '--rebase', '--autostash', '-Xtheirs'], { cwd: this.repoDir });
            await this.runCommand('git', ['push', '--no-verify', 'origin', this.repoBranch], { cwd: this.repoDir });
            this.logger.debug('Push done');
        });
        return this.notifyPushListeners();
    }

    async commitAndPush(author: GitAuthor, files: GitFileCommitDescriptor[]): Promise<void> {
        await this.commit(author, files);
        return this.push();
    }

    async pull(branch?: string): Promise<void> {
        let updatedFiles: string[] = [];
        const pullBranch = branch ?? this.repoBranch;
        this.logger.debug('Pull scheduled', { pullBranch });
        await this.worker.schedule(async () => {
            this.logger.debug('Pull running', { pullBranch });
            await this.runCommand('git', ['fetch', '--no-write-fetch-head', 'origin'], { cwd: this.repoDir }).catch((err) =>
                this.logger.error('Error fetching before pull', { err })
            );
            updatedFiles = await this.diffBranches(pullBranch, pullBranch);
            if (pullBranch === this.repoBranch) {
                await this.runCommand('git', ['pull', 'origin', '--rebase', '--autostash', '-Xtheirs'], { cwd: this.repoDir });
            }
            this.logger.debug('Pull done', { pullBranch });
        });
        await this.notifyPullListeners({ branch: pullBranch, updatedFiles });
    }

    private async publishAll(author: GitAuthor) {
        this.logger.debug('Publish all started');
        const publishDir = path.join(os.tmpdir(), uuid());
        await this.runCommand('git', ['clone', this.repoUrl, '--branch', this.repoPublishBranch, publishDir]);
        try {
            await this.runCommand('git', ['merge', `origin/${this.repoBranch}`, this.repoPublishBranch, '-Xtheirs'], { cwd: publishDir });
            await this.runCommand('git', ['commit', '--author', `${author.name || author.email} <${author.email}>`, `-m`, 'Publish'], {
                cwd: publishDir
            }).catch(() => {});
            await this.runCommand('git', ['push', 'origin'], { cwd: publishDir });
        } finally {
            await fse.remove(publishDir);
        }
        this.logger.debug('Publish all done');
    }

    private async publishFiles(author: GitAuthor, filePaths: string[]) {
        this.logger.debug('Publish files started', filePaths);
        const publishDir = path.join(os.tmpdir(), uuid());
        await this.runCommand('git', ['clone', this.repoUrl, '--branch', this.repoPublishBranch, publishDir]);
        try {
            await this.runCommand('git', ['checkout', '-b', 'stackbit-publish-branch'], { cwd: publishDir });

            const filePathsToAdd: string[] = [];
            for (const filePath of filePaths) {
                const srcFilePath = path.join(this.repoDir, filePath);
                const destFilePath = path.join(publishDir, filePath);
                if (await fse.pathExists(srcFilePath)) {
                    await fse.ensureDir(path.dirname(destFilePath));
                    await fse.copy(srcFilePath, destFilePath);
                    filePathsToAdd.push(filePath);
                } else if (await fse.pathExists(destFilePath)) {
                    // remove file if it was deleted from preview branch but exists in publish branch
                    await this.runCommand('git', ['rm', filePath], { cwd: publishDir });
                }
            }
            await this.runCommand('git', ['add', '--ignore-errors', ...filePathsToAdd], { cwd: publishDir });
            await this.runCommand('git', ['commit', '--author', `${author.name || author.email} <${author.email}>`, '-m', 'Publish'], {
                cwd: publishDir
            }).catch((err: any) => {
                return;
            });

            await this.runCommand('git', ['checkout', this.repoBranch], { cwd: publishDir });
            await this.runCommand('git', ['merge', 'stackbit-publish-branch', this.repoBranch, '-Xtheirs'], { cwd: publishDir });

            await this.runCommand('git', ['checkout', this.repoPublishBranch], { cwd: publishDir });
            await this.runCommand('git', ['merge', 'stackbit-publish-branch', this.repoPublishBranch, '-Xtheirs'], { cwd: publishDir });

            await this.runCommand('git', ['push', 'origin', this.repoPublishBranch, this.repoBranch], { cwd: publishDir });
        } finally {
            await fse.remove(publishDir);
        }
        this.logger.debug('Publish files done', filePaths);
    }

    publish(author: GitAuthor, filePaths?: string[]): Promise<void> {
        this.logger.debug('Publish scheduled');
        return this.worker.schedule(async () => {
            if (filePaths) {
                if (!filePaths.length) {
                    this.logger.debug('Nothing to publish');
                    return;
                }
                return this.publishFiles(author, filePaths);
            } else {
                return this.publishAll(author);
            }
        });
    }

    private parseGitCommitAuthor(author?: string) {
        if (!author) {
            return author;
        }
        const regex = /(.*)\((.*)\)/;
        const match = author.match(regex);
        if (match) {
            const [authorEmail, authorName] = match.slice(1);

            if (authorName === 'Stackbit Code Editor') {
                return 'stackbit';
            }
            return authorEmail ? authorEmail.toLowerCase() : author;
        }
        return author;
    }

    private async diffBranches(fromBranch: string, toBranch: string): Promise<string[]> {
        const result = await this.runCommand(
            'git',
            [
                'diff',
                '--name-only',
                '--no-renames', // this flag makes sure we get both old and new name of renamed file
                `origin/${toBranch}..${fromBranch}`
            ],
            { cwd: this.repoDir }
        );
        return result.stdout.split('\n').filter(Boolean);
    }

    async diff(): Promise<string[]> {
        this.logger.debug('Diff check scheduled');
        return this.worker.schedule(async () => {
            this.logger.debug('Diff check running');
            const result = await this.diffBranches(this.repoBranch, this.repoPublishBranch);
            this.logger.debug('Diff check done');
            return result;
        });
    }

    async commitLog(): Promise<GitCommitLogEntry[]> {
        this.logger.debug('Changes check scheduled');
        return this.worker.schedule(async () => {
            this.logger.debug('Changes check running');
            if (!this.branchFetched && this.repoPublishBranch !== this.repoBranch) {
                await this.runCommand('git', ['fetch', '--no-write-fetch-head', 'origin', `${this.repoPublishBranch}:${this.repoPublishBranch}`], {
                    cwd: this.repoDir
                });
                this.branchFetched = true;
            }
            const logResult = await this.runCommand(
                'git',
                ['log', '--pretty=format:commit:%H%n%at%n%ae%x28%an%x29', '--name-status', `${this.repoPublishBranch}..${this.repoBranch}`],
                { cwd: this.repoDir }
            );
            this.logger.debug('Changes check done');
            return logResult.stdout
                .split('commit:')
                .filter(Boolean)
                .map((rawCommit) => {
                    const split = rawCommit.trim().split('\n');
                    return {
                        author: this.parseGitCommitAuthor(split[2]),
                        timestamp: split[1] ? new Date(parseInt(split[1]) * 1000) : undefined,
                        commitHash: split[0],
                        changes: split
                            .slice(3)
                            .map((line) => line.trim().split(/\t/))
                            .filter(Boolean)
                            .filter(([status, filename, _]) => status && filename)
                            .map(([status, filename, auxFilename]) => {
                                const gitStatus = GIT_LOG_CHANGE_TYPES[status!] || 'modified';
                                if (status?.startsWith('R100')) {
                                    return {
                                        status: gitStatus,
                                        filePath: auxFilename,
                                        fromFilePath: filename
                                    };
                                }
                                return {
                                    status: gitStatus,
                                    filePath: filename
                                };
                            })
                    };
                })
                .reverse();
        });
    }
}
