import _ from 'lodash';
import { Config } from '@stackbit/sdk';
import * as StackbitTypes from '@stackbit/types';
import { mapPromise, omitByNil } from '@stackbit/utils';
import * as ContentStoreTypes from '../types';
import {
    CustomActionStateChange,
    APICustomAction,
    APICustomActionDocumentSpecifier,
    APIGetCustomActionRequest,
    APIRunCustomActionRequest,
    APIRunCustomActionRequestBulk,
    CustomActionRunStateMap,
    ExtendedCustomActionObjectModel,
    ExtendedCustomActionField,
    APICustomActionGlobal,
    APICustomActionBulk,
    ExtendedCustomAction,
    ExtendedCustomActionObjectField,
    ExtendedCustomActionDocument
} from '../types';
import { createConfigDelegate } from './config-delegate';
import { getContentSourceActionsForSourceThunk } from './document-hooks';
import { mapStoreDocumentToCSIDocumentWithSource, mapStoreFieldToCSIField } from './store-to-csi-docs-converter';
import { getModelAndDocumentFieldForLocalizedFieldPath } from './field-path-utils';
import { getContentSourceDataByTypeAndProjectIdOrThrow, getUserContextForSrcTypeThunk } from '../content-store-utils';
import { CustomActionBulk, CustomActionGlobal, CustomActionPermissions } from '@stackbit/types';

export async function getGlobalAndBulkAPIActions({
    stackbitConfig,
    customActionRunStateMap,
    contentSourceDataById,
    userLogger,
    pageUrl,
    user,
    locale,
    currentPageDocument
}: {
    stackbitConfig: Config | null;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    userLogger: StackbitTypes.Logger;
    pageUrl?: string;
    user?: ContentStoreTypes.User;
    locale?: string;
    currentPageDocument?: APICustomActionDocumentSpecifier;
}): Promise<(APICustomActionGlobal | APICustomActionBulk)[]> {
    if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
        return [];
    }

    const configDelegate = createConfigDelegate({
        contentSourceDataById: contentSourceDataById,
        logger: userLogger
    });

    return mapPromise(stackbitConfig.actions, async (action) => {
        const actionId = globalActionId(action);
        const actionRunState = customActionRunStateMap[actionId];
        let state: StackbitTypes.CustomActionState | 'unknown';
        const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
        const commonStateOptions: StackbitTypes.CustomActionStateCommonOptions = {
            actionId: actionId,
            currentLocale: locale,
            currentUser: user,
            currentPageUrl: pageUrl,
            currentPageDocument: pageDocument,
            ...configDelegate
        };

        if (actionRunState?.runningHandler) {
            state = 'running';
        } else if (action.state) {
            state = await action.state(commonStateOptions);
        } else {
            state = actionRunState?.lastResultState ?? 'enabled';
        }

        let permissionsResult;
        if (commonStateOptions.currentUser) {
            const commonPermissionsOptions: StackbitTypes.CustomActionPermissionsCommonOptions = {
                ..._.omit(commonStateOptions, ['currentUser']),
                userContext: commonStateOptions.currentUser
            };

            permissionsResult = resolveCustomActionPermissions({ action, commonPermissionsOptions, contentSourceDataById });
        }

        return omitByNil({
            type: action.type,
            actionId: actionId,
            name: action.name,
            label: action.label ?? _.startCase(action.name),
            icon: action.icon,
            state: state,
            inputFields: action.inputFields,
            hidden: action.hidden,
            permissions: permissionsResult
        });
    });
}

export async function resolveCustomActionsById({
    getActionRequest,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig,
    userLogger
}: {
    getActionRequest: APIGetCustomActionRequest;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
    userLogger: StackbitTypes.Logger;
}): Promise<APICustomAction[]> {
    const result: APICustomAction[] = [];
    const { customActionIds, locale, user, pageUrl, currentPageDocument } = getActionRequest;

    const configDelegate = createConfigDelegate({
        contentSourceDataById,
        logger: userLogger
    });

    for (const actionId of customActionIds) {
        const extendedAction = findCustomActionById({
            actionId,
            customActionRunStateMap,
            contentSourceDataById,
            stackbitConfig
        });
        if (!extendedAction) {
            userLogger.debug(`custom action with id: '${actionId}' was not found`);
            continue;
        }

        const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
        const commonStateOptions: StackbitTypes.CustomActionStateCommonOptions = {
            actionId: actionId,
            currentLocale: locale,
            currentUser: user,
            currentPageUrl: pageUrl,
            currentPageDocument: pageDocument,
            ...configDelegate
        };

        try {
            let state: StackbitTypes.CustomActionState;
            if (extendedAction.runningHandler) {
                state = 'running';
            } else if (extendedAction.state) {
                if (extendedAction.type === 'global' || extendedAction.type === 'bulk') {
                    state = await extendedAction.state(commonStateOptions);
                } else if (extendedAction.type === 'document') {
                    const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                        documentSpec: extendedAction.documentSpec,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        document: document,
                        model: model
                    });
                } else if (extendedAction.type === 'objectModel') {
                    const stateObjectParams = getHandlerParamsForObjectModelAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                } else if (extendedAction.type === 'objectField') {
                    const stateObjectParams = getHandlerParamsForObjectFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                } else if (extendedAction.type === 'field') {
                    const stateFieldParams = getHandlerParamsForFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateFieldParams
                    });
                } else {
                    const _exhaustiveCheck: never = extendedAction;
                    continue;
                }
            } else {
                state = extendedAction.lastResultState ?? 'enabled';
            }

            let permissionsResult;
            if (commonStateOptions.currentUser) {
                const commonPermissionsOptions: StackbitTypes.CustomActionPermissionsCommonOptions = {
                    ..._.omit(commonStateOptions, ['currentUser']),
                    userContext: commonStateOptions.currentUser
                };

                permissionsResult = resolveCustomActionPermissions({ action: extendedAction, commonPermissionsOptions, contentSourceDataById });
            }

            result.push(
                omitByNil({
                    actionId: actionId,
                    type: storeActionTypeToAPIActionType(extendedAction.type),
                    name: extendedAction.name,
                    label: extendedAction.label,
                    icon: extendedAction.icon,
                    state: state,
                    inputFields: extendedAction.inputFields,
                    hidden: extendedAction.hidden,
                    permissions: permissionsResult
                })
            );
        } catch (error: any) {
            userLogger.warn(`getCustomActionsById: error resolving custom action, id: '${actionId}', error: ${error.message}`);
        }
    }

    return result;
}

export function resolveCustomActionPermissions({
    action,
    commonPermissionsOptions,
    contentSourceDataById
}: {
    action:
        | CustomActionGlobal
        | CustomActionBulk
        | ExtendedCustomActionDocument
        | ExtendedCustomActionObjectModel
        | ExtendedCustomActionObjectField
        | ExtendedCustomActionField;
    commonPermissionsOptions: StackbitTypes.CustomActionPermissionsCommonOptions;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): CustomActionPermissions | undefined {
    if (typeof action?.permissions !== 'function' || !commonPermissionsOptions.userContext) {
        return undefined;
    }

    let document, model, stateParams;
    switch (action.type) {
        case 'global':
        case 'bulk':
            return action.permissions?.(commonPermissionsOptions);
        case 'document':
            ({ document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: action.documentSpec,
                contentSourceDataById
            }));
            return action.permissions?.({ ...commonPermissionsOptions, document, model });
        case 'objectModel':
            stateParams = getHandlerParamsForObjectModelAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
        case 'objectField':
            stateParams = getHandlerParamsForObjectFieldAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
        case 'field':
            stateParams = getHandlerParamsForFieldAction({
                extendedAction: action,
                contentSourceDataById
            });
            return action.permissions?.({ ...commonPermissionsOptions, ...stateParams });
    }
}

export function runCustomAction({
    runActionRequest,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig,
    userLogger
}: {
    runActionRequest: APIRunCustomActionRequest;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
    userLogger: StackbitTypes.Logger;
}): Promise<CustomActionStateChange> {
    const extendedAction = findCustomActionById({
        actionId: runActionRequest.actionId,
        customActionRunStateMap,
        contentSourceDataById,
        stackbitConfig
    });
    if (!extendedAction) {
        throw new Error(`Error running action: action not found, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    const prevResultState = extendedAction.lastResultState;
    if (extendedAction.lastResultState && extendedAction.lastResultState !== 'enabled') {
        throw new Error(
            `Error running action: action is not enabled, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`
        );
    }

    try {
        const actionLogger = userLogger.createLogger({ label: `action:${extendedAction.name}` });
        const configDelegate = createConfigDelegate({ contentSourceDataById: contentSourceDataById, logger: actionLogger });
        const currentPageDocument = getCSIDocumentWithSourceFromDocumentSpec(runActionRequest.currentPageDocument, configDelegate);

        customActionRunStateMap[runActionRequest.actionId] = {
            runningHandler: true,
            lastResultState: 'running'
        };

        const commonRunOptions: StackbitTypes.CustomActionRunCommonOptions = {
            actionId: extendedAction.actionId,
            inputData: runActionRequest.inputData,
            currentLocale: runActionRequest.locale,
            currentUser: runActionRequest.user,
            currentPageUrl: runActionRequest.pageUrl,
            currentPageDocument: currentPageDocument,
            getContentSourceActionsForSource: getContentSourceActionsForSourceThunk({
                getContentSourceDataById: () => contentSourceDataById,
                logger: userLogger,
                user: runActionRequest.user,
                stackbitConfig: stackbitConfig
            }),
            getUserContextForContentSourceType: getUserContextForSrcTypeThunk(runActionRequest.user),
            ...configDelegate
        };

        let promise: Promise<StackbitTypes.CustomActionResult | void>;

        if (extendedAction.type === 'global') {
            promise = extendedAction.run(commonRunOptions);
        } else if (extendedAction.type === 'bulk') {
            const documents = (runActionRequest as APIRunCustomActionRequestBulk).documents.map((documentSpec) => {
                const { document } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                    documentSpec,
                    contentSourceDataById
                });
                return document;
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                documents
            });
        } else if (extendedAction.type === 'document') {
            const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: extendedAction.documentSpec,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                document,
                model,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'objectModel') {
            const handlerObjectParams = getHandlerParamsForObjectModelAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'objectField') {
            const handlerObjectParams = getHandlerParamsForObjectFieldAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'field') {
            const handlerFieldParams = getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerFieldParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else {
            throw new Error(`action type ${(extendedAction as any).type} not supported`);
        }

        return promise
            .then((actionResult) => {
                customActionRunStateMap[runActionRequest.actionId] = {
                    runningHandler: false,
                    lastResultState: actionResult?.state
                };
                userLogger.debug(`Action completed: ${extendedAction.actionId}`);
                return Promise.resolve(
                    omitByNil({
                        actionId: extendedAction.actionId,
                        actionName: extendedAction.name,
                        actionType: storeActionTypeToAPIActionType(extendedAction.type),
                        // TODO: resolve the state if state function is defined
                        state: actionResult?.state ?? 'enabled',
                        success: actionResult?.success,
                        error: actionResult?.error,
                        result: actionResult?.result
                    })
                );
            })
            .catch((error: any) => {
                customActionRunStateMap[runActionRequest.actionId] = {
                    runningHandler: false,
                    lastResultState: prevResultState
                };
                userLogger.debug(`Error running action: ${error.message}`);
                return Promise.resolve({
                    actionId: extendedAction.actionId,
                    actionName: extendedAction.name,
                    actionType: storeActionTypeToAPIActionType(extendedAction.type),
                    // TODO: resolve the state if state function is defined
                    state: prevResultState ?? 'enabled',
                    error: `Error running action: ${error.message}`
                });
            });
    } catch (error: any) {
        if (customActionRunStateMap[runActionRequest.actionId]) {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
        }
        userLogger.debug(`Error running action: ${error.message}`);
        return Promise.resolve({
            actionId: runActionRequest.actionId,
            actionName: extendedAction?.name ?? runActionRequest.actionName,
            actionType: storeActionTypeToAPIActionType(extendedAction?.type) ?? runActionRequest.actionType,
            // TODO: resolve the state if state function is defined
            state: prevResultState ?? 'enabled',
            error: `Error running action: ${error.message}`
        });
    }
}

function getCSIDocumentWithSourceFromDocumentSpec(
    documentSpec: APICustomActionDocumentSpecifier | undefined,
    configDelegate: StackbitTypes.ConfigDelegate
): StackbitTypes.DocumentWithSource | undefined {
    return documentSpec
        ? configDelegate.getDocumentById({
              id: documentSpec.srcDocumentId,
              srcType: documentSpec.srcType,
              srcProjectId: documentSpec.srcProjectId
          })
        : undefined;
}

function getHandlerParamsForObjectModelAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionObjectModel, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionObjectModelStateParams {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });

    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }

    const documentField = fieldActionCommonParams.documentField as StackbitTypes.DocumentModelFieldNonLocalized;
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const objectModel = contentSourceData.modelMap[documentField.modelName];
    if (!objectModel || objectModel.type !== 'object') {
        throw new Error(`object model '${documentField.modelName}' not found`);
    }

    return {
        ...fieldActionCommonParams,
        documentField,
        modelField: fieldActionCommonParams.modelField as StackbitTypes.FieldModel,
        objectModel: {
            ...objectModel,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}

function getHandlerParamsForObjectFieldAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionObjectField, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionObjectFieldStateParams {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });

    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }

    return {
        ...fieldActionCommonParams,
        documentField: fieldActionCommonParams.documentField as StackbitTypes.DocumentObjectFieldNonLocalized,
        modelField: fieldActionCommonParams.modelField as StackbitTypes.FieldObject
    };
}

function getHandlerParamsForFieldAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionField, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionFieldStateParams {
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(
            `document not found for srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`
        );
    }

    const model = contentSourceData.modelMap[document.srcModelName];
    if (!model) {
        throw new Error(`model '${document.srcModelName}' not found`);
    }

    const mappedCSIDocument = mapStoreDocumentToCSIDocumentWithSource({ document, csiDocument });

    // the documentField should be localized because fieldPath includes locales
    const { modelField, documentField } = getModelAndDocumentFieldForLocalizedFieldPath({
        document,
        fieldPath: extendedAction.fieldPath,
        modelMap: contentSourceData.modelMap
    }) as {
        // list items cannot have actions, therefore we can safely reduce the type to non list item fields
        modelField: StackbitTypes.Field;
        documentField?: ContentStoreTypes.DocumentField;
    };

    const csiDocumentField = documentField ? mapStoreFieldToCSIField(documentField) : undefined;

    return {
        parentDocument: mappedCSIDocument,
        parentModel: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        },
        documentField: csiDocumentField,
        modelField: modelField,
        fieldPath: extendedAction.fieldPath
    };
}

function getCSIDocumentAndModelWithSourceFromDocumentSpec({
    documentSpec,
    contentSourceDataById
}: {
    documentSpec: APICustomActionDocumentSpecifier;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): {
    document: StackbitTypes.DocumentWithSource;
    model: StackbitTypes.ModelWithSource;
} {
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(
            `document not found, srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`
        );
    }
    const mappedDocument = mapStoreDocumentToCSIDocumentWithSource({
        document,
        csiDocument
    });
    const model = contentSourceData.modelMap[mappedDocument.modelName];
    if (!model) {
        throw new Error(`model '${mappedDocument.modelName}' not found`);
    }
    return {
        document: mappedDocument,
        model: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}

function storeActionTypeToAPIActionType(storeActionType: ExtendedCustomAction['type']): APICustomAction['type'] {
    if (storeActionType === 'objectModel' || storeActionType === 'objectField') {
        return 'object';
    }
    return storeActionType;
}

function findCustomActionById({
    actionId,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig
}: {
    actionId: string;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
}): ExtendedCustomAction | undefined {
    const actionRunState = customActionRunStateMap[actionId];
    if (isGlobalActionId(actionId)) {
        if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
            return undefined;
        }
        const actionName = getGlobalActionNameFromId(actionId);
        const action = stackbitConfig.actions.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            ...action,
            actionId,
            label: action.label ?? _.startCase(action.name),
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    }
    const { srcType, srcProjectId, srcDocumentId, actionName, fieldPath } = parseActionId(actionId) ?? {};
    if (!srcType || !srcProjectId || !srcDocumentId || !actionName) {
        return undefined;
    }
    const documentSpec: APICustomActionDocumentSpecifier = { srcType, srcProjectId, srcDocumentId };
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(srcType, srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[srcDocumentId];
    if (!document) {
        return undefined;
    }
    const modelName = document.srcModelName;
    const model = contentSourceData.modelMap[modelName];
    // The model of a document is always 'page' or 'data',
    // this condition helps TS to infer the right type of model.actions
    if (!model || (model.type !== 'page' && model.type !== 'data')) {
        return undefined;
    }
    if (typeof fieldPath === 'undefined') {
        // fieldPath was not provided, therefore the model must be of type "page" or "data",
        // and the action type must be 'document'
        const action = model.actions?.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId,
            label: action.label ?? _.startCase(action.name),
            documentSpec,
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    } else {
        const { modelField, documentField } = getModelAndDocumentFieldForLocalizedFieldPath({
            document,
            fieldPath,
            modelMap: contentSourceData.modelMap
        });

        if ('actions' in modelField && Array.isArray(modelField.actions)) {
            const action = modelField.actions.find((action) => action.name === actionName);
            if (action) {
                return {
                    // if configuration is updated, the new action properties will override the stored action properties
                    ...action,
                    type: action.type === 'object' ? 'objectField' : 'field',
                    actionId,
                    label: action.label ?? _.startCase(action.name),
                    documentSpec,
                    fieldPath,
                    runningHandler: actionRunState?.runningHandler,
                    lastResultState: actionRunState?.lastResultState
                } as ExtendedCustomActionField | ExtendedCustomActionObjectField;
            }
        }

        if (modelField.type === 'model') {
            if (!documentField || documentField.type !== 'model' || documentField.localized || documentField.isUnset) {
                return undefined;
            }
            const modelName = documentField.srcModelName;
            const model = contentSourceData.modelMap[modelName];
            if (!model || model.type !== 'object') {
                return undefined;
            }
            if (!('actions' in model && Array.isArray(model.actions))) {
                return undefined;
            }
            // This is a nested model of type "object", so the action must be CustomActionObjectModel
            const action = model.actions.find((action) => action.name === actionName);
            if (!action) {
                return undefined;
            }
            return {
                // if configuration is updated, the new action properties will override the stored action properties
                ...action,
                type: 'objectModel',
                actionId,
                label: action.label ?? _.startCase(action.name),
                documentSpec,
                fieldPath,
                runningHandler: actionRunState?.runningHandler,
                lastResultState: actionRunState?.lastResultState
            };
        }
    }
}

function globalActionId(action: StackbitTypes.CustomActionGlobal | StackbitTypes.CustomActionBulk): string {
    return `config.actions.${action.name}`;
}

function isGlobalActionId(actionId: string) {
    return actionId.startsWith('config.actions.');
}

function getGlobalActionNameFromId(actionId: string) {
    return actionId.substring('config.actions.'.length);
}

function parseActionId(actionId: string):
    | {
          srcType?: string;
          srcProjectId?: string;
          srcDocumentId?: string;
          actionName?: string;
          fieldPath?: string[];
      }
    | undefined {
    try {
        return JSON.parse(actionId);
    } catch (e) {
        return undefined;
    }
}
