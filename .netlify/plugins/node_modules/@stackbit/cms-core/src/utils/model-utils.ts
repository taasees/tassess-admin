import _ from 'lodash';
import { FieldCrossReferenceModel, Logger, ModelWithSource, CustomActionField, CustomActionObjectField } from '@stackbit/types';
import {
    Model,
    assignLabelFieldIfNeeded,
    isObjectField,
    isCrossReferenceField,
    isPageModel,
    mapModelFieldsRecursively,
    mapListItemsPropsOrSelfSpecificProps,
    validateConfig
} from '@stackbit/sdk';

export function normalizeModels({ models, logger }: { models: ModelWithSource[]; logger: Logger }): ModelWithSource[] {
    return models.map((model) => {
        model = { ...model };

        if (!('name' in model)) {
            logger.warn('model does not have a name');
        }

        if (!('type' in model)) {
            logger.warn(`model '${model['name']}' does not have a type, using 'object'`);
            _.set(model, 'type', 'object');
        }

        // add model label if not set
        if (!('label' in model)) {
            model.label = _.startCase(model.name);
        }

        if (!('fields' in model) || !Array.isArray(model.fields)) {
            model.fields = [];
        }

        if (isPageModel(model)) {
            // set default urlPath if not set
            if (!model.urlPath) {
                model.urlPath = '/{slug}';
            }
        }

        assignLabelFieldIfNeeded(model);

        if ((model.type === 'data' || model.type === 'page') && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: 'document'
            }));
        } else if (model.type === 'object' && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: 'object'
            }));
        }

        model = mapModelFieldsRecursively(model, (field) => {
            field = { ...field };

            if (!('label' in field)) {
                field.label = _.startCase(field.name);
            }

            if (field.actions) {
                field.actions = field.actions.map((action) => ({
                    ...action,
                    type: action.type ?? 'field'
                })) as (CustomActionField | CustomActionObjectField)[];
            }

            mapListItemsPropsOrSelfSpecificProps(field, (listItemsPropsOrField) => {
                if (isObjectField(listItemsPropsOrField)) {
                    assignLabelFieldIfNeeded(listItemsPropsOrField);
                } else if (isCrossReferenceField(listItemsPropsOrField)) {
                    listItemsPropsOrField.models = validateAndNormalizeCrossReferenceModels({
                        crossReferenceModels: listItemsPropsOrField.models,
                        models,
                        logger
                    });
                }
                return listItemsPropsOrField;
            });

            return field;
        });

        return model;
    });
}

function validateAndNormalizeCrossReferenceModels({
    crossReferenceModels,
    models,
    logger
}: {
    crossReferenceModels: FieldCrossReferenceModel[];
    models: ModelWithSource[];
    logger: Logger;
}): FieldCrossReferenceModel[] {
    const modelGroupsByModelName = models.reduce((modelGroups: Record<string, ModelWithSource[]>, model) => {
        if (!(model.name in modelGroups)) {
            modelGroups[model.name] = [];
        }
        modelGroups[model.name]!.push(model);
        return modelGroups;
    }, {});

    // Match cross-reference models to the group of content source models with
    // the same name. Then, match the cross-reference model to content source
    // model by comparing srcType and srcProjectId. If after the comparison,
    // there are more than one model left, log a warning and filter out that
    // cross-reference model so it won't cause any model ambiguity.
    const nonMatchedCrossReferenceModels: {
        crossReferenceModel: FieldCrossReferenceModel;
        matchedModels: ModelWithSource[];
    }[] = [];

    const normalizedCrossReferenceModels = crossReferenceModels.reduce((matchedCrossReferenceModels: FieldCrossReferenceModel[], crossReferenceModel) => {
        const models = modelGroupsByModelName[crossReferenceModel.modelName];
        if (!models) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels: [] });
            return matchedCrossReferenceModels;
        }
        const matchedModels = models.filter((model) => {
            const matchesType = !crossReferenceModel.srcType || model.srcType === crossReferenceModel.srcType;
            const matchesId = !crossReferenceModel.srcProjectId || model.srcProjectId === crossReferenceModel.srcProjectId;
            return matchesType && matchesId;
        });
        if (matchedModels.length !== 1) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels });
            return matchedCrossReferenceModels;
        }
        const matchedModel = matchedModels[0]!;
        matchedCrossReferenceModels.push({
            modelName: crossReferenceModel.modelName,
            srcType: matchedModel.srcType,
            srcProjectId: matchedModel.srcProjectId
        });
        return matchedCrossReferenceModels;
    }, []);

    // Log model matching warnings using user logger
    for (const { crossReferenceModel, matchedModels } of nonMatchedCrossReferenceModels) {
        let message = `a model of cross-reference field: '${crossReferenceModel.modelName}'`;
        if (crossReferenceModel.srcType) {
            message += `, srcType: '${crossReferenceModel.srcType}'`;
        }
        if (crossReferenceModel.srcProjectId) {
            message += `, srcProjectId: '${crossReferenceModel.srcProjectId}'`;
        }
        message = message + ` defined in stackbit config`;
        let contentSourceModelsMessage;
        if (matchedModels.length) {
            const matchesModelsMessage = matchedModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
            contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
        } else {
            contentSourceModelsMessage = ' does not match any content source model';
        }
        logger.warn(message + contentSourceModelsMessage);
    }

    return normalizedCrossReferenceModels;
}

export function validateModels<T extends Model>({ models, logger }: { models: T[]; logger: Logger }): T[] {
    const { config, errors } = validateConfig({
        stackbitVersion: '0.5.0',
        models: models,
        dirPath: '.',
        filePath: 'stackbit.config.js'
    });

    for (const error of errors) {
        logger.warn(error.message);
    }

    return config.models as T[];
}

export function getModelMap<T extends Model>({ models }: { models: T[] }): Record<string, T> {
    return models.reduce((res, model) => {
        res[model.name] = model;
        return res;
    }, {} as Record<string, T>);
}
