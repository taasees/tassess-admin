import { NetlifyIntegration } from '@netlify/sdk';
import {
    Asset,
    ContentChanges,
    ContentEngineConfig,
    ContentSourceInterface,
    Document,
    Model,
    UpdateOperation,
    UpdateOperationField,
    UserSSOProfile
} from '@stackbit/types';

export default class ConnectorWrapper implements ContentSourceInterface {
    private integration: NetlifyIntegration;
    private options: any;
    private connector: any;

    constructor({ integration, config }: { integration: NetlifyIntegration; config: any }) {
        this.integration = integration;
        this.options = config;
        this.connector = integration.netlifyConnectPlugin;
    }

    getContentSourceType() {
        // todo
        return 'todo';
    }

    getProjectId() {
        // todo
        return '1';
    }

    async getVersion() {
        return { interfaceVersion: '0.7.3', contentSourceVersion: '0.1' };
    }

    getProjectEnvironment() {
        // todo
        return 'main';
    }

    getProjectManageUrl() {
        return this.connector._getProjectManageUrl();
    }

    // todo make these custom error classes to be thrown from within
    // sync/create/publish/etc
    hasAccess() {
        return Promise.resolve({
            hasPermissions: true,
            hasConnection: true
        });
    }

    validateDocuments() {
        return Promise.resolve({ errors: [] });
    }

    // for now reset/destroy are not needed
    reset() {
        return Promise.resolve();
    }

    destroy() {
        return Promise.resolve();
    }

    async _getAPIPromises(name: string) {
        return this.connector.getAPIPromises(name);
    }

    async _getImplementation(name: string) {
        return this.connector.definedImplementations.get(name);
    }

    async init({ cache }: { cache: any }) {
        this.integration.netlifyConnectPlugin?.setRuntimeSupportsCreate();
        // wait for Connects init to finish
        const { connect, create } = await this._getAPIPromises('init');
        await connect.promise;
        // send back the Create cache so the SDK can use it to insert & delete
        // documents/assets/etc
        create.resolve(cache);
    }

    async updateDocument(options: {
        document: Document<unknown>;
        operations: UpdateOperation[];
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<void> {
        const update = await this._getImplementation('documents.update');
        if (update) {
            return update(options);
        }
        throw new Error('connector.documents({ update: fn }) is not implemented');
    }

    async createDocument(options: {
        updateOperationFields: Record<string, UpdateOperationField>;
        model: Model<unknown>;
        locale?: string | undefined;
        defaultLocaleDocumentId?: string | undefined;
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<{ documentId: string }> {
        const create = await this._getImplementation('documents.create');
        if (create) {
            return create(options);
        }
        throw new Error('connector.documents({ create: fn }) is not implemented');
    }

    async deleteDocument(options: {
        document: Document<unknown>;
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<void> {
        const del = await this._getImplementation('documents.delete');
        if (del) {
            return del(options);
        }
        throw new Error('connector.documents({ delete: fn }) is not implemented');
    }

    async publishDocuments(options: {
        documents: Document<unknown>[];
        assets: Asset<unknown>[];
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<void> {
        const publish = await this._getImplementation('documents.publish');
        if (publish) {
            return publish(options);
        }
        throw new Error('connector.documents({ publish: fn }) is not implemented');
    }

    async getSchema() {
        const models = await this.getModels();
        const locales = await this.getLocales();
        return {
            models: models || [],
            locales: locales || [],
            context: {}
        };
    }

    async getModels() {
        const { connect, create } = await this._getAPIPromises('model');
        const modelBuilder = await connect.promise;
        try {
            const models = modelBuilder.toCreateModels();
            return models;
        } catch (e) {
            create.reject(e);
        } finally {
            create.resolve();
        }
    }

    async getLocales() {
        return this.connector._getLocales();
    }

    async connectSyncFinished() {
        const { connect } = await this._getAPIPromises(`sync`);
        await connect.promise;
        return this.connector;
    }

    async getDocuments(): Promise<Document<unknown>[]> {
        return (await this.connectSyncFinished()).restoreAllDocuments();
    }

    async getAssets(): Promise<Asset<unknown>[]> {
        return (await this.connectSyncFinished()).restoreAllAssets();
    }

    async uploadAsset(options: {
        url?: string | undefined;
        base64?: string | undefined;
        fileName: string;
        mimeType: string;
        locale?: string | undefined;
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<Asset<unknown>> {
        //TODO
        return {
            id: '',
            type: 'asset',
            manageUrl: '',
            status: 'added',
            createdAt: '',
            updatedAt: '',
            fields: {},
            context: undefined
        } as Asset<unknown>;
    }

    async updateAsset(options: {
        asset: Asset<unknown>;
        operations: UpdateOperation[];
        userContext?: { name: string; email: string; sso?: UserSSOProfile | undefined } | undefined;
    }): Promise<void> {
        throw new Error('connector.asset({ update: fn }) is not implemented');
    }

    getContentEngineConfig(): ContentEngineConfig {
        return {
            connector: 'unified-connector-test-connector', //TODO
            plugins: [
                {
                    resolve: 'unified-connector-test-connector', //TODO
                    options: this.options || {}
                }
            ]
        };
    }

    async onFilesChange({
        updatedFiles
    }: {
        updatedFiles: string[];
    }): Promise<{ invalidateSchema?: boolean | undefined; contentChanges?: ContentChanges<unknown, unknown> | undefined }> {
        return {};
    }
}
