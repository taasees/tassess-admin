"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunkArray = exports.fetchScheduledActions = exports.fetchUsers = exports.fetchDocumentForRevision = exports.fetchDocumentRevision = exports.fetchDocumentsHistory = exports.testToken = exports.SanityClient = void 0;
const https_1 = __importDefault(require("https"));
const lodash_1 = __importDefault(require("lodash"));
const sanity_document_converter_1 = require("./sanity-document-converter");
var client_1 = require("@sanity/client");
Object.defineProperty(exports, "SanityClient", { enumerable: true, get: function () { return __importDefault(client_1).default; } });
async function testToken(apiToken) {
    return new Promise((resolve, reject) => {
        let output = '';
        const req = https_1.default.request({
            hostname: 'api.sanity.io',
            path: `/v1/auth/oauth/tokens/${apiToken}`,
            method: 'GET'
        }, (res) => {
            res.setEncoding('utf8');
            res.on('data', (chunk) => {
                output += chunk;
            });
            res.on('end', () => {
                let response = null;
                try {
                    response = JSON.parse(output);
                }
                catch (error) {
                    reject(error);
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(response);
                    return;
                }
                resolve(response);
            });
        });
        req.on('error', (error) => {
            reject(error);
        });
        req.end();
    });
}
exports.testToken = testToken;
async function fetchDocumentsHistory({ documentIds, dataset, client, limitTime = true }) {
    if (!documentIds.length) {
        return [];
    }
    // max size of one request to Sanity is 32Kb
    // Sanity response: AssertionError [ERR_ASSERTION]: Your message must be < 32kb.
    // it's undocumented, so 11Kb is query limit - https://www.sanity.io/docs/http-query, hence stick to that
    const chunkedDocumentIds = chunkArray(documentIds, 11000);
    const result = [];
    for (const idsChunk of chunkedDocumentIds) {
        const searchParams = new URLSearchParams();
        searchParams.append('excludeContent', 'true');
        searchParams.append('reverse', 'true');
        if (limitTime) {
            // get docs history from last 30 days
            searchParams.append('fromTime', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());
        }
        const data = await client.request({
            uri: `data/history/${dataset}/transactions/${idsChunk.join(',')}?${searchParams.toString()}`
        });
        for (const line of data.split('\n')) {
            if (line) {
                result.push(JSON.parse(line));
            }
        }
    }
    return result;
}
exports.fetchDocumentsHistory = fetchDocumentsHistory;
async function fetchDocumentRevision({ documentId, draftDocumentId, versionId, dataset, client }) {
    const searchParams = new URLSearchParams();
    searchParams.append('excludeContent', 'true');
    searchParams.append('fromTransaction', versionId);
    searchParams.append('toTransaction', versionId);
    const documentIds = [documentId, draftDocumentId];
    const data = await client.request({
        uri: `data/history/${dataset}/transactions/${documentIds.join(',')}?${searchParams.toString()}`
    });
    return JSON.parse(data);
}
exports.fetchDocumentRevision = fetchDocumentRevision;
async function fetchDocumentForRevision({ documentId, draftDocumentId, versionId, dataset, client }) {
    const documentIds = [documentId, draftDocumentId];
    const data = await client.request({
        uri: `data/history/${dataset}/documents/${documentIds.join(',')}?revision=${versionId}`
    });
    // take either latest draft revision object, or latest object
    return data.documents.find((object) => (0, sanity_document_converter_1.isDraftId)(object._id)) ?? data.documents[data.documents.length - 1];
}
exports.fetchDocumentForRevision = fetchDocumentForRevision;
async function fetchUsers(userIds, client) {
    const chunkedDocumentIds = chunkArray(userIds, 11000);
    const result = [];
    for (const idsChunk of chunkedDocumentIds) {
        const data = await client.request({
            uri: `users/${idsChunk.join(',')}`
        });
        // sanity respond differently for one user and multiple users
        // users/p-3vin4nyLUym1 => { 'id': 'p-3vin4nyLUym1', displayName: ... }
        // users/p-3vin4nyLUym1,p12Yq4phv => [{ 'id': 'p-3vin4nyLUym1', displayName: ... }, { 'id': 'p12Yq4phv', displayName: ... }]
        result.push(...(lodash_1.default.isArray(data) ? data : [data]));
    }
    return result;
}
exports.fetchUsers = fetchUsers;
async function fetchScheduledActions(opts, client, filters) {
    const uri = `/schedules/${opts.projectId}/${opts.dataset}`;
    const result = await client.request({ method: 'GET', uri: uri, query: filters });
    return result?.schedules ?? [];
}
exports.fetchScheduledActions = fetchScheduledActions;
function chunkArray(arr, maxChunkLength) {
    const chunks = [];
    let currentChunkLength = 0;
    let currentChunk = [];
    for (const [index, val] of arr.entries()) {
        if (val.length + currentChunkLength >= maxChunkLength) {
            if (currentChunk.length) {
                chunks.push(currentChunk);
            }
            currentChunkLength = val.length;
            currentChunk = [val];
        }
        else {
            currentChunk.push(val);
            currentChunkLength += val.length + 1; // for comma
        }
        if (arr.length === index + 1) {
            chunks.push(currentChunk);
        }
    }
    return chunks.length ? chunks : [arr];
}
exports.chunkArray = chunkArray;
//# sourceMappingURL=sanity-api-client.js.map