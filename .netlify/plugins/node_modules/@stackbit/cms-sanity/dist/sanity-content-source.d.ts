import { SanityClient as SanityClientType } from '@sanity/client';
import type * as ContentSourceTypes from '@stackbit/types';
import type { DocumentVersion, DocumentVersionWithDocument, Model, Schema } from '@stackbit/types';
import type * as SanityTypes from '@sanity/types';
import { DocumentHistoryMap } from './sanity-api-client';
import { ModelContext, SchemaContext } from './sanity-schema-converter';
import { AssetContext, ContextualAsset, ContextualDocument, ConvertDocumentsOptions, DocumentContext } from './sanity-document-converter';
export interface ContentSourceOptions {
    /**
     * The root path of the project. Used to resolve relative paths.
     */
    rootPath: string;
    /**
     * Sanity project id
     */
    projectId: string;
    /**
     * Sanity token with access to the project.
     * For local development, use a token with read and write access.
     */
    token: string;
    /**
     * Sanity dataset name. For exampe: 'production'
     */
    dataset: string;
    /**
     * Sanity studio url. Used for deep linking to documents.
     */
    studioUrl: string;
    /**
     * Sanity studio path. For example: 'studio'.
     * Usually the directory that contains your Sanity config file.
     */
    studioPath?: string;
    /**
     * The command to use to install the Sanity studio. For example: 'npm install'.
     * By default we detect the package manager and use it to install the studio.
     */
    studioInstallCommand?: string;
    /**
     * Glob pattern for Sanity schema files. Used to determine when a file changed schema has changed.
     */
    schemaGlob?: string;
    /**
     * Sanity query used to listen for document changes. For example: '*[!(_id in path("_.**"))]'
     */
    sanityQuery?: string;
    /**
     * The content change listener visibility. Defaults to 'transaction'.
     * 'transaction' - the listener will be notified of changes after the transaction is committed (fastest).
     * 'query' - the listener will be notified of changes when they are available for querying.
     */
    listenerVisibility?: 'transaction' | 'query';
    /**
     * When using Sanity Internationalized-Array plugin, specify the default language
     * that will be used by the Visual Editor. If not specified, the first language
     * in the `languages` will be selected.
     *
     * https://www.sanity.io/plugins/internationalized-array
     */
    defaultLocale?: string;
}
export type UserContext = {
    accessToken: string;
};
export type ContextualInitOptions = ContentSourceTypes.InitOptions<SchemaContext, DocumentContext, AssetContext, ModelContext>;
export type CacheWithContext = ContentSourceTypes.Cache<SchemaContext, DocumentContext, AssetContext, ModelContext>;
export declare class SanityContentSource implements ContentSourceTypes.ContentSourceInterface<UserContext, SchemaContext, DocumentContext, AssetContext, ModelContext> {
    private readonly projectId;
    private readonly dataset;
    private readonly token;
    private readonly studioPath?;
    private readonly studioInstallCommand?;
    private readonly schemaGlob?;
    private readonly studioUrl;
    private readonly sanityQuery;
    private readonly rootPath;
    private readonly listenerVisibility?;
    logger: ContentSourceTypes.Logger;
    userLogger: ContentSourceTypes.Logger;
    private localDev;
    private runCommand;
    private userCommandSpawner?;
    private client;
    private contentChangeSubscription;
    private contentChangeSubscriptionInterval;
    private userMap;
    private cache;
    private defaultLocale?;
    constructor(options: ContentSourceOptions);
    getVersion(): Promise<ContentSourceTypes.Version>;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    init({ logger, userLogger, localDev, runCommand, userCommandSpawner, cache }: ContextualInitOptions): Promise<void>;
    reset(): Promise<void>;
    destroy(): Promise<void>;
    validateConfig(): Promise<void>;
    installStudio(): Promise<void>;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    private convertListenerResult;
    private convertVersionsFromDocumentHistory;
    private convertVersionForDocument;
    getSanitySchema(): Promise<{
        models: SanityTypes.SchemaTypeDefinition[];
    }>;
    getSchema(): Promise<Schema<SchemaContext, ModelContext>>;
    getDocumentsHistory(documentIds: string[]): Promise<DocumentHistoryMap>;
    convertDocuments(options: ConvertDocumentsOptions): ContextualDocument[];
    getDocuments(): Promise<ContextualDocument[]>;
    getAssets(): Promise<ContextualAsset[]>;
    hasAccess({ userContext }: {
        userContext?: UserContext;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    onFilesChange({ updatedFiles }: {
        updatedFiles: string[];
    }): Promise<{
        invalidateSchema: boolean;
    }>;
    createDocument({ updateOperationFields, model, locale, userContext }: {
        updateOperationFields: Record<string, ContentSourceTypes.UpdateOperationField>;
        model: Model<ModelContext>;
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        documentId: string;
    }>;
    updateDocument({ document, operations, userContext }: {
        document: ContextualDocument;
        operations: ContentSourceTypes.UpdateOperation[];
        userContext?: UserContext;
    }): Promise<void>;
    deleteDocument({ document, userContext }: {
        document: ContextualDocument;
        userContext?: UserContext;
    }): Promise<void>;
    uploadAsset({ url, base64, fileName, mimeType, userContext }: {
        url?: string;
        base64?: string;
        fileName: string;
        mimeType: string;
        userContext?: UserContext;
    }): Promise<ContextualAsset>;
    validateDocuments({ documents, assets, locale, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        errors: ContentSourceTypes.ValidationError[];
    }>;
    publishDocuments({ documents, assets, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        userContext?: UserContext;
    }): Promise<void>;
    getScheduledActions(): Promise<ContentSourceTypes.ScheduledAction[]>;
    createScheduledAction({ documentIds, name, action, executeAt, userContext }: {
        documentIds: string[];
        name: string;
        action: ContentSourceTypes.ScheduledActionActionType;
        executeAt: string;
        userContext?: UserContext;
    }): Promise<{
        newScheduledActionId: string;
    }>;
    cancelScheduledAction({ scheduledActionId, userContext }: {
        scheduledActionId: string;
        userContext?: UserContext;
    }): Promise<{
        cancelledScheduledActionId: string;
    }>;
    updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext }: {
        scheduledActionId: string;
        documentIds?: string[];
        name?: string;
        executeAt?: string;
        userContext?: UserContext;
    }): Promise<{
        updatedScheduledActionId: string;
    }>;
    getApiClientForUser({ userContext }: {
        userContext?: UserContext;
    }): SanityClientType;
    getDocumentVersions({ documentId }: {
        documentId: string;
    }): Promise<{
        versions: DocumentVersion[];
    }>;
    getDocumentForVersion({ documentId, versionId }: {
        documentId: string;
        versionId: string;
    }): Promise<{
        version: DocumentVersionWithDocument;
    }>;
}
//# sourceMappingURL=sanity-content-source.d.ts.map