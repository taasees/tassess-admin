"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeIsPrimitive = exports.getItemTypeForListItem = exports.isLocalizedModelField = exports.resolvedFieldType = exports.getSanityAliasFieldType = exports.resolveLabelFieldForModel = void 0;
const lodash_1 = __importDefault(require("lodash"));
function resolveLabelFieldForModel(model, modelLabelFieldPath, fields) {
    let labelField = lodash_1.default.get(model, modelLabelFieldPath, null);
    if (labelField) {
        return labelField;
    }
    // see if there is a field named 'title'
    let titleField = lodash_1.default.find(fields, (field) => field.name === 'title' && ['string', 'text'].includes(field.type));
    if (!titleField) {
        // see if there is a field named 'label'
        titleField = lodash_1.default.find(fields, (field) => field.name === 'label' && ['string', 'text'].includes(field.type));
    }
    if (!titleField) {
        // get the first 'string' field
        titleField = lodash_1.default.find(fields, { type: 'string' });
    }
    if (titleField) {
        labelField = lodash_1.default.get(titleField, 'name');
    }
    return labelField || null;
}
exports.resolveLabelFieldForModel = resolveLabelFieldForModel;
function getSanityAliasFieldType({ resolvedType, model, modelFieldPath }) {
    const fieldAlias = model.context?.fieldAliasMap?.[modelFieldPath.join('.')] ?? [];
    return fieldAlias?.find((alias) => alias.resolvedTypeName === resolvedType)?.origTypeName ?? resolvedType;
}
exports.getSanityAliasFieldType = getSanityAliasFieldType;
function resolvedFieldType({ sanityFieldType, model, modelFieldPath }) {
    const fieldAlias = model.context?.fieldAliasMap?.[modelFieldPath.join('.')] ?? [];
    return fieldAlias?.find((alias) => alias.origTypeName === sanityFieldType)?.resolvedTypeName ?? sanityFieldType;
}
exports.resolvedFieldType = resolvedFieldType;
function isLocalizedModelField(modelField) {
    return 'localized' in modelField && modelField.localized;
}
exports.isLocalizedModelField = isLocalizedModelField;
/**
 * Sanity 'Array' field type can hold multiple field types.
 *
 * For example, Sanity Arrays can simultaneously include items of `model`
 * and `reference` types. https://www.sanity.io/docs/array-type#wT47gyCx
 *
 * With that, Sanity Arrays cannot include both primitive and complex types:
 * https://www.sanity.io/docs/array-type#fNBIr84P
 *
 * TODO:
 * This is not yet supported by Stackbit's TypeScript types, so the `any`
 * must be used. Additionally, if a Sanity array has multiple types of items one
 * of which is the 'object' type, then it will also have the 'name' property to
 * allow matching 'object' items to their types. The 'name' property is not
 * supported in Stackbit list items, so '@ts-ignore' is used.
 *
 * However, Stackbit client app should be able to render this types of lists correctly.
 *
 * @example A list that can include items of type 'model', 'reference' and 'object'.
 * {
 *     type: 'list',
 *     items: [{
 *         type: 'model',
 *         models: [...]
 *     }, {
 *         type: 'reference',
 *         models: [...]
 *     }, {
 *         type: 'object',
 *         name: 'nested_object_name',
 *         fields: {...}
 *     }]
 * }
 */
function getItemTypeForListItem(listItem, fieldModel) {
    const itemModels = fieldModel.items ?? { type: 'string' };
    // in Sanity, list items may have multiple types, in this case, 'items' will be an array
    if (!lodash_1.default.isArray(itemModels)) {
        return itemModels;
    }
    // Handle primitive list item types
    // For primitive list items, the list will hold the primitive values as is,
    // therefore, use JavaScript's `typeof` to infer the type of the values
    const type = lodash_1.default.get(listItem, '_type');
    if (!type) {
        const type = typeof listItem;
        if (typeIsPrimitive(type)) {
            return { type: type };
        }
        return null;
    }
    if (type === 'reference') {
        return lodash_1.default.find(itemModels, { type: 'reference' }) ?? null;
    }
    else if (type === 'block') {
        return lodash_1.default.find(itemModels, { type: 'richText' }) ?? null;
    }
    else {
        return (lodash_1.default.find(itemModels, (itemModel) => {
            if (itemModel.type === 'model') {
                return lodash_1.default.includes(itemModel.models, type);
            }
            else {
                // if field was one of base types (object, image, slug, etc.)
                // and it had a "name" property, then the "_type" will be equal to that name,
                // otherwise the "_type" will be equal to the base type
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return itemModel.name === type || itemModel.type === type;
            }
        }) ?? null);
    }
}
exports.getItemTypeForListItem = getItemTypeForListItem;
function typeIsPrimitive(type) {
    return ['string', 'number', 'boolean'].includes(type);
}
exports.typeIsPrimitive = typeIsPrimitive;
//# sourceMappingURL=utils.js.map