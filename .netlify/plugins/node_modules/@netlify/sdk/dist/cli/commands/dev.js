import readline from "readline";
import { spawn } from "child_process";
import chalk from "chalk";
import open from "open";
import { createDevelopmentContentEngine } from "../index.js";
import { getExtensionBuildInfo, getExtensionModule, getSettings, updateSettings, } from "../util.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { getConnectorLocalFrontendConfig, } from "../../extension/connect/cli.js";
import { build } from "./build.js";
export const dev = async ({ ...opts }) => {
    process.env.NODE_ENV = `development`;
    const buildApi = await build({
        ...opts,
        mode: "dev",
    });
    if (!buildApi) {
        throw new Error("No extension found");
    }
    const startEngine = opts.connector
        ? await handleConnector({ cwd: opts.cwd, opts })
        : false;
    if (buildApi.extension.netlifyConnectPlugin) {
        if (opts.connector && startEngine) {
            handleConnectorPlugin({ buildApi, startEngine });
        }
    }
};
export let connectorDevMode = getSettings()?.connectorDevMode || `clear cache on save`;
const handleConnectorPlugin = async ({ buildApi, startEngine, }) => {
    const supportsNetlifyCreate = !!buildApi.extension.netlifyConnectPlugin?.supports?.visualEditor;
    ntliLog("connector");
    const engine = await startEngine();
    const localFrontendConfig = getConnectorLocalFrontendConfig(buildApi.config);
    if (supportsNetlifyCreate) {
        handleFrontendProcess(localFrontendConfig);
    }
    handleConnectorKeypressListener({
        engine,
        supportsNetlifyCreate,
        localFrontendConfig,
    });
    logMode(supportsNetlifyCreate);
    buildApi.onRebuild(async () => {
        // restart content engine with the new bundle.
        // the engine runs in a worker thread and
        // calling .restart() will kill the worker and
        // start a new one that uses the new bundle that was just built.
        ntliLog(`connector`);
        await engine.stop();
        if (connectorDevMode === `rebundle-only on save`) {
            engine.initialize().then(() => {
                logMode(supportsNetlifyCreate);
            });
        }
        else {
            engine
                .sync({
                runServer: true,
                clearCache: connectorDevMode === `clear cache on save`,
            })
                .then(() => {
                logMode(supportsNetlifyCreate);
            });
        }
    });
};
let connectorKeypressListenerAdded = false;
export const handleConnectorKeypressListener = ({ engine, supportsNetlifyCreate, localFrontendConfig, }) => {
    const createLocalDev = localFrontendConfig && supportsNetlifyCreate
        ? localFrontendConfig
        : undefined;
    if (!connectorKeypressListenerAdded) {
        connectorKeypressListenerAdded = true;
        readline.emitKeypressEvents(process.stdin);
        process.stdin?.setRawMode?.(true);
        const stackbitURL = `http://localhost:8090/_stackbit`;
        const urls = {
            connect: `http://localhost:8000/__graphql`,
            create: supportsNetlifyCreate ? stackbitURL : null,
            framework: createLocalDev?.port
                ? `http://localhost:${createLocalDev.port}`
                : null,
        };
        process.stdin.on("keypress", (_str, key) => {
            if (key.name === "o") {
                process.stdout.write(`\n`);
                ntliLog(`Opening ${urls.connect}`);
                // open( .. { wait: true } causes the open subprocess to hang around forever, creating a memory leak of about 20MB per code save..
                // seems to be related to https://github.com/sindresorhus/open/issues/197
                void open(urls.connect);
            }
            else if (urls.create && key.name === "c" && !key.ctrl) {
                process.stdout.write(`\n`);
                ntliLog(`Opening ${urls.create}`);
                // open( .. { wait: true } causes the open subprocess to hang around forever, creating a memory leak of about 20MB per code save..
                // seems to be related to https://github.com/sindresorhus/open/issues/197
                void open(urls.create);
            }
            else if (
            // still show the [f] keymap even if there's no framework url. we will print instructions on how to enable it if it's not configured (below)
            (urls.framework || supportsNetlifyCreate) &&
                key.name === "f") {
                if (urls.framework) {
                    process.stdout.write(`\n`);
                    ntliLog(`Opening ${urls.framework}`);
                    // open( .. { wait: true } causes the open subprocess to hang around forever, creating a memory leak of about 20MB per code save..
                    // seems to be related to https://github.com/sindresorhus/open/issues/197
                    void open(urls.framework);
                }
                else {
                    ntliLog(`
This connector supports Netlify Visual Editor but extension.yaml is missing a local frontend configuration.\nThe local Netlify Visual Editor UI will run but the frontend site preview will be empty.

To run a frontend site and test your connector as your users will experience it, update your \`extension.yaml\` to include a \`connector.local-frontend\` block. For example:

config:
  slug: acme
  package_prefix: "@acme/connector"
  version: 1.0.0
  connector:
    local-frontend:
      port: 3000
      command: "pnpm run start"
      directory: "./local-frontend"
  `);
                }
            }
            else if (key.name === "m") {
                if (connectorDevMode === `clear cache on save`) {
                    connectorDevMode = `data update on save`;
                }
                else if (connectorDevMode === `data update on save`) {
                    connectorDevMode = `rebundle-only on save`;
                }
                else if (connectorDevMode === `rebundle-only on save`) {
                    connectorDevMode = `clear cache on save`;
                }
                updateSettings({ connectorDevMode });
                console.log(getModeLog());
            }
            else if ((key.ctrl && key.name === "c") || key.name === "q") {
                process.exit(); // If user presses CTRL+C, exit the process
            }
            else if (key.name === "r") {
                printResetHeader();
                ntliLog(`connector`);
                engine
                    .restart({
                    runServer: true,
                    clearCache: connectorDevMode === `clear cache on save`,
                })
                    .then(() => {
                    logMode(supportsNetlifyCreate);
                });
            }
            else if (key.name === "s") {
                console.log("");
                ntliLog(`syncing connector`);
                engine.sync();
            }
        });
    }
};
const getModeLog = () => `${chalk.grey(`[m]`)} mode (${connectorDevMode === `clear cache on save`
    ? chalk.yellow(connectorDevMode)
    : connectorDevMode === `rebundle-only on save`
        ? chalk.blue(connectorDevMode)
        : chalk.green(connectorDevMode)})`;
const logMode = (supportsCreate) => {
    console.log(chalk.blue(`Keys:`));
    console.log(getModeLog());
    console.log(`${chalk.grey(`[r]`)} restart process`);
    console.log(`${chalk.grey(`[s]`)} sync data\n`);
    console.log(chalk.blue(`Open:`));
    if (supportsCreate) {
        console.log(`${chalk.grey(`[c]`)} Netlify Visual Editor`);
    }
    console.log(`${chalk.grey(`[o]`)} Netlify Connect API`);
    if (supportsCreate) {
        console.log(`${chalk.grey(`[f]`)} frontend site`);
    }
};
async function handleFrontendProcess(localFrontendConfig) {
    if (!localFrontendConfig) {
        return;
    }
    const { command, directory, port } = localFrontendConfig || {};
    if (!command || !port) {
        console.warn(`When using connector.local-frontend in extension.yaml, you must provide a port and command to start a frontend for the local Netlify Visual Editor. \n\nFound: ${JSON.stringify(localFrontendConfig, null, 2)}\nSkipping connector local dev frontend settings\n`);
        return;
    }
    const [bin, ...args] = command.split(` `);
    const frameworkP = spawn(bin, args, {
        stdio: `pipe`,
        cwd: directory || process.cwd(),
        detached: true,
    });
    let sawFirstCompileLog = false;
    frameworkP.stdout.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        // omit ugly/noisy nextjs logs
        if (message.includes(`compiling /`))
            return;
        if (message.includes(`compiled client and server successfully`)) {
            if (!sawFirstCompileLog) {
                sawFirstCompileLog = true;
                return;
            }
            // for compiled still print a more minimal log
            process.stdout.write(chalk.yellow(`frontend`) + `: compiled\n`);
            return;
        }
        if (message.includes(`started server on`) && message.includes(`:${port}`)) {
            return;
        }
        if (message.includes(`> next`) &&
            message.includes(`@`) &&
            message.includes(` dev /`))
            return;
        process.stdout.write(chalk.yellow(`frontend`) + `: ${message}`);
    });
    frameworkP.stderr.on(`data`, (message) => {
        message = message.toString();
        if (message.startsWith(`- `)) {
            message = message.substring(2, message.length);
        }
        if (message.includes(`Fast Refresh had to perform a full reload.`))
            return;
        process.stderr.write(chalk.red(`frontend`) + `: ${message}`);
    });
    const { pid } = frameworkP;
    // kill frameworkP and all it's children when this process exits
    process.on("exit", async () => {
        if (pid) {
            process.kill(-pid);
        }
    });
}
const handleConnector = async ({ cwd, opts, }) => {
    const { builtPath } = await getExtensionBuildInfo({ cwd });
    const extension = await getExtensionModule(builtPath);
    if (extension) {
        return async () => {
            const { engine } = await createDevelopmentContentEngine({
                extension,
                cwd,
            });
            // do an initial sync of the built connector plugin
            const { exitCode } = await engine.sync({
                runServer: true, // with a GraphQL server for local dev
                clearCache: connectorDevMode === `clear cache on save`,
            });
            if (typeof exitCode !== `undefined`) {
                console.log(chalk.red(`Connector plugin exited with code ${exitCode}.`));
                if (opts.mode === "dev") {
                    console.log(chalk.green(`Save your code to restart the process.`));
                }
            }
            return engine;
        };
    }
    return false;
};
//# sourceMappingURL=dev.js.map