"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.contentEngine = void 0;
var _graphql = require("../graphql");
var _index = require("./../datastore/index");
var _express = _interopRequireDefault(require("express"));
var _inspector = _interopRequireDefault(require("inspector"));
var _opentracing = require("opentracing");
var _reporter = _interopRequireDefault(require("../reporter"));
var _tracer = require("../utils/tracer");
var _detectPortInUseAndPrompt = require("../utils/detect-port-in-use-and-prompt");
var _ = require(".");
var _redux = require("../redux");
var _datastore = require("../datastore");
var _printInstructions = require("../utils/print-instructions");
var _2 = require("..");
var _context = _interopRequireDefault(require("../schema/context"));
var _frameworkHooks = require("../framework-hooks");
const tracer = (0, _opentracing.globalTracer)();
const openDebuggerPort = debugInfo => {
  if (_inspector.default.url() !== undefined) {
    return; // fixes #26708
  }

  if (debugInfo.break) {
    _inspector.default.open(debugInfo.port, undefined, true);
    // eslint-disable-next-line no-debugger
    debugger;
  } else {
    _inspector.default.open(debugInfo.port);
  }
};

// Return a user-supplied port otherwise the default Node.js debugging port
const getDebugPort = port => port !== null && port !== void 0 ? port : 9229;
const getDebugInfo = program => {
  if (Object.prototype.hasOwnProperty.call(program, `inspect`)) {
    return {
      port: getDebugPort(program.inspect),
      break: false
    };
  } else if (Object.prototype.hasOwnProperty.call(program, `inspectBrk`)) {
    return {
      port: getDebugPort(program.inspectBrk),
      break: true
    };
  } else {
    return null;
  }
};
const contentEngine = ({
  verbose,
  openTracingConfigFile,
  host,
  port,
  directory,
  engineConfig,
  frameworkHooks: frameworkHooksPath
} = {
  directory: ``
}) => {
  if (frameworkHooksPath) {
    require(frameworkHooksPath);
  }
  _frameworkHooks.frameworkHooks.startup.before();
  directory ||= process.cwd();

  // provide global Gatsby object
  global.__GATSBY = process.env.GATSBY_NODE_GLOBALS ? JSON.parse(process.env.GATSBY_NODE_GLOBALS) : {};
  const hostname = `0.0.0.0`;
  const program = {
    directory,
    sitePackageJson: require(`${directory}/package.json`),
    port: (typeof port === `string` ? parseInt(port, 10) : port) || 8000,
    hostname,
    host: host || `localhost`,
    store: _redux.store,
    reporter: _reporter.default,
    openTracingConfigFile: ``,
    debugInfo: null
  };
  program.debugInfo = getDebugInfo(program);
  console.info(`[content-engine] starting "${program.sitePackageJson.name || `unknown`}" engine`);
  program.verbose = verbose || false;
  _reporter.default.setVerbose(program.verbose);
  if (program.debugInfo) {
    openDebuggerPort(program.debugInfo);
  }
  if (openTracingConfigFile) {
    (0, _tracer.initTracer)(openTracingConfigFile);
  }
  async function loadData({
    webhookBody,
    parentSpan,
    shouldBuildSchema = true,
    connector
  } = {
    shouldBuildSchema: true
  }) {
    const activity = _reporter.default.activityTimer(`update integration data`);
    activity.start();
    try {
      await _frameworkHooks.frameworkHooks.customizeSchema.before();
      await (0, _.customizeSchema)({
        parentSpan
      });
      await _frameworkHooks.frameworkHooks.customizeSchema.after();
      await _frameworkHooks.frameworkHooks.sourceNodes.before();
      await (0, _.sourceNodes)({
        parentSpan,
        webhookBody,
        store: _redux.store,
        webhookSourcePluginName: connector
      });
      await _frameworkHooks.frameworkHooks.sourceNodes.after();
      await _frameworkHooks.frameworkHooks.buildSchema.before();
      if (shouldBuildSchema) {
        await (0, _.buildSchema)({
          parentSpan
        });
      }
      await _frameworkHooks.frameworkHooks.buildSchema.after();
      (0, _redux.saveState)();
    } finally {
      activity.end();
    }
  }
  let app;
  let server;
  let serverShouldBeRunning = false;
  let initialized = false;
  const publicInitialize = async ({
    parentSpan
  }) => {
    await (0, _datastore.getDataStore)().ready();
    const appExists = Boolean(app);
    if (!appExists && serverShouldBeRunning) {
      try {
        program.port = await (0, _detectPortInUseAndPrompt.detectPortInUseAndPrompt)(program.port, hostname);
      } catch (e) {
        if (e.message === `USER_REJECTED`) {
          process.exit(0);
        }
        throw e;
      }
      app = (0, _express.default)();
      app.use((req, res, next) => {
        try {
          decodeURIComponent(req.path);
        } catch (e) {
          return res.status(500).send(`URI malformatted`);
        }
        return next();
      });
    }
    if (!initialized) {
      console.info(`[content-engine] initializing`);
      await (0, _.initialize)({
        parentSpan,
        program,
        reporter: _reporter.default,
        app,
        engineConfig
      });
      initialized = true;
    }
  };
  _frameworkHooks.frameworkHooks.startup.after();
  return {
    config: async () => {
      throw new Error(`contentEngine().config() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    onStdOut: () => {
      throw new Error(`contentEngine().onStdOut() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    onStdErr: () => {
      throw new Error(`contentEngine().onStdErr() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    onMessage: () => {
      throw new Error(`contentEngine().onMessage() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    sendMessage: () => {
      throw new Error(`contentEngine().sendMessage() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    clearListeners: () => {
      throw new Error(`contentEngine().clearListeners() can only be called when contentEngine({ runInSubProcess: true }) is set.`);
    },
    initialize: async args => {
      const parentSpan = tracer.startSpan(`initialize`);
      await publicInitialize({
        ...args,
        parentSpan
      });
      parentSpan.finish();
    },
    sync: async ({
      runServer,
      webhookBody,
      buildSchema = true,
      connector
    } = {
      buildSchema: true
    }) => {
      console.log(`[content-engine] sync started`);
      await _frameworkHooks.frameworkHooks.sync.before();
      if (typeof runServer !== `undefined`) {
        serverShouldBeRunning = runServer;
      }
      const parentSpan = tracer.startSpan(`sync-data`);
      await publicInitialize({
        parentSpan
      });
      try {
        await loadData({
          parentSpan,
          webhookBody,
          shouldBuildSchema: buildSchema,
          connector
        });
      } catch (e) {
        console.error(`[content-engine] error loading data`, e);
        throw e;
      }
      (0, _redux.savePartialStateToDisk)([`inferenceMetadata`]);
      if (serverShouldBeRunning && !server) {
        server = await (0, _.startGraphQLServer)({
          parentSpan,
          program,
          app,
          store: _redux.store,
          reporter: _reporter.default,
          loadData
        });
      }
      if (server && !serverShouldBeRunning) {
        server.close();
      }
      await (0, _datastore.getDataStore)().ready();
      parentSpan.finish();
      if (serverShouldBeRunning && server) {
        (0, _printInstructions.printInstructions)(program);
      }
      await _frameworkHooks.frameworkHooks.sync.after();
      return {};
    },
    stop: () => {
      throw new Error(`contentEngine().stop() is only available when running in a subprocess with contentEngine({ runInSubProcess: true }) set.`);
    },
    restart: () => {
      throw new Error(`contentEngine().restart() is only available when running in a subprocess with contentEngine({ runInSubProcess: true }) set.`);
    },
    test: (0, _2.throwOutsideTestEnv)({
      getNodes: _index.getNodes,
      getNodesByType: _index.getNodesByType,
      getNode: _index.getNode,
      query: async (query, variables) => {
        if (!initialized) {
          throw new Error(`contentEngine().query() called before first contentEngine().sync() completed.\nSchema customization has not run yet so the GraphQL API cannot be queried.`);
        }
        const {
          schema
        } = _redux.store.getState();
        const result = await (0, _graphql.graphql)({
          schema,
          source: query,
          rootValue: {},
          contextValue: (0, _context.default)({
            schema: _redux.store.getState().schema,
            schemaComposer: _redux.store.getState().schemaCustomization.composer,
            context: {},
            customContext: _redux.store.getState().schemaCustomization.context
          }),
          variableValues: variables
        });
        return result;
      }
    }),
    getProcess() {
      throw new Error(`contentEngine().process is only available when running in a subprocess with contentEngine({ runInSubProcess: true }) set.`);
    }
  };
};
exports.contentEngine = contentEngine;
//# sourceMappingURL=content-engine.js.map