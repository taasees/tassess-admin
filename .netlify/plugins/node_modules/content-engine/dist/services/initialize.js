"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.initialize = initialize;
var _flattenDeep2 = _interopRequireDefault(require("lodash/flattenDeep"));
var _coreUtils = require("../core-utils");
var fs = _interopRequireWildcard(require("fs-extra"));
var _mutex = require("../core-utils/mutex");
var _globby = _interopRequireDefault(require("globby"));
var _apiRunnerNode = _interopRequireDefault(require("../utils/api-runner-node"));
var _pluginRunner = require("../redux/plugin-runner");
var _redux = require("../redux");
var _reporter = _interopRequireDefault(require("../reporter"));
var _removeStaleJobs = require("../bootstrap/remove-stale-jobs");
var _loadConfig = require("../bootstrap/load-config");
var _loadPlugins = require("../bootstrap/load-plugins");
var _detectNodeMutations = require("../utils/detect-node-mutations");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// import telemetry from "gatsby-telemetry"

// Show stack trace on unhandled promises.
process.on(`unhandledRejection`, reason => {
  // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/33636
  _reporter.default.panic(reason || `Unhandled rejection`);
});

// Override console.log to add the source file + line number.
// Useful for debugging if you lose a console.log somewhere.
// Otherwise leave commented out.
// require(`../bootstrap/log-line-function`)

async function initialize({
  program: args,
  parentSpan,
  engineConfig
}) {
  if (!args) {
    _reporter.default.panic(`Missing program args`);
  }
  if (_reporter.default._registerAdditionalDiagnosticOutputHandler) {
    _reporter.default._registerAdditionalDiagnosticOutputHandler(function logPendingJobs() {
      const outputs = [];
      for (const [, {
        job
      }] of _redux.store.getState().jobsV2.incomplete) {
        outputs.push(job);
        if (outputs.length >= 5) {
          // 5 not finished jobs should be enough to track down issues
          // this is just limiting output "spam"
          break;
        }
      }
      return outputs.length ? `Unfinished jobs (showing ${outputs.length} of ${_redux.store.getState().jobsV2.incomplete.size} jobs total):\n\n` + JSON.stringify(outputs, null, 2) : ``;
    });
  }
  const directory = (0, _coreUtils.slash)(args.directory);
  const program = {
    ...args,
    extensions: [],
    // Fix program directory path for windows env.
    directory
  };
  _redux.store.dispatch({
    type: `SET_PROGRAM`,
    payload: program
  });
  let activityForJobs;
  _redux.emitter.on(`CREATE_JOB`, () => {
    if (!activityForJobs) {
      activityForJobs = _reporter.default.phantomActivity(`Running jobs`);
      activityForJobs.start();
    }
  });
  const onEndJob = () => {
    if (activityForJobs && _redux.store.getState().jobs.active.length === 0) {
      activityForJobs.end();
      activityForJobs = null;
    }
  };
  _redux.emitter.on(`END_JOB`, onEndJob);
  const siteDirectory = program.directory;
  const activity = _reporter.default.activityTimer(`Loading plugins`);
  activity.start();
  const config = await (0, _loadConfig.loadConfig)({
    siteDirectory,
    processFlags: true,
    providedConfig: engineConfig
  });
  const flattenedPlugins = await (0, _loadPlugins.loadPlugins)(config, siteDirectory);
  if (process.env.GATSBY_DETECT_NODE_MUTATIONS) {
    (0, _detectNodeMutations.enableNodeMutationsDetection)();
  }

  // run stale jobs
  // @ts-ignore we'll need to fix redux typings https://redux.js.org/usage/usage-with-typescript
  _redux.store.dispatch((0, _removeStaleJobs.removeStaleJobs)(_redux.store.getState().jobsV2));

  // Multiple occurrences of the same name-version-pair can occur,
  // so we report an array of unique pairs
  // const pluginsStr = _.uniq(flattenedPlugins.map(p => `${p.name}@${p.version}`))
  // telemetry.decorateEvent(`BUILD_END`, {
  //   plugins: pluginsStr,
  // })

  // telemetry.decorateEvent(`DEVELOP_STOP`, {
  //   plugins: pluginsStr,
  // })

  // Start plugin runner which listens to the store
  // and invokes Gatsby API based on actions.
  (0, _pluginRunner.startPluginRunner)();
  await (0, _apiRunnerNode.default)(`onPreInit`, {
    parentSpan: activity.span
  });
  const lmdbCacheDirectoryName = `caches-lmdb`;
  const cacheDirectory = `${program.directory}/.cache`;

  // We do this by creating a hash of all the version numbers of installed
  // plugins, the site's package.json, gatsby-config.js, and gatsby-node.js.
  // The last, gatsby-node.js, is important as many gatsby sites put important
  // logic in there e.g. generating slugs for custom pages.
  const pluginVersions = flattenedPlugins.map(p => p.version);
  // we should include gatsby version as well
  pluginVersions.push(require(`../../package.json`).version);
  const optionalFiles = [`${program.directory}/gatsby-node.js`, `${program.directory}/gatsby-node.ts`];
  const state = _redux.store.getState();
  const hashes = await Promise.all(
  // Ignore optional files with .catch() as these are not required
  [(0, _coreUtils.md5File)(`package.json`)].concat(optionalFiles.map(f => (0, _coreUtils.md5File)(f).catch(() => ``))));
  const pluginsHash = await (0, _coreUtils.md5)(JSON.stringify(pluginVersions.concat(hashes)));
  const oldPluginsHash = state && state.status ? state.status.PLUGINS_HASH : ``;

  // Check if anything has changed. If it has, delete the site's .cache
  // directory and tell reducers to empty themselves.
  //
  // Also if the hash isn't there, then delete things just in case something
  // is weird.
  if (oldPluginsHash && pluginsHash !== oldPluginsHash) {
    _reporter.default.info(_reporter.default.stripIndent`
      One or more of your plugins have changed since the last time you ran Content Engine. As
      a precaution, we're deleting your site's cache to ensure there's no stale data.
    `);
  }
  if (oldPluginsHash && pluginsHash !== oldPluginsHash) {
    try {
      const deleteGlobs = [
      // By default delete all files & subdirectories
      `.cache/**`, `.cache/data/**`, `!.cache/data/core-utils/**`, `!.cache/compiled`];
      if (process.env.GATSBY_EXPERIMENTAL_PRESERVE_FILE_DOWNLOAD_CACHE) {
        // Stop the caches directory from being deleted, add all sub directories,
        // but remove gatsby-source-filesystem
        deleteGlobs.push(`!.cache/caches`);
        deleteGlobs.push(`.cache/caches/*`);
        deleteGlobs.push(`!.cache/caches/gatsby-source-filesystem`);
      }
      const files = await (0, _globby.default)(deleteGlobs, {
        cwd: program.directory
      });
      await Promise.all(files.map(file => fs.remove(file)));
    } catch (e) {
      _reporter.default.error(`Failed to remove .cache files.`, e);
    }

    // Tell reducers to delete their data (the store will already have
    // been loaded from the file system cache).
    _redux.store.dispatch({
      type: `DELETE_CACHE`,
      cacheIsCorrupt: false
    });

    // make sure all previous mutexes are released
    await (0, _mutex.releaseAllMutexes)();

    // in future this should show which plugin's caches are purged
    // possibly should also have which plugins had caches
    // telemetry.decorateEvent(`BUILD_END`, {
    //   pluginCachesPurged: [`*`],
    // })
    // telemetry.decorateEvent(`DEVELOP_STOP`, {
    //   pluginCachesPurged: [`*`],
    // })
  }

  // Update the store with the new plugins hash.
  _redux.store.dispatch({
    type: `UPDATE_PLUGINS_HASH`,
    payload: pluginsHash
  });

  // Now that we know the .cache directory is safe, initialize the cache
  // directory.
  await fs.ensureDir(cacheDirectory);

  // Init plugins once cache is initialized
  await (0, _apiRunnerNode.default)(`onPluginInit`, {
    parentSpan: activity.span
  });
  try {
    await fs.ensureDir(`${cacheDirectory}/${lmdbCacheDirectoryName}`);
  } catch (err) {
    _reporter.default.panic(`Unable to copy site files to .cache`, err);
  }

  /**
   * Start the main bootstrap processes.
   */
  await (0, _apiRunnerNode.default)(`onPreBootstrap`, {
    parentSpan: activity.span
  });
  activity.end();

  // Collect resolvable extensions and attach to program.
  const extensions = [`.mjs`, `.js`, `.jsx`, `.wasm`, `.json`];
  // Change to this being an action and plugins implement `onPreBootstrap`
  // for adding extensions.
  const apiResults = await (0, _apiRunnerNode.default)(`resolvableExtensions`, {
    traceId: `initial-resolvableExtensions`,
    parentSpan
  });
  _redux.store.dispatch({
    type: `SET_PROGRAM_EXTENSIONS`,
    payload: (0, _flattenDeep2.default)([extensions, apiResults])
  });

  // const siteDirectoryFiles = await fs.readdir(siteDirectory)

  // const gatsbyFilesIsInESM = siteDirectoryFiles.some(file =>
  //   file.match(/gatsby-(node|config)\.mjs/)
  // )

  // if (gatsbyFilesIsInESM) {
  //   telemetry.trackFeatureIsUsed(`ESMInGatsbyFiles`)
  // }

  let initialWebhookBody = undefined;
  if (process.env.GATSBY_INITIAL_WEBHOOK_BODY) {
    try {
      initialWebhookBody = JSON.parse(process.env.GATSBY_INITIAL_WEBHOOK_BODY);
    } catch (e) {
      _reporter.default.error(`Failed to parse GATSBY_INITIAL_WEBHOOK_BODY as JSON:\n"${e.message}"`);
    }
  }
  return {
    store: _redux.store,
    webhookBody: initialWebhookBody
  };
}
//# sourceMappingURL=initialize.js.map