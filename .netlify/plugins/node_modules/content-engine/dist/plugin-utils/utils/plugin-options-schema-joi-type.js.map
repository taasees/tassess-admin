{"version":3,"file":"plugin-options-schema-joi-type.js","names":[],"sources":["../../../src/plugin-utils/utils/plugin-options-schema-joi-type.ts"],"sourcesContent":["/* eslint-disable */\n// The following definitions have been copied (almost) as-is from:\n// https://github.com/sideway/joi/tree/master/lib/index.d.ts\n// The only change @mxstbr made was to add support for our custom\n// .dotenv extension to AnySchema.\n\ntype Types =\n  | \"any\"\n  | \"alternatives\"\n  | \"array\"\n  | \"boolean\"\n  | \"binary\"\n  | \"date\"\n  | \"function\"\n  | \"link\"\n  | \"number\"\n  | \"object\"\n  | \"string\"\n  | \"symbol\"\n\ntype BasicType = boolean | number | string | any[] | object | null\n\ntype LanguageMessages = Record<string, string>\n\ntype PresenceMode = \"optional\" | \"required\" | \"forbidden\"\n\ninterface ErrorFormattingOptions {\n  /**\n   * when true, error message templates will escape special characters to HTML entities, for security purposes.\n   *\n   * @default false\n   */\n  escapeHtml?: boolean\n  /**\n   * defines the value used to set the label context variable.\n   */\n  label?: \"path\" | \"key\" | false\n  /**\n   * The preferred language code for error messages.\n   * The value is matched against keys at the root of the messages object, and then the error code as a child key of that.\n   * Can be a reference to the value, global context, or local context which is the root value passed to the validation function.\n   *\n   * Note that references to the value are usually not what you want as they move around the value structure relative to where the error happens.\n   * Instead, either use the global context, or the absolute value (e.g. `Joi.ref('/variable')`)\n   */\n  language?: keyof LanguageMessages\n  /**\n   * when false, skips rendering error templates. Useful when error messages are generated elsewhere to save processing time.\n   *\n   * @default true\n   */\n  render?: boolean\n  /**\n   * when true, the main error will possess a stack trace, otherwise it will be disabled.\n   * Defaults to false for performances reasons. Has no effect on platforms other than V8/node.js as it uses the Stack trace API.\n   *\n   * @default false\n   */\n  stack?: boolean\n  /**\n   * overrides the way values are wrapped (e.g. `[]` around arrays, `\"\"` around labels).\n   * Each key can be set to a string with one (same character before and after the value) or two characters (first character\n   * before and second character after), or `false` to disable wrapping.\n   */\n  wrap?: {\n    /**\n     * the characters used around `{#label}` references. Defaults to `'\"'`.\n     *\n     * @default '\"'\n     */\n    label?: string | false\n\n    /**\n     * the characters used around array avlues. Defaults to `'[]'`\n     *\n     * @default '[]'\n     */\n    array?: string | false\n  }\n}\n\ninterface BaseValidationOptions {\n  /**\n   * when true, stops validation on the first error, otherwise returns all the errors found.\n   *\n   * @default true\n   */\n  abortEarly?: boolean\n  /**\n   * when true, allows object to contain unknown keys which are ignored.\n   *\n   * @default false\n   */\n  allowUnknown?: boolean\n  /**\n   * when true, schema caching is enabled (for schemas with explicit caching rules).\n   *\n   * @default false\n   */\n  cache?: boolean\n  /**\n   * provides an external data set to be used in references\n   */\n  context?: Context\n  /**\n   * when true, attempts to cast values to the required types (e.g. a string to a number).\n   *\n   * @default true\n   */\n  convert?: boolean\n  /**\n   * sets the string format used when converting dates to strings in error messages and casting.\n   *\n   * @default 'iso'\n   */\n  dateFormat?: \"date\" | \"iso\" | \"string\" | \"time\" | \"utc\"\n  /**\n   * when true, valid results and throw errors are decorated with a debug property which includes an array of the validation steps used to generate the returned result.\n   *\n   * @default false\n   */\n  debug?: boolean\n  /**\n   * error formatting settings.\n   */\n  errors?: ErrorFormattingOptions\n  /**\n   * if false, the external rules set with `any.external()` are ignored, which is required to ignore any external validations in synchronous mode (or an exception is thrown).\n   *\n   * @default true\n   */\n  externals?: boolean\n  /**\n   * when true, do not apply default values.\n   *\n   * @default false\n   */\n  noDefaults?: boolean\n  /**\n   * when true, inputs are shallow cloned to include non-enumerables properties.\n   *\n   * @default false\n   */\n  nonEnumerables?: boolean\n  /**\n   * sets the default presence requirements. Supported modes: 'optional', 'required', and 'forbidden'.\n   *\n   * @default 'optional'\n   */\n  presence?: PresenceMode\n  /**\n   * when true, ignores unknown keys with a function value.\n   *\n   * @default false\n   */\n  skipFunctions?: boolean\n  /**\n   * remove unknown elements from objects and arrays.\n   * - when true, all unknown elements will be removed\n   * - when an object:\n   *      - objects - set to true to remove unknown keys from objects\n   *\n   * @default false\n   */\n  stripUnknown?: boolean | { arrays?: boolean; objects?: boolean }\n}\n\ninterface ValidationOptions extends BaseValidationOptions {\n  /**\n   * overrides individual error messages. Defaults to no override (`{}`).\n   * Messages use the same rules as templates.\n   * Variables in double braces `{{var}}` are HTML escaped if the option `errors.escapeHtml` is set to true.\n   *\n   * @default {}\n   */\n  messages?: LanguageMessages\n}\n\ninterface AsyncValidationOptions extends ValidationOptions {\n  /**\n   * when true, warnings are returned alongside the value (i.e. `{ value, warning }`).\n   *\n   * @default false\n   */\n  warnings?: boolean\n}\n\ninterface LanguageMessageTemplate {\n  source: string\n  rendered: string\n}\n\ninterface ErrorValidationOptions extends BaseValidationOptions {\n  messages?: Record<string, LanguageMessageTemplate>\n}\n\ninterface RenameOptions {\n  /**\n   * if true, does not delete the old key name, keeping both the new and old keys in place.\n   *\n   * @default false\n   */\n  alias?: boolean\n  /**\n   * if true, allows renaming multiple keys to the same destination where the last rename wins.\n   *\n   * @default false\n   */\n  multiple?: boolean\n  /**\n   * if true, allows renaming a key over an existing key.\n   *\n   * @default false\n   */\n  override?: boolean\n  /**\n   * if true, skip renaming of a key if it's undefined.\n   *\n   * @default false\n   */\n  ignoreUndefined?: boolean\n}\n\ninterface TopLevelDomainOptions {\n  /**\n   * - `true` to use the IANA list of registered TLDs. This is the default value.\n   * - `false` to allow any TLD not listed in the `deny` list, if present.\n   * - A `Set` or array of the allowed TLDs. Cannot be used together with `deny`.\n   */\n  allow?: Set<string> | string[] | boolean\n  /**\n   * - A `Set` or array of the forbidden TLDs. Cannot be used together with a custom `allow` list.\n   */\n  deny?: Set<string> | string[]\n}\n\ninterface HierarchySeparatorOptions {\n  /**\n   * overrides the default `.` hierarchy separator. Set to false to treat the key as a literal value.\n   *\n   * @default '.'\n   */\n  separator?: string | false\n}\n\ninterface EmailOptions {\n  /**\n   * If `true`, Unicode characters are permitted\n   *\n   * @default true\n   */\n  allowUnicode?: boolean\n  /**\n   * if `true`, ignore invalid email length errors.\n   *\n   * @default false\n   */\n  ignoreLength?: boolean\n  /**\n   * if true, allows multiple email addresses in a single string, separated by , or the separator characters.\n   *\n   * @default false\n   */\n  multiple?: boolean\n  /**\n   * when multiple is true, overrides the default , separator. String can be a single character or multiple separator characters.\n   *\n   * @default ','\n   */\n  separator?: string | string[]\n  /**\n   * Options for TLD (top level domain) validation. By default, the TLD must be a valid name listed on the [IANA registry](http://data.iana.org/TLD/tlds-alpha-by-domain.txt)\n   *\n   * @default { allow: true }\n   */\n  tlds?: TopLevelDomainOptions | false\n  /**\n   * Number of segments required for the domain. Be careful since some domains, such as `io`, directly allow email.\n   *\n   * @default 2\n   */\n  minDomainSegments?: number\n}\n\ninterface DomainOptions {\n  /**\n   * If `true`, Unicode characters are permitted\n   *\n   * @default true\n   */\n  allowUnicode?: boolean\n\n  /**\n   * Options for TLD (top level domain) validation. By default, the TLD must be a valid name listed on the [IANA registry](http://data.iana.org/TLD/tlds-alpha-by-domain.txt)\n   *\n   * @default { allow: true }\n   */\n  tlds?: TopLevelDomainOptions | false\n  /**\n   * Number of segments required for the domain.\n   *\n   * @default 2\n   */\n  minDomainSegments?: number\n}\n\ninterface HexOptions {\n  /**\n   * hex decoded representation must be byte aligned.\n   * @default false\n   */\n  byteAligned?: boolean\n}\n\ninterface IpOptions {\n  /**\n   * One or more IP address versions to validate against. Valid values: ipv4, ipv6, ipvfuture\n   */\n  version?: string | string[]\n  /**\n   * Used to determine if a CIDR is allowed or not. Valid values: optional, required, forbidden\n   */\n  cidr?: PresenceMode\n}\n\ntype GuidVersions = \"uuidv1\" | \"uuidv2\" | \"uuidv3\" | \"uuidv4\" | \"uuidv5\"\n\ninterface GuidOptions {\n  version: GuidVersions[] | GuidVersions\n}\n\ninterface UriOptions {\n  /**\n   * Specifies one or more acceptable Schemes, should only include the scheme name.\n   * Can be an Array or String (strings are automatically escaped for use in a Regular Expression).\n   */\n  scheme?: string | RegExp | Array<string | RegExp>\n  /**\n   * Allow relative URIs.\n   *\n   * @default false\n   */\n  allowRelative?: boolean\n  /**\n   * Restrict only relative URIs.\n   *\n   * @default false\n   */\n  relativeOnly?: boolean\n  /**\n   * Allows unencoded square brackets inside the query string.\n   * This is NOT RFC 3986 compliant but query strings like abc[]=123&abc[]=456 are very common these days.\n   *\n   * @default false\n   */\n  allowQuerySquareBrackets?: boolean\n  /**\n   * Validate the domain component using the options specified in `string.domain()`.\n   */\n  domain?: DomainOptions\n}\n\ninterface DataUriOptions {\n  /**\n   * optional parameter defaulting to true which will require `=` padding if true or make padding optional if false\n   *\n   * @default true\n   */\n  paddingRequired?: boolean\n}\n\ninterface Base64Options extends Pick<DataUriOptions, \"paddingRequired\"> {\n  /**\n   * if true, uses the URI-safe base64 format which replaces `+` with `-` and `\\` with `_`.\n   *\n   * @default false\n   */\n  urlSafe?: boolean\n}\n\ninterface SwitchCases {\n  /**\n   * the required condition joi type.\n   */\n  is: SchemaLike\n  /**\n   * the alternative schema type if the condition is true.\n   */\n  then: SchemaLike\n}\n\ninterface SwitchDefault {\n  /**\n   * the alternative schema type if no cases matched.\n   * Only one otherwise statement is allowed in switch as the last array item.\n   */\n  otherwise: SchemaLike\n}\n\ninterface WhenOptions {\n  /**\n   * the required condition joi type.\n   */\n  is?: SchemaLike\n\n  /**\n   * the negative version of `is` (`then` and `otherwise` have reverse\n   * roles).\n   */\n  not?: SchemaLike\n\n  /**\n   * the alternative schema type if the condition is true. Required if otherwise or switch are missing.\n   */\n  then?: SchemaLike\n\n  /**\n   * the alternative schema type if the condition is false. Required if then or switch are missing.\n   */\n  otherwise?: SchemaLike\n\n  /**\n   * the list of cases. Required if then is missing.  Required if then or otherwise are missing.\n   */\n  switch?: Array<SwitchCases | SwitchDefault>\n\n  /**\n   * whether to stop applying further conditions if the condition is true.\n   */\n  break?: boolean\n}\n\ninterface WhenSchemaOptions {\n  /**\n   * the alternative schema type if the condition is true. Required if otherwise is missing.\n   */\n  then?: SchemaLike\n  /**\n   * the alternative schema type if the condition is false. Required if then is missing.\n   */\n  otherwise?: SchemaLike\n}\n\ninterface Cache {\n  /**\n   * Add an item to the cache.\n   *\n   * Note that key and value can be anything including objects, array, etc.\n   */\n  set(key: any, value: any): void\n\n  /**\n   * Retrieve an item from the cache.\n   *\n   * Note that key and value can be anything including objects, array, etc.\n   */\n  get(key: any): any\n}\ninterface CacheProvisionOptions {\n  /**\n   * number of items to store in the cache before the least used items are dropped.\n   *\n   * @default 1000\n   */\n  max: number\n}\n\ninterface CacheConfiguration {\n  /**\n   * Provisions a simple LRU cache for caching simple inputs (`undefined`, `null`, strings, numbers, and booleans).\n   */\n  provision(options?: CacheProvisionOptions): void\n}\n\ninterface CompileOptions {\n  /**\n   * If true and the provided schema is (or contains parts) using an older version of joi, will return a compiled schema that is compatible with the older version.\n   * If false, the schema is always compiled using the current version and if older schema components are found, an error is thrown.\n   */\n  legacy: boolean\n}\n\ninterface IsSchemaOptions {\n  /**\n   * If true, will identify schemas from older versions of joi, otherwise will throw an error.\n   *\n   * @default false\n   */\n  legacy: boolean\n}\n\ninterface ReferenceOptions extends HierarchySeparatorOptions {\n  /**\n   * a function with the signature `function(value)` where `value` is the resolved reference value and the return value is the adjusted value to use.\n   * Note that the adjust feature will not perform any type validation on the adjusted value and it must match the value expected by the rule it is used in.\n   * Cannot be used with `map`.\n   *\n   * @example `(value) => value + 5`\n   */\n  adjust?: (value: any) => any\n\n  /**\n   * an array of array pairs using the format `[[key, value], [key, value]]` used to maps the resolved reference value to another value.\n   * If the resolved value is not in the map, it is returned as-is.\n   * Cannot be used with `adjust`.\n   */\n  map?: Array<[any, any]>\n\n  /**\n   * overrides default prefix characters.\n   */\n  prefix?: {\n    /**\n     * references to the globally provided context preference.\n     *\n     * @default '$'\n     */\n    global?: string\n\n    /**\n     * references to error-specific or rule specific context.\n     *\n     * @default '#'\n     */\n    local?: string\n\n    /**\n     * references to the root value being validated.\n     *\n     * @default '/'\n     */\n    root?: string\n  }\n\n  /**\n   * If set to a number, sets the reference relative starting point.\n   * Cannot be combined with separator prefix characters.\n   * Defaults to the reference key prefix (or 1 if none present)\n   */\n  ancestor?: number\n\n  /**\n   * creates an in-reference.\n   */\n  in?: boolean\n\n  /**\n   * when true, the reference resolves by reaching into maps and sets.\n   */\n  iterables?: boolean\n}\n\ninterface StringRegexOptions {\n  /**\n   * optional pattern name.\n   */\n  name?: string\n\n  /**\n   * when true, the provided pattern will be disallowed instead of required.\n   *\n   * @default false\n   */\n  invert?: boolean\n}\n\ninterface RuleOptions {\n  /**\n   * if true, the rules will not be replaced by the same unique rule later.\n   *\n   * For example, `Joi.number().min(1).rule({ keep: true }).min(2)` will keep both `min()` rules instead of the later rule overriding the first.\n   *\n   * @default false\n   */\n  keep?: boolean\n\n  /**\n   * a single message string or a messages object where each key is an error code and corresponding message string as value.\n   *\n   * The object is the same as the messages used as an option in `any.validate()`.\n   * The strings can be plain messages or a message template.\n   */\n  message?: string | LanguageMessages\n\n  /**\n   * if true, turns any error generated by the ruleset to warnings.\n   */\n  warn?: boolean\n}\n\ninterface ErrorReport extends Error {\n  code: string\n  flags: Record<string, ExtensionFlag>\n  path: string[]\n  prefs: ErrorValidationOptions\n  messages: LanguageMessages\n  state: State\n  value: any\n}\n\ninterface ValidationError extends Error {\n  name: \"ValidationError\"\n\n  isJoi: boolean\n\n  /**\n   * array of errors.\n   */\n  details: ValidationErrorItem[]\n\n  /**\n   * function that returns a string with an annotated version of the object pointing at the places where errors occurred.\n   *\n   * NOTE: This method does not exist in browser builds of Joi\n   *\n   * @param stripColors - if truthy, will strip the colors out of the output.\n   */\n  annotate(stripColors?: boolean): string\n\n  _object: any\n}\n\ninterface ValidationErrorItem {\n  message: string\n  path: Array<string | number>\n  type: string\n  context?: Context\n}\n\ntype ValidationErrorFunction = (\n  errors: ErrorReport[]\n) => string | ValidationErrorItem | Error\n\ninterface ValidationResult {\n  error?: ValidationError\n  errors?: ValidationError\n  warning?: ValidationError\n  value: any\n}\n\ninterface CreateErrorOptions {\n  flags?: boolean\n  messages?: LanguageMessages\n}\n\ninterface ModifyOptions {\n  each?: boolean\n  once?: boolean\n  ref?: boolean\n  schema?: boolean\n}\n\ninterface MutateRegisterOptions {\n  family?: any\n  key?: any\n}\n\ninterface SetFlagOptions {\n  clone: boolean\n}\n\ninterface CustomHelpers<V = any> {\n  schema: ExtensionBoundSchema\n  state: State\n  prefs: ValidationOptions\n  original: V\n  warn: (code: string, local?: Context) => void\n  error: (code: string, local?: Context) => ErrorReport\n  message: (messages: LanguageMessages, local?: Context) => ErrorReport\n}\n\ntype CustomValidator<V = any> = (value: V, helpers: CustomHelpers) => V\n\ntype ExternalValidationFunction = (value: any) => any\n\ntype SchemaLikeWithoutArray =\n  | string\n  | number\n  | boolean\n  | null\n  | Schema\n  | SchemaMap\ntype SchemaLike = SchemaLikeWithoutArray | object\n\ntype SchemaMap<TSchema = any> = {\n  [key in keyof TSchema]?: SchemaLike | SchemaLike[]\n}\n\nexport type Schema =\n  | AnySchema\n  | ArraySchema\n  | AlternativesSchema\n  | BinarySchema\n  | BooleanSchema\n  | DateSchema\n  | FunctionSchema\n  | NumberSchema\n  | ObjectSchema\n  | StringSchema\n  | LinkSchema\n  | SymbolSchema\n\ntype SchemaFunction = (schema: Schema) => Schema\n\ninterface AddRuleOptions {\n  name: string\n  args?: {\n    [key: string]: any\n  }\n}\n\ninterface GetRuleOptions {\n  args?: Record<string, any>\n  method?: string\n  name: string\n  operator?: string\n}\n\ninterface SchemaInternals {\n  /**\n   * Parent schema object.\n   */\n  $_super: Schema\n\n  /**\n   * Terms of current schema.\n   */\n  $_terms: Record<string, any>\n\n  /**\n   * Adds a rule to current validation schema.\n   */\n  $_addRule(rule: string | AddRuleOptions): Schema\n\n  /**\n   * Internally compiles schema.\n   */\n  $_compile(schema: SchemaLike, options?: CompileOptions): Schema\n\n  /**\n   * Creates a joi error object.\n   */\n  $_createError(\n    code: string,\n    value: any,\n    context: Context,\n    state: State,\n    prefs: ValidationOptions,\n    options?: CreateErrorOptions\n  ): Err\n\n  /**\n   * Get value from given flag.\n   */\n  $_getFlag(name: string): any\n\n  /**\n   * Retrieve some rule configuration.\n   */\n  $_getRule(name: string): GetRuleOptions | undefined\n\n  $_mapLabels(path: string | string[]): string\n\n  /**\n   * Returns true if validations runs fine on given value.\n   */\n  $_match(value: any, state: State, prefs: ValidationOptions): boolean\n\n  $_modify(options?: ModifyOptions): Schema\n\n  /**\n   * Resets current schema.\n   */\n  $_mutateRebuild(): this\n\n  $_mutateRegister(schema: Schema, options?: MutateRegisterOptions): void\n\n  /**\n   * Get value from given property.\n   */\n  $_property(name: string): any\n\n  /**\n   * Get schema at given path.\n   */\n  $_reach(path: string[]): Schema\n\n  /**\n   * Get current schema root references.\n   */\n  $_rootReferences(): any\n\n  /**\n   * Set flag to given value.\n   */\n  $_setFlag(flag: string, value: any, options?: SetFlagOptions): void\n\n  /**\n   * Runs internal validations against given value.\n   */\n  $_validate(\n    value: any,\n    state: State,\n    prefs: ValidationOptions\n  ): ValidationResult\n}\n\ninterface AnySchema extends SchemaInternals {\n  /**\n   * Flags of current schema.\n   */\n  _flags: Record<string, any>\n\n  /**\n   * Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called.\n   */\n  $: this\n\n  /**\n   * Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called.\n   */\n  ruleset: this\n\n  type?: Types | string\n\n  /**\n   * Whitelists a value\n   */\n  allow(...values: any[]): this\n\n  /**\n   * Assign target alteration options to a schema that are applied when `any.tailor()` is called.\n   * @param targets - an object where each key is a target name, and each value is a function that takes an schema and returns an schema.\n   */\n  alter(targets: Record<string, SchemaFunction>): this\n\n  /**\n   * By default, some Joi methods to function properly need to rely on the Joi instance they are attached to because\n   * they use `this` internally.\n   * So `Joi.string()` works but if you extract the function from it and call `string()` it won't.\n   * `bind()` creates a new Joi instance where all the functions relying on `this` are bound to the Joi instance.\n   */\n  bind(): this\n\n  /**\n   * Adds caching to the schema which will attempt to cache the validation results (success and failures) of incoming inputs.\n   * If no cache is passed, a default cache is provisioned by using `cache.provision()` internally.\n   */\n  cache(cache?: Cache): this\n\n  /**\n   * Casts the validated value to the specified type.\n   */\n  cast(to: \"map\" | \"number\" | \"set\" | \"string\"): this\n\n  /**\n   * Returns a new type that is the result of adding the rules of one type to another.\n   */\n  concat(schema: this): this\n\n  /**\n   * Adds a custom validation function.\n   */\n  custom(fn: CustomValidator, description?: string): this\n\n  /**\n   * Sets a default value if the original value is `undefined` where:\n   * @param value - the default value. One of:\n   *    - a literal value (string, number, object, etc.)\n   *    - a [references](#refkey-options)\n   *    - a function which returns the default value using the signature `function(parent, helpers)` where:\n   *        - `parent` - a clone of the object containing the value being validated. Note that since specifying a\n   *          `parent` ragument performs cloning, do not declare format arguments if you are not using them.\n   *        - `helpers` - same as those described in [`any.custom()`](anycustomermethod_description)\n   *\n   * When called without any `value` on an object schema type, a default value will be automatically generated\n   * based on the default values of the object keys.\n   *\n   * Note that if value is an object, any changes to the object after `default()` is called will change the\n   *  reference and any future assignment.\n   */\n  default(\n    value?:\n      | BasicType\n      | Reference\n      | ((parent: any, helpers: CustomHelpers) => BasicType | Reference)\n  ): this\n\n  /**\n   * Returns a plain object representing the schema's rules and properties\n   */\n  describe(): Description\n\n  /**\n   * Annotates the key\n   */\n  description(desc: string): this\n\n  /**\n   * Disallows values.\n   */\n  disallow(...values: any[]): this\n\n  /**\n   * Specifies that a value should be stored in a .env file with ${name}\n   * instead of inlined into the gatsby-config.js\n   * @param name - string\n   */\n  dotenv(name: string): this\n\n  /**\n   * Considers anything that matches the schema to be empty (undefined).\n   * @param schema - any object or joi schema to match. An undefined schema unsets that rule.\n   */\n  empty(schema?: SchemaLike): this\n\n  /**\n   * Adds the provided values into the allowed whitelist and marks them as the only valid values allowed.\n   */\n  equal(...values: any[]): this\n\n  /**\n   * Overrides the default joi error with a custom error if the rule fails where:\n   * @param err - can be:\n   *   an instance of `Error` - the override error.\n   *   a `function(errors)`, taking an array of errors as argument, where it must either:\n   *    return a `string` - substitutes the error message with this text\n   *    return a single ` object` or an `Array` of it, where:\n   *     `type` - optional parameter providing the type of the error (eg. `number.min`).\n   *     `message` - optional parameter if `template` is provided, containing the text of the error.\n   *     `template` - optional parameter if `message` is provided, containing a template string, using the same format as usual joi language errors.\n   *     `context` - optional parameter, to provide context to your error if you are using the `template`.\n   *    return an `Error` - same as when you directly provide an `Error`, but you can customize the error message based on the errors.\n   *\n   * Note that if you provide an `Error`, it will be returned as-is, unmodified and undecorated with any of the\n   * normal joi error properties. If validation fails and another error is found before the error\n   * override, that error will be returned and the override will be ignored (unless the `abortEarly`\n   * option has been set to `false`).\n   */\n  error(err: Error | ValidationErrorFunction): this\n\n  /**\n   * Annotates the key with an example value, must be valid.\n   */\n  example(value: any, options?: { override: boolean }): this\n\n  /**\n   * Marks a key as required which will not allow undefined as value. All keys are optional by default.\n   */\n  exist(): this\n\n  /**\n   * Adds an external validation rule.\n   *\n   * Note that external validation rules are only called after the all other validation rules for the entire schema (from the value root) are checked.\n   * This means that any changes made to the value by the external rules are not available to any other validation rules during the non-external validation phase.\n   * If schema validation failed, no external validation rules are called.\n   */\n  external(method: ExternalValidationFunction, description?: string): this\n\n  /**\n   * Returns a sub-schema based on a path of object keys or schema ids.\n   *\n   * @param path - a dot `.` separated path string or a pre-split array of path keys. The keys must match the sub-schema id or object key (if no id was explicitly set).\n   */\n  extract(path: string | string[]): Schema\n\n  /**\n   * Sets a failover value if the original value fails passing validation.\n   *\n   * @param value - the failover value. value supports references. value may be assigned a function which returns the default value.\n   *\n   * If value is specified as a function that accepts a single parameter, that parameter will be a context object that can be used to derive the resulting value.\n   * Note that if value is an object, any changes to the object after `failover()` is called will change the reference and any future assignment.\n   * Use a function when setting a dynamic value (e.g. the current time).\n   * Using a function with a single argument performs some internal cloning which has a performance impact.\n   * If you do not need access to the context, define the function without any arguments.\n   */\n  failover(value: any): this\n\n  /**\n   * Marks a key as forbidden which will not allow any value except undefined. Used to explicitly forbid keys.\n   */\n  forbidden(): this\n\n  /**\n   * Returns a new schema where each of the path keys listed have been modified.\n   *\n   * @param key - an array of key strings, a single key string, or an array of arrays of pre-split key strings.\n   * @param adjuster - a function which must return a modified schema.\n   */\n  fork(key: string | string[] | string[][], adjuster: SchemaFunction): this\n\n  /**\n   * Sets a schema id for reaching into the schema via `any.extract()`.\n   * If no id is set, the schema id defaults to the object key it is associated with.\n   * If the schema is used in an array or alternatives type and no id is set, the schema in unreachable.\n   */\n  id(name?: string): this\n\n  /**\n   * Disallows values.\n   */\n  invalid(...values: any[]): this\n\n  /**\n   * Same as `rule({ keep: true })`.\n   *\n   * Note that `keep()` will terminate the current ruleset and cannot be followed by another rule option.\n   * Use `rule()` to apply multiple rule options.\n   */\n  keep(): this\n\n  /**\n   * Overrides the key name in error messages.\n   */\n  label(name: string): this\n\n  /**\n   * Same as `rule({ message })`.\n   *\n   * Note that `message()` will terminate the current ruleset and cannot be followed by another rule option.\n   * Use `rule()` to apply multiple rule options.\n   */\n  message(message: string): this\n\n  /**\n   * Same as `any.prefs({ messages })`.\n   * Note that while `any.message()` applies only to the last rule or ruleset, `any.messages()` applies to the entire schema.\n   */\n  messages(messages: LanguageMessages): this\n\n  /**\n   * Attaches metadata to the key.\n   */\n  meta(meta: object): this\n\n  /**\n   * Disallows values.\n   */\n  not(...values: any[]): this\n\n  /**\n   * Annotates the key\n   */\n  note(...notes: string[]): this\n\n  /**\n   * Requires the validated value to match of the provided `any.allow()` values.\n   * It has not effect when called together with `any.valid()` since it already sets the requirements.\n   * When used with `any.allow()` it converts it to an `any.valid()`.\n   */\n  only(): this\n\n  /**\n   * Marks a key as optional which will allow undefined as values. Used to annotate the schema for readability as all keys are optional by default.\n   */\n  optional(): this\n\n  /**\n   * Overrides the global validate() options for the current key and any sub-key.\n   */\n  options(options: ValidationOptions): this\n\n  /**\n   * Overrides the global validate() options for the current key and any sub-key.\n   */\n  prefs(options: ValidationOptions): this\n\n  /**\n   * Overrides the global validate() options for the current key and any sub-key.\n   */\n  preferences(options: ValidationOptions): this\n\n  /**\n   * Sets the presence mode for the schema.\n   */\n  presence(mode: PresenceMode): this\n\n  /**\n   * Outputs the original untouched value instead of the casted value.\n   */\n  raw(enabled?: boolean): this\n\n  /**\n   * Marks a key as required which will not allow undefined as value. All keys are optional by default.\n   */\n  required(): this\n\n  /**\n   * Applies a set of rule options to the current ruleset or last rule added.\n   *\n   * When applying rule options, the last rule (e.g. `min()`) is used unless there is an active ruleset defined (e.g. `$.min().max()`)\n   * in which case the options are applied to all the provided rules.\n   * Once `rule()` is called, the previous rules can no longer be modified and any active ruleset is terminated.\n   *\n   * Rule modifications can only be applied to supported rules.\n   * Most of the `any` methods do not support rule modifications because they are implemented using schema flags (e.g. `required()`) or special\n   * internal implementation (e.g. `valid()`).\n   * In those cases, use the `any.messages()` method to override the error codes for the errors you want to customize.\n   */\n  rule(options: RuleOptions): this\n\n  /**\n   * Registers a schema to be used by descendants of the current schema in named link references.\n   */\n  shared(ref: Schema): this\n\n  /**\n   * Sets the options.convert options to false which prevent type casting for the current key and any child keys.\n   */\n  strict(isStrict?: boolean): this\n\n  /**\n   * Marks a key to be removed from a resulting object or array after validation. Used to sanitize output.\n   * @param [enabled=true] - if true, the value is stripped, otherwise the validated value is retained. Defaults to true.\n   */\n  strip(enabled?: boolean): this\n\n  /**\n   * Annotates the key\n   */\n  tag(...tags: string[]): this\n\n  /**\n   * Applies any assigned target alterations to a copy of the schema that were applied via `any.alter()`.\n   */\n  tailor(targets: string | string[]): Schema\n\n  /**\n   * Annotates the key with an unit name.\n   */\n  unit(name: string): this\n\n  /**\n   * Adds the provided values into the allowed whitelist and marks them as the only valid values allowed.\n   */\n  valid(...values: any[]): this\n\n  /**\n   * Validates a value using the schema and options.\n   */\n  validate(value: any, options?: ValidationOptions): ValidationResult\n\n  /**\n   * Validates a value using the schema and options.\n   */\n  validateAsync(value: any, options?: AsyncValidationOptions): Promise<any>\n\n  /**\n   * Same as `rule({ warn: true })`.\n   * Note that `warn()` will terminate the current ruleset and cannot be followed by another rule option.\n   * Use `rule()` to apply multiple rule options.\n   */\n  warn(): this\n\n  /**\n   * Generates a warning.\n   * When calling `any.validateAsync()`, set the `warning` option to true to enable warnings.\n   * Warnings are reported separately from errors alongside the result value via the warning key (i.e. `{ value, warning }`).\n   * Warning are always included when calling `any.validate()`.\n   */\n  warning(code: string, context?: Context): this\n\n  /**\n   * Converts the type into an alternatives type where the conditions are merged into the type definition where:\n   */\n  when(ref: string | Reference, options: WhenOptions): this\n\n  /**\n   * Converts the type into an alternatives type where the conditions are merged into the type definition where:\n   */\n  when(ref: Schema, options: WhenSchemaOptions): this\n}\n\ninterface Description {\n  type?: Types | string\n  label?: string\n  description?: string\n  flags?: object\n  notes?: string[]\n  tags?: string[]\n  meta?: any[]\n  example?: any[]\n  valids?: any[]\n  invalids?: any[]\n  unit?: string\n  options?: ValidationOptions\n  [key: string]: any\n}\n\ninterface Context {\n  [key: string]: any\n  key?: string\n  label?: string\n  value?: any\n}\n\ninterface State {\n  key?: string\n  path: Array<string | number>\n  parent?: any\n  reference?: any\n  ancestors?: any\n  localize?(...args: any[]): State\n}\n\ninterface BooleanSchema extends AnySchema {\n  /**\n   * Allows for additional values to be considered valid booleans by converting them to false during validation.\n   * String comparisons are by default case insensitive,\n   * see `boolean.sensitive()` to change this behavior.\n   * @param values - strings, numbers or arrays of them\n   */\n  falsy(...values: Array<string | number>): this\n\n  /**\n   * Allows the values provided to truthy and falsy as well as the \"true\" and \"false\" default conversion\n   * (when not in `strict()` mode) to be matched in a case insensitive manner.\n   */\n  sensitive(enabled?: boolean): this\n\n  /**\n   * Allows for additional values to be considered valid booleans by converting them to true during validation.\n   * String comparisons are by default case insensitive, see `boolean.sensitive()` to change this behavior.\n   * @param values - strings, numbers or arrays of them\n   */\n  truthy(...values: Array<string | number>): this\n}\n\ninterface NumberSchema extends AnySchema {\n  /**\n   * Specifies that the value must be greater than limit.\n   * It can also be a reference to another field.\n   */\n  greater(limit: number | Reference): this\n\n  /**\n   * Requires the number to be an integer (no floating point).\n   */\n  integer(): this\n\n  /**\n   * Specifies that the value must be less than limit.\n   * It can also be a reference to another field.\n   */\n  less(limit: number | Reference): this\n\n  /**\n   * Specifies the maximum value.\n   * It can also be a reference to another field.\n   */\n  max(limit: number | Reference): this\n\n  /**\n   * Specifies the minimum value.\n   * It can also be a reference to another field.\n   */\n  min(limit: number | Reference): this\n\n  /**\n   * Specifies that the value must be a multiple of base.\n   */\n  multiple(base: number | Reference): this\n\n  /**\n   * Requires the number to be negative.\n   */\n  negative(): this\n\n  /**\n   * Requires the number to be a TCP port, so between 0 and 65535.\n   */\n  port(): this\n\n  /**\n   * Requires the number to be positive.\n   */\n  positive(): this\n\n  /**\n   * Specifies the maximum number of decimal places where:\n   * @param limit - the maximum number of decimal places allowed.\n   */\n  precision(limit: number): this\n\n  /**\n   * Requires the number to be negative or positive.\n   */\n  sign(sign: \"positive\" | \"negative\"): this\n\n  /**\n   * Allows the number to be outside of JavaScript's safety range (Number.MIN_SAFE_INTEGER & Number.MAX_SAFE_INTEGER).\n   */\n  unsafe(enabled?: any): this\n}\n\ninterface StringSchema extends AnySchema {\n  /**\n   * Requires the string value to only contain a-z, A-Z, and 0-9.\n   */\n  alphanum(): this\n\n  /**\n   * Requires the string value to be a valid base64 string; does not check the decoded value.\n   */\n  base64(options?: Base64Options): this\n\n  /**\n   * Sets the required string case.\n   */\n  case(direction: \"upper\" | \"lower\"): this\n\n  /**\n   * Requires the number to be a credit card number (Using Lunh Algorithm).\n   */\n  creditCard(): this\n\n  /**\n   * Requires the string value to be a valid data URI string.\n   */\n  dataUri(options?: DataUriOptions): this\n\n  /**\n   * Requires the string value to be a valid domain.\n   */\n  domain(options?: DomainOptions): this\n\n  /**\n   * Requires the string value to be a valid email address.\n   */\n  email(options?: EmailOptions): this\n\n  /**\n   * Requires the string value to be a valid GUID.\n   */\n  guid(options?: GuidOptions): this\n\n  /**\n   * Requires the string value to be a valid hexadecimal string.\n   */\n  hex(options?: HexOptions): this\n\n  /**\n   * Requires the string value to be a valid hostname as per RFC1123.\n   */\n  hostname(): this\n\n  /**\n   * Allows the value to match any whitelist of blacklist item in a case insensitive comparison.\n   */\n  insensitive(): this\n\n  /**\n   * Requires the string value to be a valid ip address.\n   */\n  ip(options?: IpOptions): this\n\n  /**\n   * Requires the string value to be in valid ISO 8601 date format.\n   */\n  isoDate(): this\n\n  /**\n   * Requires the string value to be in valid ISO 8601 duration format.\n   */\n  isoDuration(): this\n\n  /**\n   * Specifies the exact string length required\n   * @param limit - the required string length. It can also be a reference to another field.\n   * @param encoding - if specified, the string length is calculated in bytes using the provided encoding.\n   */\n  length(limit: number | Reference, encoding?: string): this\n\n  /**\n   * Requires the string value to be all lowercase. If the validation convert option is on (enabled by default), the string will be forced to lowercase.\n   */\n  lowercase(): this\n\n  /**\n   * Specifies the maximum number of string characters.\n   * @param limit - the maximum number of string characters allowed. It can also be a reference to another field.\n   * @param encoding - if specified, the string length is calculated in bytes using the provided encoding.\n   */\n  max(limit: number | Reference, encoding?: string): this\n\n  /**\n   * Specifies the minimum number string characters.\n   * @param limit - the minimum number of string characters required. It can also be a reference to another field.\n   * @param encoding - if specified, the string length is calculated in bytes using the provided encoding.\n   */\n  min(limit: number | Reference, encoding?: string): this\n\n  /**\n   * Requires the string value to be in a unicode normalized form. If the validation convert option is on (enabled by default), the string will be normalized.\n   * @param [form='NFC'] - The unicode normalization form to use. Valid values: NFC [default], NFD, NFKC, NFKD\n   */\n  normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): this\n\n  /**\n   * Defines a regular expression rule.\n   * @param pattern - a regular expression object the string value must match against.\n   * @param options - optional, can be:\n   *   Name for patterns (useful with multiple patterns). Defaults to 'required'.\n   *   An optional configuration object with the following supported properties:\n   *     name - optional pattern name.\n   *     invert - optional boolean flag. Defaults to false behavior. If specified as true, the provided pattern will be disallowed instead of required.\n   */\n  pattern(pattern: RegExp, options?: string | StringRegexOptions): this\n\n  /**\n   * Defines a regular expression rule.\n   * @param pattern - a regular expression object the string value must match against.\n   * @param options - optional, can be:\n   *   Name for patterns (useful with multiple patterns). Defaults to 'required'.\n   *   An optional configuration object with the following supported properties:\n   *     name - optional pattern name.\n   *     invert - optional boolean flag. Defaults to false behavior. If specified as true, the provided pattern will be disallowed instead of required.\n   */\n  regex(pattern: RegExp, options?: string | StringRegexOptions): this\n\n  /**\n   * Replace characters matching the given pattern with the specified replacement string where:\n   * @param pattern - a regular expression object to match against, or a string of which all occurrences will be replaced.\n   * @param replacement - the string that will replace the pattern.\n   */\n  replace(pattern: RegExp | string, replacement: string): this\n\n  /**\n   * Requires the string value to only contain a-z, A-Z, 0-9, and underscore _.\n   */\n  token(): this\n\n  /**\n   * Requires the string value to contain no whitespace before or after. If the validation convert option is on (enabled by default), the string will be trimmed.\n   * @param [enabled=true] - optional parameter defaulting to true which allows you to reset the behavior of trim by providing a falsy value.\n   */\n  trim(enabled?: any): this\n\n  /**\n   * Specifies whether the string.max() limit should be used as a truncation.\n   * @param [enabled=true] - optional parameter defaulting to true which allows you to reset the behavior of truncate by providing a falsy value.\n   */\n  truncate(enabled?: boolean): this\n\n  /**\n   * Requires the string value to be all uppercase. If the validation convert option is on (enabled by default), the string will be forced to uppercase.\n   */\n  uppercase(): this\n\n  /**\n   * Requires the string value to be a valid RFC 3986 URI.\n   */\n  uri(options?: UriOptions): this\n\n  /**\n   * Requires the string value to be a valid GUID.\n   */\n  uuid(options?: GuidOptions): this\n}\n\ninterface SymbolSchema extends AnySchema {\n  // TODO: support number and symbol index\n  map(\n    iterable:\n      | Iterable<[string | number | boolean | symbol, symbol]>\n      | { [key: string]: symbol }\n  ): this\n}\n\ninterface ArraySortOptions {\n  /**\n   * @default 'ascending'\n   */\n  order?: \"ascending\" | \"descending\"\n  by?: string | Reference\n}\n\ninterface ArrayUniqueOptions extends HierarchySeparatorOptions {\n  /**\n   * if true, undefined values for the dot notation string comparator will not cause the array to fail on uniqueness.\n   *\n   * @default false\n   */\n  ignoreUndefined?: boolean\n}\n\ntype ComparatorFunction = (a: any, b: any) => boolean\n\ninterface ArraySchema extends AnySchema {\n  /**\n   * Verifies that an assertion passes for at least one item in the array, where:\n   * `schema` - the validation rules required to satisfy the assertion. If the `schema` includes references, they are resolved against\n   * the array item being tested, not the value of the `ref` target.\n   */\n  has(schema: SchemaLike): this\n\n  /**\n   * List the types allowed for the array values.\n   * If a given type is .required() then there must be a matching item in the array.\n   * If a type is .forbidden() then it cannot appear in the array.\n   * Required items can be added multiple times to signify that multiple items must be found.\n   * Errors will contain the number of items that didn't match.\n   * Any unmatched item having a label will be mentioned explicitly.\n   *\n   * @param type - a joi schema object to validate each array item against.\n   */\n  items(...types: SchemaLikeWithoutArray[]): this\n\n  /**\n   * Specifies the exact number of items in the array.\n   */\n  length(limit: number | Reference): this\n\n  /**\n   * Specifies the maximum number of items in the array.\n   */\n  max(limit: number | Reference): this\n\n  /**\n   * Specifies the minimum number of items in the array.\n   */\n  min(limit: number | Reference): this\n\n  /**\n   * Lists the types in sequence order for the array values where:\n   * @param type - a joi schema object to validate against each array item in sequence order. type can be multiple values passed as individual arguments.\n   * If a given type is .required() then there must be a matching item with the same index position in the array.\n   * Errors will contain the number of items that didn't match.\n   * Any unmatched item having a label will be mentioned explicitly.\n   */\n  ordered(...types: SchemaLikeWithoutArray[]): this\n\n  /**\n   * Allow single values to be checked against rules as if it were provided as an array.\n   * enabled can be used with a falsy value to go back to the default behavior.\n   */\n  single(enabled?: any): this\n\n  /**\n   * Sorts the array by given order.\n   */\n  sort(options?: ArraySortOptions): this\n\n  /**\n   * Allow this array to be sparse.\n   * enabled can be used with a falsy value to go back to the default behavior.\n   */\n  sparse(enabled?: any): this\n\n  /**\n   * Requires the array values to be unique.\n   * Remember that if you provide a custom comparator function,\n   * different types can be passed as parameter depending on the rules you set on items.\n   * Be aware that a deep equality is performed on elements of the array having a type of object,\n   * a performance penalty is to be expected for this kind of operation.\n   */\n  unique(\n    comparator?: string | ComparatorFunction,\n    options?: ArrayUniqueOptions\n  ): this\n}\n\ninterface ObjectPatternOptions {\n  fallthrough?: boolean\n  matches: SchemaLike | Reference\n}\n\nexport interface ObjectSchema<TSchema = any> extends AnySchema {\n  /**\n   * Defines an all-or-nothing relationship between keys where if one of the peers is present, all of them are required as well.\n   *\n   * Optional settings must be the last argument.\n   */\n  and(...peers: Array<string | HierarchySeparatorOptions>): this\n\n  /**\n   * Appends the allowed object keys. If schema is null, undefined, or {}, no changes will be applied.\n   */\n  append(schema?: SchemaMap<TSchema>): this\n\n  /**\n   * Verifies an assertion where.\n   */\n  assert(ref: string | Reference, schema: SchemaLike, message?: string): this\n\n  /**\n   * Requires the object to be an instance of a given constructor.\n   *\n   * @param constructor - the constructor function that the object must be an instance of.\n   * @param name - an alternate name to use in validation errors. This is useful when the constructor function does not have a name.\n   */\n  // tslint:disable-next-line:ban-types\n  instance(constructor: Function, name?: string): this\n\n  /**\n   * Sets or extends the allowed object keys.\n   */\n  keys(schema?: SchemaMap<TSchema>): this\n\n  /**\n   * Specifies the exact number of keys in the object.\n   */\n  length(limit: number): this\n\n  /**\n   * Specifies the maximum number of keys in the object.\n   */\n  max(limit: number | Reference): this\n\n  /**\n   * Specifies the minimum number of keys in the object.\n   */\n  min(limit: number | Reference): this\n\n  /**\n   * Defines a relationship between keys where not all peers can be present at the same time.\n   *\n   * Optional settings must be the last argument.\n   */\n  nand(...peers: Array<string | HierarchySeparatorOptions>): this\n\n  /**\n   * Defines a relationship between keys where one of the peers is required (and more than one is allowed).\n   *\n   * Optional settings must be the last argument.\n   */\n  or(...peers: Array<string | HierarchySeparatorOptions>): this\n\n  /**\n   * Defines an exclusive relationship between a set of keys where only one is allowed but none are required.\n   *\n   * Optional settings must be the last argument.\n   */\n  oxor(...peers: Array<string | HierarchySeparatorOptions>): this\n\n  /**\n   * Specify validation rules for unknown keys matching a pattern.\n   *\n   * @param pattern - a pattern that can be either a regular expression or a joi schema that will be tested against the unknown key names\n   * @param schema - the schema object matching keys must validate against\n   */\n  pattern(\n    pattern: RegExp | SchemaLike,\n    schema: SchemaLike,\n    options?: ObjectPatternOptions\n  ): this\n\n  /**\n   * Requires the object to be a Joi reference.\n   */\n  ref(): this\n\n  /**\n   * Requires the object to be a `RegExp` object.\n   */\n  regex(): this\n\n  /**\n   * Renames a key to another name (deletes the renamed key).\n   */\n  rename(from: string | RegExp, to: string, options?: RenameOptions): this\n\n  /**\n   * Requires the object to be a Joi schema instance.\n   */\n  schema(type?: SchemaLike): this\n\n  /**\n   * Overrides the handling of unknown keys for the scope of the current object only (does not apply to children).\n   */\n  unknown(allow?: boolean): this\n\n  /**\n   * Requires the presence of other keys whenever the specified key is present.\n   */\n  with(\n    key: string,\n    peers: string | string[],\n    options?: HierarchySeparatorOptions\n  ): this\n\n  /**\n   * Forbids the presence of other keys whenever the specified is present.\n   */\n  without(\n    key: string,\n    peers: string | string[],\n    options?: HierarchySeparatorOptions\n  ): this\n\n  /**\n   * Defines an exclusive relationship between a set of keys. one of them is required but not at the same time.\n   *\n   * Optional settings must be the last argument.\n   */\n  xor(...peers: Array<string | HierarchySeparatorOptions>): this\n}\n\ninterface BinarySchema extends AnySchema {\n  /**\n   * Sets the string encoding format if a string input is converted to a buffer.\n   */\n  encoding(encoding: string): this\n\n  /**\n   * Specifies the minimum length of the buffer.\n   */\n  min(limit: number | Reference): this\n\n  /**\n   * Specifies the maximum length of the buffer.\n   */\n  max(limit: number | Reference): this\n\n  /**\n   * Specifies the exact length of the buffer:\n   */\n  length(limit: number | Reference): this\n}\n\ninterface DateSchema extends AnySchema {\n  /**\n   * Specifies that the value must be greater than date.\n   * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,\n   * allowing to explicitly ensure a date is either in the past or in the future.\n   * It can also be a reference to another field.\n   */\n  greater(date: \"now\" | Date | number | string | Reference): this\n\n  /**\n   * Requires the string value to be in valid ISO 8601 date format.\n   */\n  iso(): this\n\n  /**\n   * Specifies that the value must be less than date.\n   * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,\n   * allowing to explicitly ensure a date is either in the past or in the future.\n   * It can also be a reference to another field.\n   */\n  less(date: \"now\" | Date | number | string | Reference): this\n\n  /**\n   * Specifies the oldest date allowed.\n   * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,\n   * allowing to explicitly ensure a date is either in the past or in the future.\n   * It can also be a reference to another field.\n   */\n  min(date: \"now\" | Date | number | string | Reference): this\n\n  /**\n   * Specifies the latest date allowed.\n   * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,\n   * allowing to explicitly ensure a date is either in the past or in the future.\n   * It can also be a reference to another field.\n   */\n  max(date: \"now\" | Date | number | string | Reference): this\n\n  /**\n   * Requires the value to be a timestamp interval from Unix Time.\n   * @param type - the type of timestamp (allowed values are unix or javascript [default])\n   */\n  timestamp(type?: \"javascript\" | \"unix\"): this\n}\n\ninterface FunctionSchema extends ObjectSchema {\n  /**\n   * Specifies the arity of the function where:\n   * @param n - the arity expected.\n   */\n  arity(n: number): this\n\n  /**\n   * Requires the function to be a class.\n   */\n  class(): this\n\n  /**\n   * Specifies the minimal arity of the function where:\n   * @param n - the minimal arity expected.\n   */\n  minArity(n: number): this\n\n  /**\n   * Specifies the minimal arity of the function where:\n   * @param n - the minimal arity expected.\n   */\n  maxArity(n: number): this\n}\n\ninterface AlternativesSchema extends AnySchema {\n  /**\n   * Adds a conditional alternative schema type, either based on another key value, or a schema peeking into the current value.\n   */\n  conditional(ref: string | Reference, options: WhenOptions): this\n  conditional(ref: Schema, options: WhenSchemaOptions): this\n\n  /**\n   * Requires the validated value to match a specific set of the provided alternative.try() schemas.\n   * Cannot be combined with `alternatives.conditional()`.\n   */\n  match(mode: \"any\" | \"all\" | \"one\"): this\n\n  /**\n   * Adds an alternative schema type for attempting to match against the validated value.\n   */\n  try(...types: SchemaLikeWithoutArray[]): this\n}\n\ninterface LinkSchema extends AnySchema {\n  /**\n   * Same as `any.concat()` but the schema is merged after the link is resolved which allows merging with schemas of the same type as the resolved link.\n   * Will throw an exception during validation if the merged types are not compatible.\n   */\n  concat(schema: Schema): this\n\n  /**\n   * Initializes the schema after constructions for cases where the schema has to be constructed first and then initialized.\n   * If `ref` was not passed to the constructor, `link.ref()` must be called prior to usaged.\n   */\n  ref(ref: string): this\n}\n\ninterface Reference extends Exclude<ReferenceOptions, \"prefix\"> {\n  depth: number\n  type: string\n  key: string\n  root: string\n  path: string[]\n  display: string\n  toString(): string\n}\n\ntype ExtensionBoundSchema = Schema & SchemaInternals\n\ninterface RuleArgs {\n  name: string\n  ref?: boolean\n  assert?: ((value: any) => boolean) | AnySchema\n  message?: string\n\n  /**\n   * Undocumented properties\n   */\n  normalize?(value: any): any\n}\n\ntype RuleMethod = (...args: any[]) => any\n\ninterface ExtensionRule {\n  /**\n   * alternative name for this rule.\n   */\n  alias?: string\n  /**\n   * whether rule supports multiple invocations.\n   */\n  multi?: boolean\n  /**\n   * Dual rule: converts or validates.\n   */\n  convert?: boolean\n  /**\n   * list of arguments accepted by `method`.\n   */\n  args?: Array<RuleArgs | string>\n  /**\n   * rule body.\n   */\n  method?: RuleMethod | false\n  /**\n   * validation function.\n   */\n  validate?(\n    value: any,\n    helpers: any,\n    args: Record<string, any>,\n    options: any\n  ): any\n\n  /**\n   * undocumented flags.\n   */\n  priority?: boolean\n  manifest?: boolean\n}\n\ninterface CoerceResult {\n  errors?: ErrorReport[]\n  value?: any\n}\n\ntype CoerceFunction = (value: any, helpers: CustomHelpers) => CoerceResult\n\ninterface CoerceObject {\n  method: CoerceFunction\n  from?: string | string[]\n}\n\ninterface ExtensionFlag {\n  setter?: string\n  default?: any\n}\n\ninterface ExtensionTermManifest {\n  mapped: {\n    from: string\n    to: string\n  }\n}\n\ninterface ExtensionTerm {\n  init: any[] | null\n  register?: any\n  manifest?: Record<string, \"schema\" | \"single\" | ExtensionTermManifest>\n}\n\ninterface Extension {\n  type: string\n  args?(...args: SchemaLike[]): Schema\n  base?: Schema\n  coerce?: CoerceFunction | CoerceObject\n  flags?: Record<string, ExtensionFlag>\n  manifest?: {\n    build?(obj: ExtensionBoundSchema, desc: Record<string, any>): any\n  }\n  messages?: LanguageMessages | string\n  modifiers?: Record<string, (rule: any, enabled?: boolean) => any>\n  overrides?: Record<string, (value: any) => Schema>\n  prepare?(value: any, helpers: CustomHelpers): any\n  rebuild?(schema: ExtensionBoundSchema): void\n  rules?: Record<string, ExtensionRule & ThisType<SchemaInternals>>\n  terms?: Record<string, ExtensionTerm>\n  validate?(value: any, helpers: CustomHelpers): any\n\n  /**\n   * undocumented options\n   */\n  cast?: Record<\n    string,\n    { from(value: any): any; to(value: any, helpers: CustomHelpers): any }\n  >\n  properties?: Record<string, any>\n}\n\ntype ExtensionFactory = (joi: PluginOptionsSchemaJoi) => Extension\n\ninterface Err {\n  toString(): string\n}\n\n// --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n\nexport interface PluginOptionsSchemaJoi {\n  /**\n   * Current version of the joi package.\n   */\n  version: string\n\n  ValidationError: new (\n    message: string,\n    details: any,\n    original: any\n  ) => ValidationError\n\n  /**\n   * Generates a schema object that matches any data type.\n   */\n  any(): AnySchema\n\n  /**\n   * Generates a schema object that matches an array data type.\n   */\n  array(): ArraySchema\n\n  /**\n   * Generates a schema object that matches a boolean data type (as well as the strings 'true', 'false', 'yes', and 'no'). Can also be called via bool().\n   */\n  bool(): BooleanSchema\n\n  /**\n   * Generates a schema object that matches a boolean data type (as well as the strings 'true', 'false', 'yes', and 'no'). Can also be called via bool().\n   */\n  boolean(): BooleanSchema\n\n  /**\n   * Generates a schema object that matches a Buffer data type (as well as the strings which will be converted to Buffers).\n   */\n  binary(): BinarySchema\n\n  /**\n   * Generates a schema object that matches a date type (as well as a JavaScript date string or number of milliseconds).\n   */\n  date(): DateSchema\n\n  /**\n   * Generates a schema object that matches a function type.\n   */\n  func(): FunctionSchema\n\n  /**\n   * Generates a schema object that matches a function type.\n   */\n  function(): FunctionSchema\n\n  /**\n   * Generates a schema object that matches a number data type (as well as strings that can be converted to numbers).\n   */\n  number(): NumberSchema\n\n  /**\n   * Generates a schema object that matches an object data type (as well as JSON strings that have been parsed into objects).\n   */\n  // tslint:disable-next-line:no-unnecessary-generics\n  object<TSchema = any, T = TSchema>(\n    schema?: SchemaMap<T>\n  ): ObjectSchema<TSchema>\n\n  /**\n   * Generates a schema object that matches a string data type. Note that empty strings are not allowed by default and must be enabled with allow('').\n   */\n  string(): StringSchema\n\n  /**\n   * Generates a schema object that matches any symbol.\n   */\n  symbol(): SymbolSchema\n\n  /**\n   * Generates a type that will match one of the provided alternative schemas\n   */\n  alternatives(types: SchemaLike[]): AlternativesSchema\n  alternatives(...types: SchemaLike[]): AlternativesSchema\n\n  /**\n   * Alias for `alternatives`\n   */\n  alt(types: SchemaLike[]): AlternativesSchema\n  alt(...types: SchemaLike[]): AlternativesSchema\n\n  /**\n   * Links to another schema node and reuses it for validation, typically for creative recursive schemas.\n   *\n   * @param ref - the reference to the linked schema node.\n   * Cannot reference itself or its children as well as other links.\n   * Links can be expressed in relative terms like value references (`Joi.link('...')`),\n   * in absolute terms from the schema run-time root (`Joi.link('/a')`),\n   * or using schema ids implicitly using object keys or explicitly using `any.id()` (`Joi.link('#a.b.c')`).\n   */\n  link(ref?: string): LinkSchema\n\n  /**\n   * Validates a value against a schema and throws if validation fails.\n   *\n   * @param value - the value to validate.\n   * @param schema - the schema object.\n   * @param message - optional message string prefix added in front of the error message. may also be an Error object.\n   */\n  assert(value: any, schema: Schema, options?: ValidationOptions): void\n  assert(\n    value: any,\n    schema: Schema,\n    message: string | Error,\n    options?: ValidationOptions\n  ): void\n\n  /**\n   * Validates a value against a schema, returns valid object, and throws if validation fails.\n   *\n   * @param value - the value to validate.\n   * @param schema - the schema object.\n   * @param message - optional message string prefix added in front of the error message. may also be an Error object.\n   */\n  attempt(value: any, schema: Schema, options?: ValidationOptions): any\n  attempt(\n    value: any,\n    schema: Schema,\n    message: string | Error,\n    options?: ValidationOptions\n  ): any\n\n  cache: CacheConfiguration\n\n  /**\n   * Converts literal schema definition to joi schema object (or returns the same back if already a joi schema object).\n   */\n  compile(schema: SchemaLike, options?: CompileOptions): Schema\n\n  /**\n   * Checks if the provided preferences are valid.\n   *\n   * Throws an exception if the prefs object is invalid.\n   *\n   * The method is provided to perform inputs validation for the `any.validate()` and `any.validateAsync()` methods.\n   * Validation is not performed automatically for performance reasons. Instead, manually validate the preferences passed once and reuse.\n   */\n  checkPreferences(prefs: ValidationOptions): void\n\n  /**\n   * Creates a custom validation schema.\n   */\n  custom(fn: CustomValidator, description?: string): Schema\n\n  /**\n   * Creates a new Joi instance that will apply defaults onto newly created schemas\n   * through the use of the fn function that takes exactly one argument, the schema being created.\n   *\n   * @param fn - The function must always return a schema, even if untransformed.\n   */\n  defaults(fn: SchemaFunction): PluginOptionsSchemaJoi\n\n  /**\n   * Generates a dynamic expression using a template string.\n   */\n  expression(template: string, options?: ReferenceOptions): any\n\n  /**\n   * Creates a new Joi instance customized with the extension(s) you provide included.\n   */\n  extend(...extensions: Array<Extension | ExtensionFactory>): any\n\n  /**\n   * Creates a reference that when resolved, is used as an array of values to match against the rule.\n   */\n  in(ref: string, options?: ReferenceOptions): Reference\n\n  /**\n   * Checks whether or not the provided argument is an instance of ValidationError\n   */\n  isError(error: any): error is ValidationError\n\n  /**\n   * Checks whether or not the provided argument is an expression.\n   */\n  isExpression(expression: any): boolean\n\n  /**\n   * Checks whether or not the provided argument is a reference. It's especially useful if you want to post-process error messages.\n   */\n  isRef(ref: any): ref is Reference\n\n  /**\n   * Checks whether or not the provided argument is a joi schema.\n   */\n  isSchema(schema: any, options?: IsSchemaOptions): boolean\n\n  /**\n   * A special value used with `any.allow()`, `any.invalid()`, and `any.valid()` as the first value to reset any previously set values.\n   */\n  override: symbol\n\n  /**\n   * Generates a reference to the value of the named key.\n   */\n  ref(key: string, options?: ReferenceOptions): Reference\n\n  /**\n   * Returns an object where each key is a plain joi schema type.\n   * Useful for creating type shortcuts using deconstruction.\n   * Note that the types are already formed and do not need to be called as functions (e.g. `string`, not `string()`).\n   */\n  types(): {\n    alternatives: AlternativesSchema\n    any: AnySchema\n    array: ArraySchema\n    binary: BinarySchema\n    boolean: BooleanSchema\n    date: DateSchema\n    function: FunctionSchema\n    link: LinkSchema\n    number: NumberSchema\n    object: ObjectSchema\n    string: StringSchema\n    symbol: SymbolSchema\n  }\n\n  /**\n   * Generates a dynamic expression using a template string.\n   */\n  x(template: string, options?: ReferenceOptions): any\n\n  // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n  // Below are undocumented APIs. use at your own risk\n  // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n\n  /**\n   * Array of plugin definitions which get resolved automatically\n   */\n  subPlugins(...values: any[]): Schema\n\n  /**\n   * Whitelists a value\n   */\n  allow(...values: any[]): Schema\n\n  /**\n   * Adds the provided values into the allowed whitelist and marks them as the only valid values allowed.\n   */\n  valid(...values: any[]): Schema\n  equal(...values: any[]): Schema\n\n  /**\n   * Blacklists a value\n   */\n  invalid(...values: any[]): Schema\n  disallow(...values: any[]): Schema\n  not(...values: any[]): Schema\n\n  /**\n   * Marks a key as required which will not allow undefined as value. All keys are optional by default.\n   */\n  required(): Schema\n\n  /**\n   * Alias of `required`.\n   */\n  exist(): Schema\n\n  /**\n   * Marks a key as optional which will allow undefined as values. Used to annotate the schema for readability as all keys are optional by default.\n   */\n  optional(): Schema\n\n  /**\n   * Marks a key as forbidden which will not allow any value except undefined. Used to explicitly forbid keys.\n   */\n  forbidden(): Schema\n\n  /**\n   * Overrides the global validate() options for the current key and any sub-key.\n   */\n  preferences(options: ValidationOptions): Schema\n\n  /**\n   * Overrides the global validate() options for the current key and any sub-key.\n   */\n  prefs(options: ValidationOptions): Schema\n\n  /**\n   * Converts the type into an alternatives type where the conditions are merged into the type definition where:\n   */\n  when(ref: string | Reference, options: WhenOptions): AlternativesSchema\n  when(ref: Schema, options: WhenSchemaOptions): AlternativesSchema\n\n  /**\n   * Unsure, maybe alias for `compile`?\n   */\n  build(...args: any[]): any\n\n  /**\n   * Unsure, maybe alias for `preferences`?\n   */\n  options(...args: any[]): any\n\n  /**\n   * Unsure, maybe leaked from `@hapi/lab/coverage/initialize`\n   */\n  trace(...args: any[]): any\n  untrace(...args: any[]): any\n}\n"],"mappings":""}