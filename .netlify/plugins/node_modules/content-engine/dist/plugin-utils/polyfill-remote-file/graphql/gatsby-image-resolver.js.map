{"version":3,"file":"gatsby-image-resolver.js","names":["DEFAULT_PIXEL_DENSITIES","DEFAULT_BREAKPOINTS","DEFAULT_QUALITY","GATSBY_SHOULD_TRACK_IMAGE_CDN_URLS","includes","process","env","didShowTraceSVGRemovalWarning","gatsbyImageResolver","source","args","actions","store","isImage","layout","Error","url","width","height","formats","outputPixelDensities","breakpoints","fit","placeholder","PlaceholderType","DOMINANT_COLOR","TRACED_SVG","console","warn","quality","backgroundColor","sourceMetadata","format","getImageFormatFromMimeType","mimeType","filename","validateAndNormalizeFormats","imageSizes","calculateImageSizes","sizes","getSizesAttrFromLayout","presentationWidth","result","sources","fallback","undefined","getFormatValue","sortedFormats","Array","from","sort","a","b","fallbackSrc","images","map","shouldDispatch","dispatchLocalImageServiceJob","contentDigest","internal","Math","round","aspectRatio","cropFocus","src","generateImageUrl","descriptor","length","srcSet","createSrcSetFromImages","push","type","bgColor","generatePlaceholder","addGatsbyImageSourceUrl","presentationHeight","generateGatsbyImageFieldConfig","enums","description","getTypeName","stripIndent","defaultValue","getField","value","NonNull","List","resolve","sortNumeric","image","join","Number","calculateFixedImageSizes","calculateResponsiveImageSizes","requestedAspectRatio","densities","Set","filter","Boolean","calculated","calculateImageDimensions","isRequestedSizeLargerThanOriginal","invalidDimension","density","widthFromDensity","add","min","unscaledWidth","nonNullableWidth","originalWidth","size"],"sources":["../../../../src/plugin-utils/polyfill-remote-file/graphql/gatsby-image-resolver.ts"],"sourcesContent":["import { generateImageUrl } from \"../utils/url-generator\"\nimport { getImageFormatFromMimeType } from \"../utils/mime-type-helpers\"\nimport { stripIndent } from \"../utils/strip-indent\"\nimport {\n  dispatchLocalImageServiceJob,\n  shouldDispatch,\n} from \"../jobs/dispatchers\"\nimport { generatePlaceholder, PlaceholderType } from \"../placeholder-handler\"\nimport { ImageCropFocus, isImage } from \"../types\"\nimport { validateAndNormalizeFormats, calculateImageDimensions } from \"./utils\"\n\nimport type { Actions, Store } from \"../../../types\"\nimport type {\n  IRemoteFileNode,\n  IRemoteImageNode,\n  IGraphQLFieldConfigDefinition,\n  ImageFormat,\n  ImageLayout,\n  CalculateImageSizesArgs,\n} from \"../types\"\nimport type { getRemoteFileEnums } from \"./get-remote-file-enums\"\n\ninterface IGatsbyImageData {\n  sources: Array<{\n    srcSet: string\n    type: string\n    sizes: string\n  }>\n  fallback: {\n    srcSet: string\n    src: string\n    sizes: string\n  }\n}\n\ninterface ISourceMetadata {\n  width: number\n  height: number\n  format: ImageFormat\n  filename: string\n}\n\ntype IGatsbyImageDataArgs = Omit<\n  CalculateImageSizesArgs,\n  \"fit\" | \"outputPixelDensities\"\n> & {\n  formats?: Array<ImageFormat>\n  backgroundColor?: string\n  placeholder?: PlaceholderType | \"none\"\n  aspectRatio?: number\n  sizes?: string\n  cropFocus?: Array<ImageCropFocus>\n  fit?: CalculateImageSizesArgs[\"fit\"]\n  outputPixelDensities?: CalculateImageSizesArgs[\"outputPixelDensities\"]\n  quality?: number\n}\n\ntype ImageSizeArgs = CalculateImageSizesArgs & {\n  sourceMetadata: ISourceMetadata\n}\n\ninterface IImageSizes {\n  sizes: Array<number>\n  presentationWidth: number\n  presentationHeight: number\n  aspectRatio: number\n  unscaledWidth: number\n}\n\nconst DEFAULT_PIXEL_DENSITIES = [0.25, 0.5, 1, 2]\nconst DEFAULT_BREAKPOINTS = [750, 1080, 1366, 1920]\nconst DEFAULT_QUALITY = 75\n\nconst GATSBY_SHOULD_TRACK_IMAGE_CDN_URLS = [`true`, `1`].includes(\n  process.env.GATSBY_SHOULD_TRACK_IMAGE_CDN_URLS || ``\n)\n\nlet didShowTraceSVGRemovalWarning = false\nexport async function gatsbyImageResolver(\n  source: IRemoteFileNode,\n  args: IGatsbyImageDataArgs,\n  actions: Actions,\n  store?: Store\n): Promise<{\n  images: IGatsbyImageData\n  layout: string\n  width: number\n  height: number\n  backgroundColor?: string\n  placeholder?: { fallback: string } | undefined\n} | null> {\n  if (!isImage(source)) {\n    return null\n  }\n\n  if (!args.layout) {\n    throw new Error(`The \"layout\" argument is required for \"${source.url}\"`)\n  }\n\n  if (!args.width && !args.height) {\n    throw new Error(`\n      Either the \"width\" or \"height\" argument is required for \"${source.url}\"\n    `)\n  }\n\n  if (!args.formats) {\n    args.formats = [`auto`, `webp`, `avif`]\n  }\n\n  if (!args.outputPixelDensities) {\n    args.outputPixelDensities = DEFAULT_PIXEL_DENSITIES\n  }\n\n  if (!args.breakpoints) {\n    args.breakpoints = DEFAULT_BREAKPOINTS\n  }\n\n  if (!args.fit) {\n    args.fit = `cover`\n  }\n\n  if (!args.placeholder) {\n    args.placeholder = PlaceholderType.DOMINANT_COLOR\n  } else if (args.placeholder === PlaceholderType.TRACED_SVG) {\n    if (!didShowTraceSVGRemovalWarning) {\n      console.warn(\n        `\"TRACED_SVG\" placeholder argument value is no longer supported (used in gatsbyImage processing), falling back to \"DOMINANT_COLOR\". See https://gatsby.dev/tracesvg-removal/`\n      )\n      didShowTraceSVGRemovalWarning = true\n    }\n    args.placeholder = PlaceholderType.DOMINANT_COLOR\n  }\n\n  if (!args.quality) {\n    args.quality = DEFAULT_QUALITY\n  }\n\n  let backgroundColor = args.backgroundColor\n  const sourceMetadata: ISourceMetadata = {\n    width: source.width,\n    height: source.height,\n    format: getImageFormatFromMimeType(source.mimeType),\n    filename: source.filename,\n  }\n  const formats = validateAndNormalizeFormats(\n    args.formats,\n    sourceMetadata.format\n  )\n  const imageSizes = calculateImageSizes(\n    sourceMetadata,\n    args as CalculateImageSizesArgs\n  )\n  const sizes = getSizesAttrFromLayout(\n    args.layout,\n    imageSizes.presentationWidth\n  )\n  const result: Partial<IGatsbyImageData> & {\n    sources: IGatsbyImageData[\"sources\"]\n  } = {\n    sources: [],\n    fallback: undefined,\n  }\n\n  const getFormatValue = (format: ImageFormat): number => {\n    if (format === `avif`) {\n      return 3\n    }\n    if (format === `webp`) {\n      return 2\n    }\n\n    return 1\n  }\n\n  const sortedFormats = Array.from(formats).sort(\n    (a, b) => getFormatValue(b) - getFormatValue(a)\n  )\n\n  // Result will be used like this\n  // <picture>\n  // for each result.sources we create a <source srcset=\"...\" /> tag\n  // <img src=\"fallbacksrc\" srcset=\"fallbacksrcset\" />\n  // </picture>\n  for (const format of sortedFormats) {\n    let fallbackSrc: string | undefined = undefined\n    const images = imageSizes.sizes.map(width => {\n      if (shouldDispatch()) {\n        dispatchLocalImageServiceJob(\n          {\n            url: source.url,\n            mimeType: source.mimeType,\n            filename: source.filename,\n            contentDigest: source.internal.contentDigest,\n          },\n          {\n            width,\n            height: Math.round(width / imageSizes.aspectRatio),\n            format,\n            cropFocus: args.cropFocus,\n            quality: args.quality as number,\n          },\n          actions,\n          store\n        )\n      }\n\n      const src = generateImageUrl(\n        source,\n        {\n          width,\n          height: Math.round(width / imageSizes.aspectRatio),\n          format,\n          cropFocus: args.cropFocus,\n          quality: args.quality as number,\n        },\n        store\n      )\n\n      if (!fallbackSrc) {\n        fallbackSrc = src\n      }\n\n      return {\n        src,\n        descriptor:\n          args.layout === `fixed`\n            ? `${width / imageSizes.presentationWidth}x`\n            : `${width}w`,\n      }\n    })\n\n    // The latest format (by default will be jpg/png) is the fallback and doesn't need sources\n    if (format === sortedFormats[sortedFormats.length - 1] && fallbackSrc) {\n      result.fallback = {\n        src: fallbackSrc,\n        srcSet: createSrcSetFromImages(images),\n        sizes,\n      }\n    } else {\n      result.sources.push({\n        srcSet: createSrcSetFromImages(images),\n        type: `image/${format}`,\n        sizes,\n      })\n    }\n  }\n\n  let placeholder: { fallback: string } | undefined\n  if (args.placeholder !== `none`) {\n    const { fallback, backgroundColor: bgColor } = await generatePlaceholder(\n      source,\n      args.placeholder as PlaceholderType,\n      store\n    )\n\n    if (fallback) {\n      placeholder = { fallback }\n    }\n    if (bgColor) {\n      backgroundColor = bgColor\n    }\n  }\n\n  // Check if addGatsbyImageSourceUrl for backwards compatibility with older Gatsby versions\n  if (GATSBY_SHOULD_TRACK_IMAGE_CDN_URLS && actions.addGatsbyImageSourceUrl) {\n    actions.addGatsbyImageSourceUrl(source.url)\n  }\n\n  return {\n    images: result as IGatsbyImageData,\n    layout: args.layout,\n    width: imageSizes.presentationWidth,\n    height: imageSizes.presentationHeight,\n    placeholder,\n    backgroundColor,\n  }\n}\n\nexport function generateGatsbyImageFieldConfig(\n  enums: ReturnType<typeof getRemoteFileEnums>,\n  actions: Actions,\n  store?: Store\n): IGraphQLFieldConfigDefinition<\n  IRemoteFileNode | IRemoteImageNode,\n  ReturnType<typeof gatsbyImageResolver>,\n  IGatsbyImageDataArgs\n> {\n  return {\n    type: `GatsbyImageData`,\n    description: `Data used in the <GatsbyImage /> component. See https://gatsby.dev/img for more info.`,\n    args: {\n      layout: {\n        type: enums.layout.getTypeName(),\n        description: stripIndent`\n      The layout for the image.\n      FIXED: A static image sized, that does not resize according to the screen width\n      FULL_WIDTH: The image resizes to fit its container. Pass a \"sizes\" option if it isn't going to be the full width of the screen.\n      CONSTRAINED: Resizes to fit its container, up to a maximum width, at which point it will remain fixed in size.\n      `,\n        defaultValue: enums.layout.getField(`CONSTRAINED`).value,\n      },\n      width: {\n        type: `Int`,\n        description: stripIndent`\n  The display width of the generated image for layout = FIXED, and the display width of the largest image for layout = CONSTRAINED.\n  The actual largest image resolution will be this value multiplied by the largest value in outputPixelDensities\n  Ignored if layout = FLUID.\n  `,\n      },\n      height: {\n        type: `Int`,\n        description: stripIndent`\n  If set, the height of the generated image. If omitted, it is calculated from the supplied width, matching the aspect ratio of the source image.`,\n      },\n      placeholder: {\n        type: enums.placeholder.getTypeName(),\n        defaultValue: enums.placeholder.getField(`DOMINANT_COLOR`).value,\n        description: stripIndent`\n      Format of generated placeholder image, displayed while the main image loads.\n      BLURRED: a blurred, low resolution image, encoded as a base64 data URI\n      DOMINANT_COLOR: a solid color, calculated from the dominant color of the image (default).\n      TRACED_SVG: deprecated. Will use DOMINANT_COLOR.\n      NONE: no placeholder. Set the argument \"backgroundColor\" to use a fixed background color.`,\n      },\n      aspectRatio: {\n        type: `Float`,\n        description: stripIndent`\n      If set along with width or height, this will set the value of the other dimension to match the provided aspect ratio, cropping the image if needed.\n      If neither width or height is provided, height will be set based on the intrinsic width of the source image.\n      `,\n      },\n      formats: {\n        type: enums.format.NonNull.List.getTypeName(),\n        description: stripIndent`\n      The image formats to generate. Valid values are AUTO (meaning the same format as the source image), JPG, PNG, WEBP and AVIF.\n      The default value is [AUTO, WEBP, AVIF], and you should rarely need to change this. Take care if you specify JPG or PNG when you do\n      not know the formats of the source images, as this could lead to unwanted results such as converting JPEGs to PNGs. Specifying\n      both PNG and JPG is not supported and will be ignored.\n  `,\n        defaultValue: [\n          enums.format.getField(`AUTO`).value,\n          enums.format.getField(`WEBP`).value,\n          enums.format.getField(`AVIF`).value,\n        ],\n      },\n      outputPixelDensities: {\n        type: `[Float]`,\n        defaultValue: DEFAULT_PIXEL_DENSITIES,\n        description: stripIndent`\n      A list of image pixel densities to generate for FIXED and CONSTRAINED images. You should rarely need to change this. It will never generate images larger than the source, and will always include a 1x image.\n      Default is [ 1, 2 ] for fixed images, meaning 1x, 2x, and [0.25, 0.5, 1, 2] for fluid. In this case, an image with a fluid layout and width = 400 would generate images at 100, 200, 400 and 800px wide.\n      `,\n      },\n      breakpoints: {\n        type: `[Int]`,\n        defaultValue: DEFAULT_BREAKPOINTS,\n        description: stripIndent`\n  Specifies the image widths to generate. You should rarely need to change this. For FIXED and CONSTRAINED images it is better to allow these to be determined automatically,\n  based on the image size. For FULL_WIDTH images this can be used to override the default, which is [750, 1080, 1366, 1920].\n  It will never generate any images larger than the source.\n  `,\n      },\n      sizes: {\n        type: `String`,\n        description: stripIndent`\n      The \"sizes\" property, passed to the img tag. This describes the display size of the image.\n      This does not affect the generated images, but is used by the browser to decide which images to download. You can leave this blank for fixed images, or if the responsive image\n      container will be the full width of the screen. In these cases we will generate an appropriate value.\n  `,\n      },\n      backgroundColor: {\n        type: `String`,\n        description: `Background color applied to the wrapper, or when \"letterboxing\" an image to another aspect ratio.`,\n      },\n      fit: {\n        type: enums.fit.getTypeName(),\n        defaultValue: enums.fit.getField(`COVER`).value,\n      },\n      cropFocus: {\n        type: enums.cropFocus.List.getTypeName(),\n      },\n      quality: {\n        type: `Int`,\n        defaultValue: DEFAULT_QUALITY,\n      },\n    },\n    resolve(source, args): ReturnType<typeof gatsbyImageResolver> {\n      return gatsbyImageResolver(source, args, actions, store)\n    },\n  }\n}\n\nfunction sortNumeric(a: number, b: number): number {\n  return a - b\n}\n\nfunction createSrcSetFromImages(\n  images: Array<{ src: string; descriptor: string }>\n): string {\n  return images.map(image => `${image.src} ${image.descriptor}`).join(`,`)\n}\n\n// eslint-disable-next-line consistent-return\nfunction calculateImageSizes(\n  sourceMetadata: ISourceMetadata,\n  {\n    width,\n    height,\n    layout,\n    fit,\n    outputPixelDensities,\n    breakpoints,\n    aspectRatio,\n  }: CalculateImageSizesArgs\n): IImageSizes {\n  if (width && Number(width) <= 0) {\n    throw new Error(\n      `The provided width of \"${width}\" is incorrect. Dimensions should be a positive number.`\n    )\n  }\n\n  if (height && Number(height) <= 0) {\n    throw new Error(\n      `The provided height of \"${height}\" is incorrect. Dimensions should be a positive number.`\n    )\n  }\n\n  switch (layout) {\n    case `fixed`: {\n      return calculateFixedImageSizes({\n        width,\n        height,\n        fit,\n        sourceMetadata,\n        outputPixelDensities,\n        aspectRatio,\n      })\n    }\n    case `constrained`: {\n      // @ts-ignore - only width or height can be undefined but it doesn't let me type this correctly\n      return calculateResponsiveImageSizes({\n        sourceMetadata,\n        width,\n        height,\n        fit,\n        outputPixelDensities,\n        layout,\n        aspectRatio,\n      })\n    }\n    case `fullWidth`: {\n      // @ts-ignore - only width or height can be undefined but it doesn't let me type this correctly\n      return calculateResponsiveImageSizes({\n        sourceMetadata,\n        width,\n        height,\n        fit,\n        outputPixelDensities,\n        layout,\n        breakpoints,\n        aspectRatio,\n      })\n    }\n  }\n}\n\nfunction calculateFixedImageSizes({\n  sourceMetadata,\n  width,\n  height,\n  fit = `cover`,\n  outputPixelDensities,\n  aspectRatio: requestedAspectRatio,\n}: Omit<ImageSizeArgs, \"layout\" | \"breakpoints\">): IImageSizes {\n  let aspectRatio\n  if (requestedAspectRatio) {\n    aspectRatio = requestedAspectRatio\n  } else {\n    aspectRatio = sourceMetadata.width / sourceMetadata.height\n  }\n\n  // make sure output outputPixelDensities has a value of 1\n  outputPixelDensities.push(1)\n  const densities = new Set<number>(\n    outputPixelDensities.sort(sortNumeric).filter(Boolean)\n  )\n\n  // If both are provided then we need to check the fit\n  if (width && height) {\n    const calculated = calculateImageDimensions(sourceMetadata, {\n      width,\n      height,\n      fit,\n      aspectRatio,\n    })\n    width = calculated.width\n    height = calculated.height\n    aspectRatio = calculated.aspectRatio\n  } else {\n    // if we only get one value calculate the other value based on aspectRatio\n    if (!width) {\n      width = Math.round((height as number) * aspectRatio)\n    } else {\n      height = Math.round(width / aspectRatio)\n    }\n  }\n\n  const presentationWidth = width // will use this for presentationWidth, don't want to lose it\n  const isRequestedSizeLargerThanOriginal =\n    sourceMetadata.width < width || sourceMetadata.height < (height as number)\n\n  // If the image is smaller than requested, warn the user that it's being processed as such\n  // print out this message with the necessary information before we overwrite it for sizing\n  if (isRequestedSizeLargerThanOriginal) {\n    const invalidDimension = sourceMetadata.width < width ? `width` : `height`\n    console.warn(`\n    The requested ${invalidDimension} \"${\n      invalidDimension === `width` ? width : height\n    }px\" for the image ${\n      sourceMetadata.filename\n    } was larger than the actual image ${invalidDimension} of ${\n      sourceMetadata[invalidDimension]\n    }px. If possible, replace the current image with a larger one.`)\n\n    if (invalidDimension === `width`) {\n      width = sourceMetadata.width\n      height = width / aspectRatio\n    } else {\n      height = sourceMetadata.height\n      width = height * aspectRatio\n    }\n  }\n\n  const sizes = new Set<number>()\n  for (const density of densities) {\n    // Screen densities can only be higher or equal to 1\n    if (density >= 1) {\n      const widthFromDensity = density * width\n      sizes.add(Math.min(widthFromDensity, sourceMetadata.width))\n    }\n  }\n\n  return {\n    sizes: Array.from(sizes),\n    aspectRatio,\n    presentationWidth,\n    presentationHeight: Math.round(presentationWidth / aspectRatio),\n    unscaledWidth: width,\n  }\n}\n\nfunction calculateResponsiveImageSizes({\n  sourceMetadata,\n  width,\n  height,\n  fit = `cover`,\n  outputPixelDensities,\n  breakpoints,\n  layout,\n  aspectRatio: requestedAspectRatio,\n}: ImageSizeArgs): IImageSizes {\n  let sizes: Array<number> = []\n  let aspectRatio\n  if (requestedAspectRatio) {\n    aspectRatio = requestedAspectRatio\n  } else {\n    aspectRatio = sourceMetadata.width / sourceMetadata.height\n  }\n  // Sort, dedupe and ensure there's a 1\n  const densities = new Set<number>(\n    outputPixelDensities.sort(sortNumeric).filter(Boolean)\n  )\n\n  // If both are provided then we need to check the fit\n  if (width && height) {\n    const calculated = calculateImageDimensions(sourceMetadata, {\n      width,\n      height,\n      fit,\n      aspectRatio,\n    })\n    width = calculated.width\n    height = calculated.height\n    aspectRatio = calculated.aspectRatio\n  } else {\n    if (!width) {\n      width = (height as number) / aspectRatio\n    } else {\n      height = width * aspectRatio\n    }\n  }\n\n  // width of height were passed in, make sure it isn't larger than the actual image\n  width = width ? Math.round(Math.min(width, sourceMetadata.width)) : undefined\n  height = height ? Math.min(height, sourceMetadata.height) : undefined\n\n  const nonNullableWidth = width as number\n  const originalWidth = width as number\n\n  if (breakpoints && breakpoints.length > 0) {\n    sizes = breakpoints.filter(size => size <= sourceMetadata.width)\n\n    // If a larger breakpoint has been filtered-out, add the actual image width instead\n    if (\n      sizes.length < breakpoints.length &&\n      !sizes.includes(sourceMetadata.width)\n    ) {\n      sizes.push(sourceMetadata.width)\n    }\n  } else {\n    sizes = Array.from(densities).map(density =>\n      Math.round(density * nonNullableWidth)\n    )\n    sizes = sizes.filter(size => size <= sourceMetadata.width)\n  }\n\n  // ensure that the size passed in is included in the final output\n  if (layout === `constrained` && !sizes.includes(nonNullableWidth)) {\n    sizes.push(nonNullableWidth)\n  }\n\n  sizes = sizes.sort(sortNumeric)\n\n  return {\n    sizes,\n    aspectRatio,\n    presentationWidth: originalWidth,\n    presentationHeight: Math.round(originalWidth / aspectRatio),\n    unscaledWidth: nonNullableWidth,\n  }\n}\n\n// eslint-disable-next-line consistent-return\nfunction getSizesAttrFromLayout(layout: ImageLayout, width: number): string {\n  switch (layout) {\n    // If screen is wider than the max size, image width is the max size,\n    // otherwise it's the width of the screen\n    case `constrained`:\n      return `(min-width: ${width}px) ${width}px, 100vw`\n\n    // Image is always the same width, whatever the size of the screen\n    case `fixed`:\n      return `${width}px`\n\n    // Image is always the width of the screen\n    case `fullWidth`:\n      return `100vw`\n  }\n}\n"],"mappings":"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"}