{"version":3,"file":"utils.js","names":["toTypeNames","schema","gqlTypeName","gqlType","getType","isObjectType","isAbstractType","possibleTypes","getPossibleTypes","map","type","name","toNodeTypeNames","filter","getInterfaces","some","iface","isObjectOrInterfaceTypeComposer","ObjectTypeComposer","InterfaceTypeComposer","fieldNeedToResolve","typeComposer","schemaComposer","fieldName","nodeTypeNames","possibleTCs","getAnyTC","tc","getFieldExtension","fieldPathNeedToResolve","selector","schemaCustomization","composer","store","getState","Error","selectors","split","isInterfaceType","i","length","nextType","getNamedType","getFields","getResolvedFields","node","typeName","internal","resolvedNodes","resolvedNodesCache","get","id","pathObjectToPathString","input","path","currentValue","leaf","undefined","isPlainObject","entries","Object","key","value","push","join","maybeConvertSortInputObjectToSortPath","args","sort","Array","isArray","fields","order","every","item","toLowerCase","sorts","modifiedSort"],"sources":["../../src/schema/utils.ts"],"sourcesContent":["import {\n  isAbstractType,\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\"\nimport {\n  InterfaceTypeComposer,\n  NamedTypeComposer,\n  ObjectTypeComposer,\n  SchemaComposer,\n} from \"graphql-compose\"\nimport isPlainObject from \"lodash/isPlainObject\"\n\nimport type { IGatsbyNodePartial } from \"../datastore/in-memory/indexing\"\nimport { IGatsbyNode } from \"../internal\"\nimport { store } from \"../redux\"\n\nexport const toTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return []\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes.map(type => type.name)\n}\n\nexport const toNodeTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return []\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nexport function isObjectOrInterfaceTypeComposer(\n  type: NamedTypeComposer<any>\n): type is ObjectTypeComposer | InterfaceTypeComposer {\n  return (\n    type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer\n  )\n}\n\nexport const fieldNeedToResolve = ({\n  schema,\n  gqlType,\n  typeComposer,\n  schemaComposer,\n  fieldName,\n}: {\n  schema: GraphQLSchema\n  gqlType: GraphQLObjectType | GraphQLInterfaceType\n  typeComposer: ObjectTypeComposer<any> | InterfaceTypeComposer<any>\n  schemaComposer: SchemaComposer<any>\n  fieldName: string\n}): boolean => {\n  const nodeTypeNames = toNodeTypeNames(schema, gqlType)\n\n  const possibleTCs: Array<ObjectTypeComposer | InterfaceTypeComposer> = [\n    typeComposer,\n    ...nodeTypeNames\n      .map(name => schemaComposer.getAnyTC(name))\n      .filter(isObjectOrInterfaceTypeComposer),\n  ]\n\n  for (const tc of possibleTCs) {\n    if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport const fieldPathNeedToResolve = ({\n  selector,\n  type,\n}: {\n  selector: string\n  type: string | GraphQLObjectType | GraphQLInterfaceType\n}): boolean => {\n  const {\n    schema,\n    schemaCustomization: { composer: schemaComposer },\n  } = store.getState()\n\n  if (!schemaComposer) {\n    throw new Error(`Schema composer isn't set yet`)\n  }\n\n  const selectors =\n    typeof selector === `string` ? selector.split(`.`) : selector\n\n  let gqlType = typeof type === `string` ? schema.getType(type) : type\n\n  if (!gqlType || !(isObjectType(gqlType) || isInterfaceType(gqlType))) {\n    return false\n  }\n\n  for (let i = 0; i < selectors.length; i++) {\n    const fieldName = selectors[i]\n    const typeComposer = schemaComposer.getAnyTC(gqlType.name)\n\n    if (!isObjectOrInterfaceTypeComposer(typeComposer)) {\n      return false\n    }\n\n    if (\n      fieldNeedToResolve({\n        schema,\n        gqlType,\n        typeComposer,\n        schemaComposer,\n        fieldName,\n      })\n    ) {\n      return true\n    }\n\n    const nextType = getNamedType(gqlType.getFields()[fieldName].type)\n    if (!nextType || !(isObjectType(nextType) || isInterfaceType(nextType))) {\n      return false\n    } else {\n      gqlType = nextType\n    }\n  }\n\n  return false\n}\n\nexport function getResolvedFields(\n  node: IGatsbyNode | IGatsbyNodePartial\n): undefined | Record<string, any> {\n  const typeName = node.internal.type\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n  return resolvedNodes?.get(node.id)\n}\n\ntype NestedPathStructure = INestedPathStructureNode | true | \"ASC\" | \"DESC\"\n\nexport interface INestedPathStructureNode {\n  [key: string]: NestedPathStructure\n}\n\nexport function pathObjectToPathString(input: INestedPathStructureNode): {\n  path: string\n  leaf: any\n} {\n  const path: Array<string> = []\n  let currentValue: NestedPathStructure | undefined = input\n  let leaf: any = undefined\n  while (currentValue) {\n    if (isPlainObject(currentValue)) {\n      const entries = Object.entries(currentValue)\n      if (entries.length !== 1) {\n        throw new Error(`Invalid field arg`)\n      }\n      for (const [key, value] of entries) {\n        path.push(key)\n        currentValue = value\n      }\n    } else {\n      leaf = currentValue\n      currentValue = undefined\n    }\n  }\n\n  return {\n    path: path.join(`.`),\n    leaf,\n  }\n}\n\nexport function maybeConvertSortInputObjectToSortPath(args: any): any {\n  if (!args.sort) {\n    return args\n  }\n\n  // check if it's already in expected format\n  if (\n    Array.isArray(args.sort?.fields) &&\n    Array.isArray(args.sort?.order) &&\n    args.sort.order.every(\n      item =>\n        typeof item === `string` &&\n        (item.toLowerCase() === `asc` || item.toLowerCase() === `desc`)\n    )\n  ) {\n    return args\n  }\n\n  let sorts = args.sort\n\n  if (!Array.isArray(sorts)) {\n    sorts = [sorts]\n  }\n\n  const modifiedSort: any = {\n    fields: [],\n    order: [],\n  }\n\n  for (const sort of sorts) {\n    const { path, leaf } = pathObjectToPathString(sort)\n    modifiedSort.fields.push(path)\n    modifiedSort.order.push(leaf)\n  }\n\n  return {\n    ...args,\n    sort: modifiedSort,\n  }\n\n  return args\n}\n"],"mappings":"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"}