"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.typesWithoutInference = exports.reportParsingError = exports.parseTypeDef = exports.isASTDocument = void 0;
var _graphql = require("graphql");
var _typeBuilders = require("./type-builders");
var _extensions = require("../extensions");
var _reporter = _interopRequireDefault(require("../../reporter"));
const isASTDocument = typeOrTypeDef => typeof typeOrTypeDef === `object` && typeOrTypeDef.kind && _graphql.Kind.DOCUMENT === typeOrTypeDef.kind;

/**
 * Parses type definition represented as an SDL string into an AST Document.
 * Type definitions of other formats (other than SDL) are returned as is
 */
exports.isASTDocument = isASTDocument;
const parseTypeDef = typeOrTypeDef => {
  if (typeof typeOrTypeDef === `string`) {
    try {
      return (0, _graphql.parse)(typeOrTypeDef);
    } catch (error) {
      reportParsingError(error);
    }
  }
  return typeOrTypeDef;
};
exports.parseTypeDef = parseTypeDef;
const reportParsingError = error => {
  const {
    message,
    source,
    locations
  } = error;
  if (source && locations && locations.length) {
    const {
      codeFrameColumns
    } = require(`@babel/code-frame`);
    const frame = codeFrameColumns(source.body, {
      start: locations[0]
    }, {
      linesAbove: 5,
      linesBelow: 5
    });
    _reporter.default.panic(`Encountered an error parsing the provided GraphQL type definitions:\n` + message + `\n\n` + frame + `\n`);
  } else {
    throw error;
  }
};

/**
 * Given a type definition, collects type names that should skip the inference process
 */
exports.reportParsingError = reportParsingError;
const typesWithoutInference = (typeNames = [], typeOrTypeDef) => {
  if (typeof typeOrTypeDef === `string`) {
    typeOrTypeDef = parseTypeDef(typeOrTypeDef);
  }
  if (isASTDocument(typeOrTypeDef)) {
    typeOrTypeDef.definitions.forEach(def => {
      if (!def.directives) return;
      def.directives.forEach(directive => {
        if (directive.name.value === _extensions.dontInferExtensionName && def.name.value) {
          // @ts-ignore quick convert from js
          typeNames.push(def.name.value);
        }
      });
    });
    return typeNames;
  }
  // @ts-ignore quick convert from js
  if ((0, _typeBuilders.isGatsbyType)(typeOrTypeDef) && typeOrTypeDef.config) {
    // @ts-ignore quick convert from js
    const {
      extensions = {},
      name
    } = typeOrTypeDef.config;
    if (name && (extensions[_extensions.dontInferExtensionName] || extensions[_extensions.inferExtensionName] === false)) {
      // @ts-ignore quick convert from js
      typeNames.push(name);
    }
  }
  return typeNames;
};
exports.typesWithoutInference = typesWithoutInference;
//# sourceMappingURL=type-defs.js.map