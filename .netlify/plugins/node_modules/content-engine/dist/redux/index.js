"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.store = exports.saveState = exports.savePartialStateToDisk = exports.replaceReducer = exports.readState = exports.loadPartialStateFromDisk = exports.emitter = exports.configureStore = void 0;
var _pick2 = _interopRequireDefault(require("lodash/pick"));
var _redux = require("redux");
var _mett = require("../utils/mett");
var _reduxThunk = _interopRequireDefault(require("redux-thunk"));
var reducers = _interopRequireWildcard(require("./reducers"));
var _persist = require("./persist");
var _createRequireFromPath = require("../core-utils/create-require-from-path");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// import telemetry from "gatsby-telemetry"

const gatsbyRedux = (0, _createRequireFromPath.requireFromInstalledGatsbyDist)(`redux/index.js`);

// Create event emitter for actions
const emitter = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.emitter) || (0, _mett.mett)();

// Read old node data from cache.
exports.emitter = emitter;
const readState = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.readState) || (() => {
  try {
    const state = (0, _persist.readFromCache)();
    if (state.nodes) {
      // re-create nodesByType
      state.nodesByType = new Map();
      state.nodes.forEach(node => {
        const {
          type
        } = node.internal;
        if (!state.nodesByType.has(type)) {
          state.nodesByType.set(type, new Map());
        }
        // The `.has` and `.set` calls above make this safe
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        state.nodesByType.get(type).set(node.id, node);
      });
    }

    // jsonDataPaths was removed in the per-page-manifest
    // changes. Explicitly delete it here to cover case where user
    // runs gatsby the first time after upgrading.
    delete state[`jsonDataPaths`];

    // telemetry.trackCli(`CACHE_STATUS`, {
    //   cacheStatus: `WARM`,
    // })

    return state;
  } catch (e) {
    // telemetry.trackCli(`CACHE_STATUS`, {
    //   cacheStatus: `COLD`,
    // })

    return {};
  }
});
exports.readState = readState;
/**
 * Redux middleware handling array of actions
 */
const multi = ({
  dispatch
}) => next => action => Array.isArray(action) ? action.filter(Boolean).map(dispatch) : next(action);
const configureStore = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.configureStore) || (initialState => (0, _redux.createStore)((0, _redux.combineReducers)({
  ...reducers
}), initialState, (0, _redux.applyMiddleware)(_reduxThunk.default, multi)));
exports.configureStore = configureStore;
const store = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.store) || configureStore(process.env.GATSBY_WORKER_POOL_WORKER ? {} : readState());

/**
 * Allows overloading some reducers (e.g. when setting a custom datastore)
 */
exports.store = store;
const replaceReducer = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.replaceReducer) || (customReducers => {
  store.replaceReducer((0, _redux.combineReducers)({
    ...reducers,
    ...customReducers
  }));
});

// Persist state.
exports.replaceReducer = replaceReducer;
const saveState = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.saveState) || (() => {
  const state = store.getState();
  return (0, _persist.writeToCache)({
    nodes: state.nodes,
    typeOwners: state.typeOwners,
    statefulSourcePlugins: state.statefulSourcePlugins,
    status: state.status,
    jobsV2: state.jobsV2
  });
});
exports.saveState = saveState;
const savePartialStateToDisk = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.savePartialStateToDisk) || ((keys, transformState) => {
  const state = store.getState();
  const contents = (0, _pick2.default)(state, keys);
  const savedContents = transformState ? transformState(contents) : contents;
  return (0, _persist.writeToCache)(savedContents);
});
exports.savePartialStateToDisk = savePartialStateToDisk;
const loadPartialStateFromDisk = (gatsbyRedux === null || gatsbyRedux === void 0 ? void 0 : gatsbyRedux.loadPartialStateFromDisk) || (() => {
  try {
    return (0, _persist.readFromCache)();
  } catch (e) {
    // ignore errors.
  }
  return {};
});

// if we're using Gatsby's redux then it will already be emitting the following:
exports.loadPartialStateFromDisk = loadPartialStateFromDisk;
if (!(gatsbyRedux !== null && gatsbyRedux !== void 0 && gatsbyRedux.emitter)) {
  store.subscribe(() => {
    const lastAction = store.getState().lastAction;
    emitter.emit(lastAction.type, lastAction);
  });
}
//# sourceMappingURL=index.js.map