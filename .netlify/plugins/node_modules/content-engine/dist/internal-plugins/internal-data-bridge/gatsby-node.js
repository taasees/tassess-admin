"use strict";

const moment = require(`moment`);
const _ = require(`lodash`);
function transformPackageJson(json) {
  const transformDeps = deps => _.entries(deps).map(([name, version]) => {
    return {
      name,
      version
    };
  });
  json = _.pick(json, [`name`, `description`, `version`, `main`, `keywords`, `author`, `license`, `dependencies`, `devDependencies`, `peerDependencies`, `optionalDependecies`, `bundledDependecies`]);
  json.dependencies = transformDeps(json.dependencies);
  json.devDependencies = transformDeps(json.devDependencies);
  json.peerDependencies = transformDeps(json.peerDependencies);
  json.optionalDependecies = transformDeps(json.optionalDependecies);
  json.bundledDependecies = transformDeps(json.bundledDependecies);
  return json;
}
exports.sourceNodes = ({
  createContentDigest,
  actions,
  store
}) => {
  const {
    createNode
  } = actions;
  const {
    program,
    flattenedPlugins,
    config
  } = store.getState();
  flattenedPlugins.forEach(plugin => {
    plugin.pluginFilepath = plugin.resolve;
    createNode({
      ...plugin,
      packageJson: transformPackageJson(require(`${plugin.resolve}/package.json`)),
      parent: null,
      children: [],
      internal: {
        contentDigest: createContentDigest(plugin),
        type: `SitePlugin`
      }
    });
  });
  const createGatsbyConfigNode = (config = {}) => {
    // Delete plugins from the config as we add plugins above.
    const configCopy = {
      ...config
    };
    delete configCopy.plugins;
    const node = {
      siteMetadata: {
        ...configCopy.siteMetadata
      },
      port: program.port,
      host: program.host,
      ...configCopy
    };
    createNode({
      ...node,
      id: `Site`,
      parent: null,
      children: [],
      internal: {
        contentDigest: createContentDigest(node),
        type: `Site`
      }
    });
  };
  createGatsbyConfigNode(config);
  const buildTime = moment().subtract(process.uptime(), `seconds`).startOf(`second`).toJSON();
  const metadataNode = {
    buildTime
  };
  createNode({
    ...metadataNode,
    id: `SiteBuildMetadata`,
    parent: null,
    children: [],
    internal: {
      contentDigest: createContentDigest(metadataNode),
      type: `SiteBuildMetadata`
    }
  });
};
exports.createResolvers = ({
  createResolvers
}) => {
  const resolvers = {
    Site: {
      buildTime: {
        type: `Date`,
        resolve(source, args, context, info) {
          const {
            buildTime
          } = context.nodeModel.getNodeById({
            id: `SiteBuildMetadata`,
            type: `SiteBuildMetadata`
          });
          return info.originalResolver({
            ...source,
            buildTime
          }, args, context, info);
        }
      }
    }
  };
  createResolvers(resolvers);
};
//# sourceMappingURL=gatsby-node.js.map