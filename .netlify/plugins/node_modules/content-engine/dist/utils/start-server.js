"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.startServer = startServer;
var _express = _interopRequireDefault(require("express"));
var _compression = _interopRequireDefault(require("compression"));
var _express2 = require("graphql-http/lib/use/express");
var _contentEngineGraphiqlExplorer = _interopRequireDefault(require("content-engine-graphiql-explorer"));
var _graphql = require("graphql");
var _uuid = require("../core-utils/uuid");
var _http = _interopRequireDefault(require("http"));
var _https = _interopRequireDefault(require("https"));
var _cors = _interopRequireDefault(require("cors"));
var _redux = require("../redux");
var _context = _interopRequireDefault(require("../schema/context"));
var _apiRunnerNode = _interopRequireDefault(require("./api-runner-node"));
var _polyfillRemoteFile = require("../plugin-utils/polyfill-remote-file");
// import telemetry from "gatsby-telemetry"

async function startServer(program, app) {
  /**
   * Set up the express app.
   **/
  app.use((0, _compression.default)());
  // app.use(telemetry.expressMiddleware(`DEVELOP`))

  app.use((0, _cors.default)());

  /**
   * Pattern matching all endpoints with graphql or graphiql with 1 or more leading underscores
   */
  const graphqlEndpoint = `/_+graphi?ql`;
  (0, _contentEngineGraphiqlExplorer.default)(app, {
    graphqlEndpoint,
    getFragments: function getFragments() {
      const fragments = [];
      for (const def of _redux.store.getState().definitions.values()) {
        if (def.def.kind === _graphql.Kind.FRAGMENT_DEFINITION) {
          fragments.push(def.def);
        }
      }
      return fragments;
    }
  });
  app.use(graphqlEndpoint, (0, _express2.createHandler)({
    schema() {
      return _redux.store.getState().schema;
    },
    context() {
      return (0, _context.default)({
        schema: _redux.store.getState().schema,
        schemaComposer: _redux.store.getState().schemaCustomization.composer,
        context: {},
        customContext: _redux.store.getState().schemaCustomization.context
      });
    },
    onOperation(_req, _args, result) {
      if (result.errors) {
        result.errors = result.errors.map(err => ({
          ...err.toJSON(),
          extensions: {
            stack: err.stack ? err.stack.split(`\n`) : []
          }
        }));
      }
      result.extensions = {
        enableRefresh: process.env.ENABLE_GATSBY_REFRESH_ENDPOINT,
        refreshToken: process.env.GATSBY_REFRESH_TOKEN
      };
      return result;
    }
  }));

  /**
   * Refresh external data sources.
   * If no GATSBY_REFRESH_TOKEN env var is available, then no Authorization header is required
   **/
  const REFRESH_ENDPOINT = `/__refresh`;
  const refresh = async (req, pluginName) => {
    global.__GATSBY.buildId = _uuid.uuid.v4();
    _redux.emitter.emit(`WEBHOOK_RECEIVED`, {
      webhookBody: req.body,
      pluginName
    });
  };
  app.post(`${REFRESH_ENDPOINT}/:plugin_name?`, _express.default.json(), (req, res) => {
    const pluginName = req.params[`plugin_name`];
    const refreshToken = process.env.GATSBY_REFRESH_TOKEN;
    const authorizedRefresh = !refreshToken || req.headers.authorization === refreshToken;
    if (authorizedRefresh) {
      refresh(req, pluginName);
      res.status(200);
      res.setHeader(`content-type`, `application/json`);
    } else {
      res.status(authorizedRefresh ? 404 : 403);
      res.json({
        error: `Authorization failed. Make sure you add authorization header to your refresh requests`
      });
    }
    res.end();
  });
  (0, _polyfillRemoteFile.addImageRoutes)(app,
  // @ts-ignore todo should this be Store or GatsbyStore?
  _redux.store);

  // Expose access to app for advanced use cases
  const {
    developMiddleware
  } = _redux.store.getState().config;
  if (developMiddleware) {
    developMiddleware(app, program);
  }
  await (0, _apiRunnerNode.default)(`onCreateDevServer`, {
    app,
    deferNodeMutation: true
  });
  app.use(async (req, res) => {
    // in this catch-all block we don't support POST so we should 404
    if (req.method === `POST`) {
      res.status(404).end();
      return;
    }
    res.sendStatus(404);
  });
  return new Promise(res => {
    /**
     * Set up the HTTP server and socket.io.
     **/
    const server = program.ssl ? new _https.default.Server(program.ssl, app) : new _http.default.Server(app);
    const listener = server.listen(program.port, program.host, () => {
      res({
        listener
      });
    });
  });
}
//# sourceMappingURL=start-server.js.map