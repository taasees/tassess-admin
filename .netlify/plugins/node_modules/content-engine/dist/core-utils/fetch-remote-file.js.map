{"version":3,"file":"fetch-remote-file.js","names":["GATSBY_CONCURRENT_DOWNLOAD","process","env","parseInt","alreadyCopiedFiles","Set","fetchRemoteFile","args","cacheKey","storage","getStorage","getDatabaseDir","info","remoteFileInfo","get","url","fileDirectory","cache","directory","cachedPath","path","join","downloadPath","fs","pathExists","isPublicPath","copyCachedPathToDownloadPath","pushTask","startsWith","global","__GATSBY","root","cwd","has","copyFileMutex","createMutex","acquire","copy","overwrite","add","release","queue","Queue","fetchWorker","task","cb","fetchFile","e","Promise","resolve","reject","push","err","node","auth","httpHeaders","ext","name","excludeDigest","BUILD_ID","buildId","Error","fetchFileMutex","digest","createContentDigest","finalDirectory","getRemoteFileName","getRemoteFileExtension","cachedEntry","inFlightValue","getInFlightObject","createFilePath","httpOptions","htaccess_pass","htaccess_user","username","password","ensureDir","tmpFilename","filename","headers","etag","response","requestRemoteNode","statusCode","filetype","fileType","fromFile","move","slashedDirectory","slash","setInFlightObject","extension","replace","remove","inFlightMap","Map","key","remoteFile","undefined","value","set","put"],"sources":["../../src/core-utils/fetch-remote-file.ts"],"sourcesContent":["import fileType from \"file-type\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport Queue from \"fastq\"\nimport { createContentDigest } from \"./create-content-digest\"\nimport {\n  getRemoteFileName,\n  getRemoteFileExtension,\n  createFilePath,\n} from \"./filename-utils\"\nimport { slash } from \"./path\"\nimport { requestRemoteNode } from \"./remote-file-utils/fetch-file\"\nimport { getStorage, getDatabaseDir } from \"./utils/get-storage\"\nimport { createMutex } from \"./mutex\"\nimport type { Options } from \"got\"\nimport type { IFetchRemoteFileOptions } from \"./remote-file-utils/fetch-file\"\n\ninterface ITask {\n  args: IFetchRemoteFileOptions\n}\n\nconst GATSBY_CONCURRENT_DOWNLOAD = process.env.GATSBY_CONCURRENT_DOWNLOAD\n  ? parseInt(process.env.GATSBY_CONCURRENT_DOWNLOAD, 10) || 0\n  : 50\n\nconst alreadyCopiedFiles = new Set<string>()\n\nexport type { IFetchRemoteFileOptions }\n\n/**\n * Downloads a remote file to disk\n */\nexport async function fetchRemoteFile(\n  args: IFetchRemoteFileOptions\n): Promise<string> {\n  // when cachekey is present we can do more persistance\n  if (args.cacheKey) {\n    const storage = getStorage(getDatabaseDir())\n    const info = storage.remoteFileInfo.get(args.url)\n\n    const fileDirectory = (\n      args.cache ? args.cache.directory : args.directory\n    ) as string\n\n    if (info?.cacheKey === args.cacheKey && fileDirectory) {\n      const cachedPath = path.join(info.directory, info.path)\n      const downloadPath = path.join(fileDirectory, info.path)\n\n      if (await fs.pathExists(cachedPath)) {\n        // If the cached directory is not part of the public directory, we don't need to copy it\n        // as it won't be part of the build.\n        if (isPublicPath(downloadPath) && cachedPath !== downloadPath) {\n          return copyCachedPathToDownloadPath({ cachedPath, downloadPath })\n        }\n\n        return cachedPath\n      }\n    }\n  }\n\n  return pushTask({ args })\n}\n\nfunction isPublicPath(downloadPath: string): boolean {\n  return downloadPath.startsWith(\n    path.join(global.__GATSBY?.root ?? process.cwd(), `public`)\n  )\n}\n\nasync function copyCachedPathToDownloadPath({\n  cachedPath,\n  downloadPath,\n}: {\n  cachedPath: string\n  downloadPath: string\n}): Promise<string> {\n  // Create a mutex to do our copy - we could do a md5 hash check as well but that's also expensive\n  if (!alreadyCopiedFiles.has(downloadPath)) {\n    const copyFileMutex = createMutex(\n      `core-utils:copy-fetch:${downloadPath}`,\n      200\n    )\n    await copyFileMutex.acquire()\n    if (!alreadyCopiedFiles.has(downloadPath)) {\n      await fs.copy(cachedPath, downloadPath, {\n        overwrite: true,\n      })\n    }\n\n    alreadyCopiedFiles.add(downloadPath)\n    await copyFileMutex.release()\n  }\n\n  return downloadPath\n}\n\nconst queue = Queue<null, ITask, string>(\n  /**\n   * fetchWorker\n   * --\n   * Handle fetch requests that are pushed in to the Queue\n   */\n  async function fetchWorker(task, cb): Promise<void> {\n    try {\n      return void cb(null, await fetchFile(task.args))\n    } catch (e) {\n      return void cb(e)\n    }\n  },\n  GATSBY_CONCURRENT_DOWNLOAD\n)\n\n/**\n * pushTask\n * --\n * pushes a task in to the Queue and the processing cache\n *\n * Promisfy a task in queue\n * @param {CreateRemoteFileNodePayload} task\n * @return {Promise<Buffer | string>}\n */\nasync function pushTask(task: ITask): Promise<string> {\n  return new Promise((resolve, reject) => {\n    queue.push(task, (err, node) => {\n      if (!err) {\n        resolve(node as string)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\n\nasync function fetchFile({\n  url,\n  cache,\n  directory,\n  auth = {},\n  httpHeaders = {},\n  ext,\n  name,\n  cacheKey,\n  excludeDigest,\n}: IFetchRemoteFileOptions): Promise<string> {\n  // global introduced in gatsby 4.0.0\n  const BUILD_ID = global.__GATSBY?.buildId ?? ``\n  const fileDirectory = (cache ? cache.directory : directory) as string\n  const storage = getStorage(getDatabaseDir())\n\n  if (!cache && !directory) {\n    throw new Error(`You must specify either a cache or a directory`)\n  }\n\n  const fetchFileMutex = createMutex(`core-utils:fetch:${url}`)\n  await fetchFileMutex.acquire()\n\n  // Fetch the file.\n  try {\n    const digest = createContentDigest(url)\n    const finalDirectory = excludeDigest\n      ? path.resolve(fileDirectory)\n      : path.join(fileDirectory, digest)\n\n    if (!name) {\n      name = getRemoteFileName(url)\n    }\n\n    if (!ext) {\n      ext = getRemoteFileExtension(url)\n    }\n\n    const cachedEntry = await storage.remoteFileInfo.get(url)\n\n    const inFlightValue = getInFlightObject(url, BUILD_ID)\n    if (inFlightValue) {\n      const downloadPath = createFilePath(finalDirectory, name, ext)\n      if (!isPublicPath(finalDirectory) || downloadPath === inFlightValue) {\n        return inFlightValue\n      }\n\n      return await copyCachedPathToDownloadPath({\n        cachedPath: inFlightValue,\n        downloadPath: createFilePath(finalDirectory, name, ext),\n      })\n    }\n\n    // Add htaccess authentication if passed in. This isn't particularly\n    // extensible. We should define a proper API that we validate.\n    const httpOptions: Options = {}\n    if (auth && (auth.htaccess_pass || auth.htaccess_user)) {\n      httpOptions.username = auth.htaccess_user\n      httpOptions.password = auth.htaccess_pass\n    }\n\n    await fs.ensureDir(finalDirectory)\n\n    const tmpFilename = createFilePath(fileDirectory, `tmp-${digest}`, ext)\n    let filename = createFilePath(finalDirectory, name, ext)\n\n    // See if there's response headers for this url\n    // from a previous request.\n    const headers = { ...httpHeaders }\n\n    if (cachedEntry?.headers?.etag && (await fs.pathExists(filename))) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      headers[`If-None-Match`] = cachedEntry.headers.etag\n    }\n\n    const response = await requestRemoteNode(\n      url,\n      headers,\n      tmpFilename,\n      httpOptions\n    )\n\n    if (response.statusCode === 200) {\n      // Save the response headers for future requests.\n      // If the user did not provide an extension and we couldn't get one from remote file, try and guess one\n      if (!ext) {\n        // if this is fresh response - try to guess extension and cache result for future\n        const filetype = await fileType.fromFile(tmpFilename)\n        if (filetype) {\n          ext = `.${filetype.ext}`\n\n          filename += ext\n        }\n      }\n\n      await fs.move(tmpFilename, filename, { overwrite: true })\n\n      const slashedDirectory = slash(finalDirectory)\n      await setInFlightObject(url, BUILD_ID, {\n        cacheKey,\n        extension: ext,\n        headers: response.headers.etag ? { etag: response.headers.etag } : {},\n        directory: slashedDirectory,\n        path: slash(filename).replace(`${slashedDirectory}/`, ``),\n      })\n    } else if (response.statusCode === 304) {\n      await fs.remove(tmpFilename)\n    }\n\n    return filename\n  } finally {\n    await fetchFileMutex.release()\n  }\n}\n\nconst inFlightMap = new Map<string, string>()\nfunction getInFlightObject(key: string, buildId?: string): string | undefined {\n  if (!buildId) {\n    return inFlightMap.get(key)\n  }\n\n  const remoteFile = getStorage(getDatabaseDir()).remoteFileInfo.get(key)\n  // if buildId match we know it's the same build and it already processed this url this build\n  if (remoteFile && remoteFile.buildId === buildId) {\n    return path.join(remoteFile.directory, remoteFile.path)\n  }\n\n  return undefined\n}\nasync function setInFlightObject(\n  key: string,\n  buildId: string,\n  value: { buildId?: string } & Omit<\n    NonNullable<\n      ReturnType<ReturnType<typeof getStorage>[\"remoteFileInfo\"][\"get\"]>\n    >,\n    \"buildId\"\n  >\n): Promise<void> {\n  if (!buildId) {\n    inFlightMap.set(key, path.join(value.directory, value.path))\n  }\n\n  await getStorage(getDatabaseDir()).remoteFileInfo.put(key, {\n    ...value,\n    buildId,\n  })\n}\n"],"mappings":"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"}