"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
var _exportNames = {
  setFrameworkHook: true,
  contentEngine: true,
  throwOutsideTestEnv: true
};
exports.setFrameworkHook = exports.contentEngine = void 0;
exports.throwOutsideTestEnv = throwOutsideTestEnv;
var _inspector = _interopRequireDefault(require("inspector"));
var _signalExit = _interopRequireDefault(require("signal-exit"));
var _reporter = _interopRequireDefault(require("./reporter"));
var _controllableScript = require("./utils/controllable-script");
var _crypto = _interopRequireDefault(require("crypto"));
var _fsExtra = require("fs-extra");
var _path = _interopRequireDefault(require("path"));
var _createRequireFromPath = require("./core-utils/create-require-from-path");
var _lmdbDatastore = require("./datastore/lmdb/lmdb-datastore");
var _types = require("./types");
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});
var _index = require("./framework-hooks/index");
exports.setFrameworkHook = _index.setFrameworkHook;
/* eslint-disable @typescript-eslint/no-non-null-assertion */

const contentEngine = engineOptions => {
  var _engineOptions2;
  const {
    directory,
    frameworkHooks
  } = engineOptions || {};
  if (directory && !(0, _fsExtra.existsSync)(directory)) {
    throw new Error(`Content Engine directory does not exist: ${directory}`);
  }
  if (frameworkHooks && typeof frameworkHooks !== `string`) {
    throw new Error(`The framework file passed to contentEngine({ frameworkHooks: "..." }) must be a string.`);
  }
  if (frameworkHooks && !(0, _fsExtra.existsSync)(frameworkHooks)) {
    throw new Error(`The framework file passed to contentEngine({ frameworkHooks: "${frameworkHooks}" }) does not exist. Make sure the path to the framework file is correct.`);
  }
  engineOptions = {
    directory: process.cwd(),
    ...(engineOptions || {})
  };
  if (`runInSubProcess` in engineOptions && engineOptions.runInSubProcess === false) {
    var _engineOptions;
    process.chdir(engineOptions.directory);
    const defaultContentEnginePath = `content-engine/dist/services/content-engine.js`;
    const contentEngineDir = (0, _createRequireFromPath.resolveFromContentEngine)(`/services/content-engine`, (_engineOptions = engineOptions) === null || _engineOptions === void 0 ? void 0 : _engineOptions.directory) || defaultContentEnginePath;
    if (!contentEngineDir || contentEngineDir && contentEngineDir !== defaultContentEnginePath && !(0, _fsExtra.existsSync)(contentEngineDir)) {
      throw new Error(`Content Engine directory does not exist: ${contentEngineDir}`);
    }
    const {
      contentEngine
    } = require(contentEngineDir);
    return contentEngine(engineOptions);
  }
  const state = {
    exited: false
  };
  const internalState = {
    env: ((_engineOptions2 = engineOptions) === null || _engineOptions2 === void 0 ? void 0 : _engineOptions2.env) || {},
    processListenersWereSet: false,
    stdErrListeners: [],
    stdOutListeners: [],
    messageListeners: []
  };
  const log = message => {
    var _engineOptions3;
    if (((_engineOptions3 = engineOptions) === null || _engineOptions3 === void 0 ? void 0 : _engineOptions3.printLogs) !== false) {
      console.log(message);
    }
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function onceReceived(message) {
    return new Promise(res => {
      const subprocess = internalState.subProcess;
      if (!subprocess) {
        new Error(`Content Engine process is not running but should be.`);
      }
      const exitListener = () => {
        // @ts-ignore if subProcess is accessed from outside it will be recreated automatically. setting it to null here allows it to be recreated as needed
        internalState.subProcess = null;
        res(false);
      };
      const listener = receivedMessage => {
        if (receivedMessage.type === message) {
          subprocess.offMessage(listener);
          subprocess.offExit(exitListener);
          res(receivedMessage.payload || true);
        }
      };
      subprocess.onMessage(listener);
      subprocess.onExit(exitListener);
    });
  }
  const createSubProcessIfNoneExists = async ({
    env
  }) => {
    if (!internalState.subProcess) {
      var _engineOptions4, _engineOptions5, _engineOptions6, _engineOptions7, _stdout, _stderr;
      state.exited = false;
      state.exitCode = undefined;
      internalState.env = env || internalState.env;
      _reporter.default.verbose(`[content-engine] starting subprocess`);
      const contentEngineDir = (0, _createRequireFromPath.resolveFromContentEngine)(`/services/content-engine`, (_engineOptions4 = engineOptions) === null || _engineOptions4 === void 0 ? void 0 : _engineOptions4.directory) || require.resolve(`./services/content-engine`);
      const reduxDir = (0, _createRequireFromPath.resolveFromContentEngine)(`/redux`, (_engineOptions5 = engineOptions) === null || _engineOptions5 === void 0 ? void 0 : _engineOptions5.directory) || require.resolve(`./redux`);
      internalState.subProcess = new _controllableScript.ControllableScript(`
          const engineOptions = ${JSON.stringify(engineOptions)}
          const { contentEngine } = require("${contentEngineDir}")
          const { saveState } = require("${reduxDir}")

          const engine = contentEngine(engineOptions)

          if (!process.send) {
            throw new Error(
              'Started Content Engine as a subprocess, but no parent was found.'
            )
          }

          process.send({
            type: 'CONTENT_ENGINE_CHILD_RUNNING',
          })

          process.on('message', async message => {
            if (message.type === 'COMMAND' && message.action?.type === 'EXIT') {
              saveState()
              const code = typeof message.action?.payload === 'number'
                ? message.action.payload
                : 0

              process.exit(code)
            } else if (message.type === 'CONTENT_ENGINE_CHILD_SYNC_DATA') {
              engine.sync(message.payload).then(() => {
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_FINISHED_SYNCING_DATA',
                })
              }).catch(e => {
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_FINISHED_SYNCING_DATA',
                  payload: {
                    error: {
                      message: e.message,
                      stack: e.stack
                    }
                  }
                })
              })
            } else if (message.type === 'CONTENT_ENGINE_CHILD_QUERY') {
              engine.test.query(message.payload.query, message.payload.variables).then(result => {
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_QUERY_RESULT--' + message.payload.queryId,
                  payload: {
                    result
                  }
                })
              }).catch(e => {
                console.error(e)
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_QUERY_RESULT--' + message.payload.queryId,
                  payload: {
                    error: e.message,
                    stack: e.stack
                  }
                })
              })
            } else if (message.type === 'CONTENT_ENGINE_CHILD_INITIALIZE') {
              engine.initialize(message.payload).then(() => {
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_FINISHED_INITIALIZING',
                })
              }).catch(e => {
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_FINISHED_INITIALIZING',
                  error: {
                    message: e.message,
                    stack: e.stack
                  }
                })
              })
            } else if (message.type === 'CONTENT_ENGINE_CHILD_INVOKE_TEST_UTIL') {
              const responseType = 'CONTENT_ENGINE_CHILD_INVOKE_TEST_UTIL_RESULT--' + message.payload.messageId

              function sendError(e) {
                console.error(e)
                process.send({
                  type: 'CONTENT_ENGINE_CHILD_INVOKE_TEST_UTIL_RESULT--' + message.payload.messageId,
                  payload: {
                    error: e.message,
                    stack: e.stack
                  }
                })
              }

              try {
                const promiseOrResult = engine.test[message.payload.utilName](...message.payload.args)

                if (promiseOrResult && 'then' in promiseOrResult) {
                  promiseOrResult.then(result => {
                    process.send({
                      type: responseType,
                      payload: {
                        result
                      }
                    })
                  }).catch(sendError)
                } else {
                  process.send({
                    type: responseType,
                    payload: {
                      result: promiseOrResult
                    }
                  })
                }
              } catch (e) {
                sendError(e)
              }
            }
          })
      `, null, {
        printLogs: (_engineOptions6 = engineOptions) === null || _engineOptions6 === void 0 ? void 0 : _engineOptions6.printLogs
      });
      internalState.subProcess.start({
        env: internalState.env,
        directory: (_engineOptions7 = engineOptions) === null || _engineOptions7 === void 0 ? void 0 : _engineOptions7.directory
      });
      (_stdout = internalState.subProcess.process.stdout) === null || _stdout === void 0 ? void 0 : _stdout.on(`data`, data => {
        internalState.stdOutListeners.forEach(listener => listener(data));
      });
      (_stderr = internalState.subProcess.process.stderr) === null || _stderr === void 0 ? void 0 : _stderr.on(`data`, data => {
        internalState.stdErrListeners.forEach(listener => listener(data));
      });
      internalState.subProcess.onMessage(message => {
        internalState.messageListeners.forEach(listener => listener(message));
      });
      internalState.subProcess.onExit(exitCode => {
        var _internalState$subPro;
        state.exitCode = exitCode || undefined;
        const proc = (_internalState$subPro = internalState.subProcess) === null || _internalState$subPro === void 0 ? void 0 : _internalState$subPro.process;
        if (proc !== null && proc !== void 0 && proc.killed || typeof exitCode === `number`) {
          state.exited = true;
        }

        // @ts-ignore if subProcess is accessed from outside it will be recreated automatically
        internalState.subProcess = null;
        if (typeof exitCode === `number` && exitCode !== 0) {
          console.error(`[content-engine] Process stopped with exit code ${exitCode}`);
        }
      });
      if (!internalState.processListenersWereSet) {
        internalState.processListenersWereSet = true;
        function shutdownService({
          subProcess,
          code
        }, signal) {
          if (!subProcess) {
            return Promise.resolve();
          }
          return subProcess.stop(signal, code || 0).catch(() => {}).then(() => {});
        }
        process.on(`message`, msg => {
          var _internalState$subPro2;
          (_internalState$subPro2 = internalState.subProcess) === null || _internalState$subPro2 === void 0 ? void 0 : _internalState$subPro2.send(msg);
        });
        process.on(`SIGINT`, async () => {
          await shutdownService(internalState, `SIGINT`);
          process.exit(0);
        });
        process.on(`SIGTERM`, async () => {
          await shutdownService(internalState, `SIGTERM`);
          process.exit(0);
        });
        (0, _signalExit.default)((code, signal) => {
          shutdownService({
            subProcess: internalState.subProcess,
            code
          }, signal);
        });
      }
      _reporter.default.verbose(`[content-engine] waiting for subprocess to start`);
      const isRunning = await onceReceived(`CONTENT_ENGINE_CHILD_RUNNING`);
      return {
        isRunning
      };
    }
    return {
      isRunning: true
    };
  };
  const sendFrameworkContext = context => {
    if (internalState.subProcess) {
      internalState.subProcess.send({
        type: `CONTENT_ENGINE_FRAMEWORK_CONTEXT`,
        context
      });
    }
  };
  const initialize = async ({
    clearCache,
    env,
    context
  } = {
    clearCache: false
  }) => {
    var _engineOptions8;
    if (env && internalState.subProcess) {
      log(`restarting process since env vars were passed to initialize`);
      await stop();
    }
    if (clearCache) {
      await deleteCache();
    }
    const {
      isRunning
    } = await createSubProcessIfNoneExists({
      env: env || ((_engineOptions8 = engineOptions) === null || _engineOptions8 === void 0 ? void 0 : _engineOptions8.env)
    });
    if (context) {
      sendFrameworkContext(context);
    }
    if (!isRunning) {
      _reporter.default.verbose(`[content-engine] subprocess exited.`);
      // return early if not running. this means the process exited.
      return;
    }
    internalState.subProcess.send({
      type: `CONTENT_ENGINE_CHILD_INITIALIZE`
    });
    const result = await onceReceived(`CONTENT_ENGINE_CHILD_FINISHED_INITIALIZING`);
    if (result !== null && result !== void 0 && result.error) {
      const newErr = new Error(result.error.message);
      newErr.stack = result.error.stack;
      throw newErr;
    }
  };
  const deleteCache = async () => {
    await stop();
    const cachePath = _path.default.join(engineOptions.directory, `.cache`);
    if ((0, _fsExtra.existsSync)(cachePath)) {
      await (0, _fsExtra.rm)(cachePath, {
        recursive: true,
        force: true
      });
    }
    await getStore().resetCache();
  };
  const sync = async ({
    clearCache = false,
    runServer,
    webhookBody,
    env,
    context,
    buildSchema = true,
    connector
  } = {
    buildSchema: true
  }) => {
    var _engineOptions9;
    state.error = undefined;
    if (runServer && !buildSchema) {
      throw new Error(`Cannot run server without building schema. Set "runServer: true" or "buildSchema: false" to fix this.`);
    }
    _reporter.default.verbose(`[content-engine] sync, ${JSON.stringify(env, null, 2)}`);
    if (env && internalState.subProcess && JSON.stringify(env) !== JSON.stringify(internalState.env)) {
      log(`restarting process since new env vars were passed to sync`);
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      await stop();
    }
    if (clearCache) {
      await deleteCache();
    }
    const {
      isRunning
    } = await createSubProcessIfNoneExists({
      env: env || ((_engineOptions9 = engineOptions) === null || _engineOptions9 === void 0 ? void 0 : _engineOptions9.env)
    });
    if (context) {
      sendFrameworkContext(context);
    }
    if (!isRunning) {
      _reporter.default.verbose(`[content-engine] subprocess exited.`);
      // return early if not running. this means the process exited.
      return state;
    }
    internalState.subProcess.send({
      type: `CONTENT_ENGINE_CHILD_SYNC_DATA`,
      payload: {
        runServer,
        webhookBody,
        buildSchema,
        connector
      }
    });
    _reporter.default.verbose(`[content-engine] waiting for subprocess to finish sync`);
    const {
      error
    } = (await onceReceived(`CONTENT_ENGINE_CHILD_FINISHED_SYNCING_DATA`)) || {};
    if (error) {
      state.error = {
        message: error.message,
        stack: error.stack
      };
      _reporter.default.verbose(`[content-engine] subprocess finished syncing with errors.`);
    } else {
      _reporter.default.verbose(`[content-engine] subprocess finished sync`);
    }
    return {
      ...state,
      error: state.error ? {
        ...state.error
      } : undefined
    };
  };
  const restart = async ({
    env,
    clearCache,
    buildSchema = true,
    ...options
  } = {
    buildSchema: true
  }) => {
    await stop();
    if (clearCache) {
      await deleteCache();
    }
    log(`restarting subprocess`);
    await createSubProcessIfNoneExists({
      env
    });
    return sync({
      ...options,
      buildSchema
    });
  };
  const stop = async (signal, code = 0) => {
    if (internalState.subProcess) {
      log(`stopping subprocess`);

      // if a debugger is attached, the process must be killed with SIGKILL or it will hang indefinitely
      const inDebugMode = _inspector.default.url() !== undefined;
      const exitSignal = inDebugMode ? `SIGKILL` : signal || null;
      await internalState.subProcess.stop(exitSignal, code);

      // @ts-ignore if subProcess is accessed from outside it will be recreated automatically
      internalState.subProcess = null;
    }
  };
  async function deferTestUtilToSubProcess(utilName, args) {
    if (!internalState.subProcess) {
      throw new Error(`contentEngine().test.${utilName}() can only be called when content engine is running.`);
    }

    // @ts-ignore
    const messageId = _crypto.default.randomUUID();
    internalState.subProcess.send({
      type: `CONTENT_ENGINE_CHILD_INVOKE_TEST_UTIL`,
      payload: {
        args,
        messageId,
        utilName
      }
    });
    const message = await onceReceived(`CONTENT_ENGINE_CHILD_INVOKE_TEST_UTIL_RESULT--${messageId}`);
    if (message !== null && message !== void 0 && message.error) {
      if (message.error.startsWith(`Error:`)) {
        message.error = message.error.replace(`Error: `, ``);
      }
      const newErr = new Error(message.error.message);
      newErr.stack = message.error.stack;
      throw newErr;
    }
    return message === null || message === void 0 ? void 0 : message.result;
  }
  function getStore() {
    var _engineOptions10;
    internalState.store ||= (0, _lmdbDatastore.getLmdbStore)({
      dbPath: (0, _lmdbDatastore.getDefaultDbPath)((_engineOptions10 = engineOptions) === null || _engineOptions10 === void 0 ? void 0 : _engineOptions10.directory)
    });
    return internalState.store;
  }
  const engineApi = {
    initialize,
    sync,
    restart,
    stop,
    config: async newConfig => {
      const normConfig = {
        directory: newConfig.directory || process.cwd(),
        ...(newConfig || {})
      };
      if (JSON.stringify(normConfig) !== JSON.stringify(engineOptions)) {
        _reporter.default.info(`[content-engine] restarting process since config changed`);
        await stop();
        const newEngine = contentEngine(normConfig);

        // update the engineApi with the new engine's methods
        // so that calling engine.sync() will use the new engine config instead of the old one
        Object.keys(engineApi).forEach(key => {
          engineApi[key] = newEngine[key];
        });
        return newEngine;
      } else {
        _reporter.default.verbose(`[content-engine] reusing existing engine since the config didn't change`);
        return engineApi;
      }
    },
    test: throwOutsideTestEnv({
      getNodes: () => deferTestUtilToSubProcess(`getNodes`, []),
      getNodesByType: (...args) => deferTestUtilToSubProcess(`getNodesByType`, [...args]),
      getNode: (...args) => deferTestUtilToSubProcess(`getNode`, [...args]),
      query: (...args) => deferTestUtilToSubProcess(`query`, [...args])
    }),
    store: {
      getNode: id => getStore().getNode(id),
      getTypes: () => getStore().getTypes(),
      countNodes: type => getStore().countNodes(type),
      getNodes: () => getStore().iterateNodes(),
      getNodesByType: type => getStore().iterateNodesByType(type),
      runQuery: args => {
        process.env.GATSBY_EXPERIMENTAL_LMDB_INDEXES ||= `1`;
        return getStore().runQuery(args);
      }
    },
    getProcess() {
      createSubProcessIfNoneExists({
        env: internalState.env
      });
      return internalState.subProcess.process;
    },
    onStdOut(callback) {
      internalState.stdOutListeners.push(callback);
    },
    onStdErr(callback) {
      internalState.stdErrListeners.push(callback);
    },
    onMessage(callback) {
      internalState.messageListeners.push(callback);
    },
    sendMessage(message) {
      if (internalState.subProcess) {
        internalState.subProcess.send(message);
      } else {
        throw new Error(`contentEngine().sendMessage() can only be called when content engine is running.`);
      }
    },
    clearListeners() {
      internalState.stdErrListeners = [];
      internalState.stdOutListeners = [];
      internalState.messageListeners = [];
    }
  };
  return engineApi;
};
exports.contentEngine = contentEngine;
function throwOutsideTestEnv(fns) {
  return Object.fromEntries(Object.entries(fns).map(([name, fn]) => [name, (...args) => {
    if (process.env.NODE_ENV !== `test`) {
      throw new Error(`contentEngine().test.${name}() can only be called from within tests.`);
    }
    return fn(...args);
  }]));
}
//# sourceMappingURL=index.js.map