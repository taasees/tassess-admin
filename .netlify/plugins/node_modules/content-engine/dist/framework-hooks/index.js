"use strict";

exports.__esModule = true;
exports.frameworkHooks = void 0;
exports.setFrameworkHook = setFrameworkHook;
const frameworkHooks = {
  startup: {
    before: async () => {},
    after: async () => {}
  },
  sourceNodes: {
    before: async () => {},
    after: async () => {}
  },
  customizeSchema: {
    before: async () => {},
    after: async () => {}
  },
  buildSchema: {
    before: async () => {},
    after: async () => {}
  },
  sync: {
    before: async () => {},
    after: async () => {}
  }
};
exports.frameworkHooks = frameworkHooks;
const globalState = {
  context: {}
};
process.on(`message`, msg => {
  if ((msg === null || msg === void 0 ? void 0 : msg.type) === `CONTENT_ENGINE_FRAMEWORK_CONTEXT`) {
    globalState.context = msg.context || {};
  }
});
function makeInvertedPromise() {
  let res = null;
  let rej = null;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  return {
    promise,
    resolve: res,
    reject: rej
  };
}
function setFrameworkHook(name, fn) {
  if (typeof fn !== `function`) {
    throw new Error(`Framework hook must be a function`);
  }
  if (!frameworkHooks[name]) {
    throw new Error(`Framework hook "${name}" does not exist`);
  }
  const defaultHookState = {
    before: {
      resolve: null,
      reject: null,
      promise: null
    },
    after: {
      resolve: null,
      reject: null,
      promise: null
    },
    userPromise: null
  };
  const hookState = {
    ...defaultHookState
  };
  function runAPI() {
    if (hookState.before.resolve) {
      hookState.before.resolve(null);
    }
    return hookState.after.promise || Promise.resolve();
  }
  frameworkHooks[name].before = async () => {
    try {
      if (!hookState.before.promise) {
        hookState.before = makeInvertedPromise();
        hookState.after = makeInvertedPromise();
      } else {
        throw new Error(`Framework hook "${name}" is already running. This is a bug or you're calling engine.sync() multiple times at once. Hooks may only run one a time.`);
      }
      hookState.userPromise = fn({
        runAPI,
        context: globalState.context
      }).catch(err => {
        var _hookState$before$rej, _hookState$before;
        (_hookState$before$rej = (_hookState$before = hookState.before).reject) === null || _hookState$before$rej === void 0 ? void 0 : _hookState$before$rej.call(_hookState$before, err);
        throw err;
      });
      await hookState.before.promise;
    } finally {
      hookState.before = {
        ...defaultHookState.before
      };
    }
  };
  frameworkHooks[name].after = async () => {
    try {
      if (hookState.after.resolve) {
        hookState.after.resolve(null);
      }
      if (hookState.userPromise) {
        await hookState.userPromise;
      }
    } finally {
      hookState.userPromise = null;
      hookState.after = {
        ...defaultHookState.after
      };
    }
  };
}
//# sourceMappingURL=index.js.map